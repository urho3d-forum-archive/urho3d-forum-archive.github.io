<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>Field Diamond Square for Terrain Generation</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>

  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="40" alt="Urho3D" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">Archive 17/01/2023.</div>
    <h1 class="topic-title">Field Diamond Square for Terrain Generation</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Hey!</p>
<p>Does this make any sense to anyone? I’m trying to get the basic concept of this.I’m asking because if its done its pretty much a field diamond square procedual method that could use time and a hash table to create infinite terrain with wrapping.</p>
<p>Generated picture <a href="http://tinypic.com/view.php?pic=aaho3t&amp;s=8#.VBjW3K1hWio" rel="nofollow noopener">tinypic.com/view.php?pic=aaho3t&amp;s=8#.VBjW3K1hWio</a></p>
<p>Javascript demostration <a href="http://tatarize.nfshost.com/FieldDiamondSquare.htm" rel="nofollow noopener">tatarize.nfshost.com/FieldDiamondSquare.htm</a><br/>
Basic Algorithm and theory of use <a href="http://godsnotwheregodsnot.blogspot.com/2013/11/field-diamond-squared-fractal-terrain.html" rel="nofollow noopener">godsnotwheregodsnot.blogspot.com … rrain.html</a></p>
<p>Vivienne</p>
<p>The Javascript Code</p>
<pre><code class="lang-auto">function diamondSquaredMap(x, y, width, height, iterations) {
    var map = fieldDiamondSquared(x, y, x+width, y+height, iterations);

    var maxdeviation = getMaxDeviation(iterations);

    for (var j = 0; j &lt; width; j++) {
        for (var k = 0; k &lt; height; k++) {
            map[j][k] = map[j][k] / maxdeviation;
        }
    }
    return map;

    function create2DArray(d1, d2) {
        var x = new Array(d1),
                i = 0,
                j = 0;

        for (i = 0; i &lt; d1; i += 1) {
            x[i] = new Array(d2);
        }
        return x;
    }

    function fieldDiamondSquared(x0, y0, x1, y1, iterations) {
        if (x1 &lt; x0) { return null; }
        if (y1 &lt; y0) { return null; }
        var finalwidth  = x1 - x0;
        var finalheight = y1 - y0;
        var finalmap = create2DArray(finalwidth, finalheight);
        if (iterations === 0) {
            for (var j = 0; j &lt; finalwidth; j++) {
                for (var k = 0; k &lt; finalheight; k++) {
                    finalmap[j][k] =  displace(iterations,x0+j,y0+k) ;
                }
            }
            return finalmap;
        }
        var ux0 = Math.floor(x0 / 2) - 1;
        var uy0 = Math.floor(y0 / 2) - 1;
        var ux1 = Math.ceil(x1 / 2) + 1;
        var uy1 = Math.ceil(y1 / 2) + 1;
        var uppermap = fieldDiamondSquared(ux0, uy0, ux1, uy1, iterations-1);

        var uw = ux1 - ux0;
        var uh = uy1 - uy0;

        var cx0 = ux0 * 2;
        var cy0 = uy0 * 2;

        var cw = uw*2-1;
        var ch = uh*2-1;
        var currentmap = create2DArray(cw,ch);

        for (var j = 0; j &lt; uw; j++) {
            for (var k = 0; k &lt; uh; k++) {
                currentmap[j*2][k*2] = uppermap[j][k];
            }
        }
        var xoff = x0 - cx0;
        var yoff = y0 - cy0;
        for (var j = 1; j &lt; cw-1; j += 2) {
            for (var k = 1; k &lt; ch-1; k += 2) {
                currentmap[j][k] = ((currentmap[j - 1][k - 1] + currentmap[j - 1][k + 1] + currentmap[j + 1][k - 1] + currentmap[j + 1][k + 1]) / 4) + displace(iterations,cx0+j,cy0+k);
            }
        }
        for (var j = 1; j &lt; cw-1; j += 2) {
            for (var k = 2; k &lt; ch-1; k += 2) {
                currentmap[j][k] = ((currentmap[j - 1][k]     + currentmap[j + 1][k]     + currentmap[j][k - 1]     + currentmap[j][k + 1]) / 4) + displace(iterations,cx0+j,cy0+k);
            }
        }
        for (var j = 2; j &lt; cw-1; j += 2) {
            for (var k = 1; k &lt; ch-1; k += 2) {
                currentmap[j][k] = ((currentmap[j - 1][k]     + currentmap[j + 1][k]     + currentmap[j][k - 1]     + currentmap[j][k + 1]) / 4) + displace(iterations,cx0+j,cy0+k);
            }
        }

        for (var j = 0; j &lt; finalwidth; j++) {
            for (var k = 0; k &lt; finalheight; k++) {
                finalmap[j][k] = currentmap[j+xoff][k+yoff];
            }
        }

        return finalmap;
    }

    // Random function to offset
    function displace(iterations, x, y) {
        return (((PRH(iterations,x,y) - 0.5)*2)) / (iterations+1);
    }

    function getMaxDeviation(iterations) {
        var dev = 0.5 / (iterations+1);
        if (iterations &lt;= 0) return dev;
        return getMaxDeviation(iterations-1) + dev;
    }

    //This function returns the same result for given values but should be somewhat random.
    function PRH(iterations,x,y) {
        var hash;
        x &amp;= 0xFFF;
        y &amp;= 0xFFF;
        iterations &amp;= 0xFF;
        hash = (iterations &lt;&lt; 24);
        hash |= (y &lt;&lt; 12);
        hash |= x;
        var rem = hash &amp; 3;
        var h = hash;

        switch (rem) {
            case 3:
                hash += h;
                hash ^= hash &lt;&lt; 32;
                hash ^= h &lt;&lt; 36;
                hash += hash &gt;&gt; 22;
                break;
            case 2:
                hash += h;
                hash ^= hash &lt;&lt; 22;
                hash += hash &gt;&gt; 34;
                break;
            case 1:
                hash += h;
                hash ^= hash &lt;&lt; 20;
                hash += hash &gt;&gt; 2;
        }
        hash ^= hash &lt;&lt; 6;
        hash += hash &gt;&gt; 10;
        hash ^= hash &lt;&lt; 8;
        hash += hash &gt;&gt; 34;
        hash ^= hash &lt;&lt; 50;
        hash += hash &gt;&gt; 12;

        return (hash &amp; 0xFFFF) / 0xFFFF;
    }[/code]

C++ Code / Somewhat functional at least no memory leak error
[code]///Headers
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;png++/png.hpp&gt;
#include &lt;png++/image.hpp&gt;
#include &lt;png++/rgb_pixel.hpp&gt;



using namespace std;

/// Terraub Functions
double * getFieldSquareTerrain(int x0,int y0, int x1, int y1, unsigned int iterations);
double displace(unsigned int iterations,int x, int y);
double getMaxDeviation(unsigned int iterations);
double PRH(unsigned iterations, int x, int y);
double * getFieldDiamondSquaredMap(int x, int y, int width, int height, unsigned int iterations);

//Size of the grid to generate
//This must be 2^n+1 (e.g. 257)
const int DATA_SIZE = 1024;

void SaveTerrFile(const double * image);

/// Main function
int main()
{
    /// Define Settings
    int width=1024;
    int height=1024;
    int iterations=1023;
    int x=0;
    int y=0;

    // allocate memory
    double * map=new double[width*height];

    map=getFieldDiamondSquaredMap(x,y,width,height,iterations);

    SaveTerrFile(map);

    return 1;
}

double * getFieldDiamondSquaredMap(int x, int y, int width, int height, unsigned int iterations)
{
    /// Allocate memory for final mapdouble
    double * map = new double[width*height];

    map = getFieldSquareTerrain(x, y, x+width, y+height, iterations);

    double maxdeviation = getMaxDeviation(iterations);

    for (unsigned int x = 0; x &lt; width; x++)
    {
        for (unsigned int  y = 0; y &lt; height; y++)
        {
            map[x*y] = map[x*y] / maxdeviation;
        }
    }

    return map;
}

double * getFieldSquareTerrain(int x0, int y0, int x1, int y1, unsigned int iterations)
{
    /// Define final height and width
    int finalwidth  = x1 - x0;
    int finalheight = y1 - y0;

    /// Allocate memory for final map
    double * finalmap = new double[finalwidth*finalheight];

    /// Test iteration
    if (iterations == 0)
    {
        for (unsigned int x = 0; x &lt; finalwidth; x++)
        {
            for (unsigned int y = 0; y &lt; finalheight; y++)
            {
                finalmap[x*y] =  displace(iterations,x0+x,y0+y) ;
            }
            return finalmap;
        }
    }

    /// Define ceil and floor
    int upper_x0=floor(x0/2) - 1;
    int upper_y0=floor(y0/2) - 1;
    int upper_x1=ceil(x1/2)+1;
    int upper_y1=ceil(y1/2)+1;

    /// Define upper height and width for upper maps
    int upper_xwidth= upper_x1-upper_x0;
    int upper_yheight= upper_y1-upper_y0;

    /// Allocate memory for upper map width and height
    double * uppermap = new double[upper_xwidth*upper_yheight];

    /// Pass another iteration
    uppermap = getFieldSquareTerrain(upper_x0, upper_y0, upper_x1, upper_y1, iterations-1);

    /// Define counter height and width
    int counter_x0= upper_x0 * 2;
    int counter_y0= upper_y0 * 2;

    int counter_width = upper_xwidth*2-1;
    int counter_height = upper_yheight*2-1;

    /// Allocate memory for currentmap using counter height and width
    double * currentmap = new double[counter_width*counter_height];

    /// Copy information to double map
    for (unsigned int x = 0; x &lt; upper_xwidth; x++)
    {
        for (unsigned int y = 0; y&lt; upper_yheight; y++)
        {
            currentmap[(x*2)*(y*2)] = uppermap[x*y];
        }
    }

    /// Define offset
    int xoff = x0 - counter_x0;
    int yoff = y0 - counter_y0;

    /// Use a diamond mehod algorithm
    for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
    {
        for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
        {
            currentmap[x*y] = ((currentmap[(x - 1)*(y - 1)] + currentmap[(x - 1)*(y + 1)] + currentmap[(x + 1)*(y - 1)] + currentmap[(x + 1)*(y + 1)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
        }
    }
    for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
    {
        for (unsigned int y = 2; y &lt; counter_height-1; y += 2)
        {
            currentmap[x*y] = ((currentmap[(x - 1)*y]     + currentmap[(x + 1)*y]     + currentmap[x*(y - 1)]     + currentmap[x*(y + 1)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
        }
    }
    for (unsigned int x = 2; x &lt; counter_width-1; x += 2)
    {
        for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
        {
            currentmap[x*y] = ((currentmap[(x - 1)*y]     + currentmap[(x + 1)*y]     + currentmap[x*(y - 1)]     + currentmap[x*(y + 1)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
        }
    }

    /// Copy actual information to returned map
    for (unsigned int x = 0; x &lt; finalwidth; x++)
    {
        for (unsigned int y = 0; y &lt; finalheight; y++)
        {
            finalmap[x*y] = currentmap[(x+xoff)*(y+yoff)];

        }
    }

    return finalmap;
}

/// Random function to offset
double displace(unsigned int  iterations, int x, int y)
{
    return (((PRH(iterations,x,y) - 0.5)*2)) / (iterations+1);
}

/// Get maximum deviations
double getMaxDeviation(unsigned int iterations)
{
    double dev = 0.5 / (iterations+1);
    if (iterations &lt;= 0) return dev;
    return getMaxDeviation(iterations-1) + dev;
}

///This function returns the same result for given values but should be somewhat random.
double PRH(unsigned iterations, int x, int y)
{
    unsigned long long hash;
    x &amp;= 0xFFF;
    y &amp;= 0xFFF;
    iterations &amp;= 0xFF;
    hash = (iterations &lt;&lt; 24);
    hash |= (y &lt;&lt; 12);
    hash |= x;
    unsigned long long rem = hash &amp; 3;
    unsigned long long h = hash;

    switch (rem)
    {
    case 3:
        hash += h;
        hash ^= hash &lt;&lt; 32;
        hash ^= h &lt;&lt; 36;
        hash += hash &gt;&gt; 22;
        break;
    case 2:
        hash += h;
        hash ^= hash &lt;&lt; 22;
        hash += hash &gt;&gt; 34;
        break;
    case 1:
        hash += h;
        hash ^= hash &lt;&lt; 20;
        hash += hash &gt;&gt; 2;
    }
    hash ^= hash &lt;&lt; 6;
    hash += hash &gt;&gt; 10;
    hash ^= hash &lt;&lt; 8;
    hash += hash &gt;&gt; 34;
    hash ^= hash &lt;&lt; 50;
    hash += hash &gt;&gt; 12;

    return (hash &amp; 0xFFFF) / static_cast&lt;double&gt;(0xFFFF);
}


void SaveTerrFile(const double * image)
{
    png::image&lt; png::rgb_pixel &gt; newimage(1024, 1024);


    for (unsigned int y = 0; y &lt; newimage.get_width(); ++y)
    {
        for (unsigned int x = 0; x &lt; newimage.get_height(); ++x)
        {
            int col=(int)(image[x*y]+1)*255;
            newimage[y][x] = png::rgb_pixel(col,col,col);
            // non-checking equivalent of image.set_pixel(x, y, ...);
        }
    }

    newimage.write("rgb.png");
}</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Non-Working revised for the 1d array</p>
<p>[code]///Headers<br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> </p>
<p><span class="hashtag">#include</span> &lt;stdio.h&gt;<br/>
<span class="hashtag">#include</span> &lt;stdlib.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;png++/png.hpp&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/image.hpp&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/rgb_pixel.hpp&gt;</p>
<p>using namespace std;</p>
<p>/// Terraub Functions<br/>
double * getFieldSquareTerrain(int x0,int y0, int x1, int y1, unsigned int iterations);<br/>
double displace(unsigned int iterations,int x, int y);<br/>
double getMaxDeviation(unsigned int iterations);<br/>
double PRH(unsigned iterations, int x, int y);<br/>
double * getFieldDiamondSquaredMap(int x, int y, int width, int height, unsigned int iterations);</p>
<p>//Size of the grid to generate<br/>
//This must be 2^n+1 (e.g. 257)<br/>
const int DATA_SIZE = 1024;</p>
<p>void SaveTerrFile(const double * image);</p>
<p>/// Main function<br/>
int main()<br/>
{<br/>
/// Define Settings<br/>
int width=1024;<br/>
int height=1024;<br/>
int iterations=12;<br/>
int x=0;<br/>
int y=0;</p>
<pre><code>// allocate memory
double * map=new double[width*height];

map=getFieldDiamondSquaredMap(x,y,width,height,iterations);

SaveTerrFile(map);

return 1;
</code></pre>
<p>}</p>
<p>double * getFieldDiamondSquaredMap(int x, int y, int width, int height, unsigned int iterations)<br/>
{<br/>
/// Allocate memory for final mapdouble<br/>
double * map = new double[width*height];</p>
<pre><code>map = getFieldSquareTerrain(x, y, x+width, y+height, iterations);

double maxdeviation = getMaxDeviation(iterations);

for (unsigned int x = 0; x &lt; width; x++)
{
    for (unsigned int  y = 0; y &lt; height; y++)
    {
        map[x+(y*width)] = map[x+(y*width)] / maxdeviation;
    }
}

return map;
</code></pre>
<p>}</p>
<p>double * getFieldSquareTerrain(int x0, int y0, int x1, int y1, unsigned int iterations)<br/>
{<br/>
/// Define final height and width<br/>
int finalwidth  = x1 - x0;<br/>
int finalheight = y1 - y0;</p>
<pre><code>/// Allocate memory for final map
double * finalmap = new double[finalwidth*finalheight];

/// Test iteration
if (iterations == 0)
{
    for (unsigned int x = 0; x &lt; finalwidth; x++)
    {
        for (unsigned int y = 0; y &lt; finalheight; y++)
        {
            finalmap[x+(y*finalwidth)] =  displace(iterations,x0+x,y0+y) ;
        }
        return finalmap;
    }
}

/// Define ceil and floor
int upper_x0=floor(x0/2) - 1;
int upper_y0=floor(y0/2) - 1;
int upper_x1=ceil(x1/2)+1;
int upper_y1=ceil(y1/2)+1;

/// Define upper height and width for upper maps
int upper_xwidth= upper_x1-upper_x0;
int upper_yheight= upper_y1-upper_y0;

/// Allocate memory for upper map width and height
double * uppermap = new double[upper_xwidth*upper_yheight];

/// Pass another iteration
uppermap = getFieldSquareTerrain(upper_x0, upper_y0, upper_x1, upper_y1, iterations-1);

/// Define counter height and width
int counter_x0= upper_x0 * 2;
int counter_y0= upper_y0 * 2;

int counter_width = upper_xwidth*2-1;
int counter_height = upper_yheight*2-1;

/// Allocate memory for currentmap using counter height and width
double * currentmap = new double[counter_width*counter_height];

/// Copy information to double map
for (unsigned int x = 0; x &lt; upper_xwidth; x++)
{
    for (unsigned int y = 0; y&lt; upper_yheight; y++)
    {
        currentmap[(x*2)+((y*counter_width)*2)] = uppermap[x+(y*upper_xwidth)];
    }
}

/// Define offset
int xoff = x0 - counter_x0;
int yoff = y0 - counter_y0;

/// Use a diamond mehod algorithm
for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+((y-1)*counter_width)] + currentmap[(x - 1)+((y+1)*counter_width)] + currentmap[(x + 1)+((y-1)*counter_width)] + currentmap[(x + 1)+((y+1)*counter_width)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}
for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 2; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+(y*counter_width)]     + currentmap[(x + 1)+(y*counter_width)]     + currentmap[x+((y-1)*counter_width)]     + currentmap[x+((y+1)*counter_width)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}
for (unsigned int x = 2; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+(y*counter_width)]     + currentmap[(x + 1)+(y*counter_width)]     + currentmap[x+((y-1)*counter_width)]     + currentmap[x+((y+1)*counter_width) ]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}

/// Copy actual information to returned map
for (unsigned int x = 0; x &lt; finalwidth; x++)
{
    for (unsigned int y = 0; y &lt; finalheight; y++)
    {
        finalmap[x+(y*finalwidth)] = currentmap[(x+xoff)+((y+yoff)*counter_width)];

    }
}

return finalmap;
</code></pre>
<p>}</p>
<p>/// Random function to offset<br/>
double displace(unsigned int  iterations, int x, int y)<br/>
{<br/>
return (((PRH(iterations,x,y) - 0.5)*2)) / (iterations+1);<br/>
}</p>
<p>/// Get maximum deviations<br/>
double getMaxDeviation(unsigned int iterations)<br/>
{<br/>
double dev = 0.5 / (iterations+1);<br/>
if (iterations &lt;= 0) return dev;<br/>
return getMaxDeviation(iterations-1) + dev;<br/>
}</p>
<p>///This function returns the same result for given values but should be somewhat random.<br/>
double PRH(unsigned iterations, int x, int y)<br/>
{<br/>
unsigned long long hash;<br/>
x &amp;= 0xFFF;<br/>
y &amp;= 0xFFF;<br/>
iterations &amp;= 0xFF;<br/>
hash = (iterations &lt;&lt; 24);<br/>
hash |= (y &lt;&lt; 12);<br/>
hash |= x;<br/>
unsigned long long rem = hash &amp; 3;<br/>
unsigned long long h = hash;</p>
<pre><code>switch (rem)
{
case 3:
    hash += h;
    hash ^= hash &lt;&lt; 32;
    hash ^= h &lt;&lt; 36;
    hash += hash &gt;&gt; 22;
    break;
case 2:
    hash += h;
    hash ^= hash &lt;&lt; 22;
    hash += hash &gt;&gt; 34;
    break;
case 1:
    hash += h;
    hash ^= hash &lt;&lt; 20;
    hash += hash &gt;&gt; 2;
}
hash ^= hash &lt;&lt; 6;
hash += hash &gt;&gt; 10;
hash ^= hash &lt;&lt; 8;
hash += hash &gt;&gt; 34;
hash ^= hash &lt;&lt; 50;
hash += hash &gt;&gt; 12;

return (hash &amp; 0xFFFF) / static_cast&lt;double&gt;(0xFFFF);
</code></pre>
<p>}</p>
<p>void SaveTerrFile(const double * image)<br/>
{<br/>
png::image&lt; png::rgb_pixel &gt; newimage(1024, 1024);</p>
<pre><code>for (unsigned int y = 0; y &lt; newimage.get_width(); ++y)
{
    for (unsigned int x = 0; x &lt; newimage.get_height(); ++x)
    {
        int col=(int)(image[x+(y*newimage.get_width())]+1)*255;
        newimage[y][x] = png::rgb_pixel(col,col,col);
        // non-checking equivalent of image.set_pixel(x, y, ...);
    }
}

newimage.write("rgb.png");
</code></pre>
<p>}</p>
<p>[/code]</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>This code test resulted in. The image before additional processing and saving to disk in a png.</p>
<p>0<br/>
-0.000926858<br/>
-8.59313e-05<br/>
0.000740951<br/>
-0.00112015<br/>
-0.00146794<br/>
0.000344809<br/>
1.85939e-05<br/>
-0.000501624<br/>
0.000191158</p>
<pre><code class="lang-auto">void SaveTerrFile(const double * image)
{
    png::image&lt; png::rgb_pixel &gt; newimage(1024, 1024);


    cout &lt;&lt; "\r\n" &lt;&lt; image[0];
    cout &lt;&lt; "\r\n" &lt;&lt; image[1];
    cout &lt;&lt; "\r\n" &lt;&lt; image[2];
    cout &lt;&lt; "\r\n" &lt;&lt; image[3];
    cout &lt;&lt; "\r\n" &lt;&lt; image[4];
    cout &lt;&lt; "\r\n" &lt;&lt; image[5];
    cout &lt;&lt; "\r\n" &lt;&lt; image[6];
    cout &lt;&lt; "\r\n" &lt;&lt; image[7];
    cout &lt;&lt; "\r\n" &lt;&lt; image[8];
    cout &lt;&lt; "\r\n" &lt;&lt; image[9];


    for (unsigned int y = 0; y &lt; newimage.get_width(); ++y)
    {
        for (unsigned int x = 0; x &lt; newimage.get_height(); ++x)
        {
            int col=(int)(image[x+(y*newimage.get_width())]+.1)*255;
            newimage[y][x] = png::rgb_pixel(col,col,col);
            // non-checking equivalent of image.set_pixel(x, y, ...);
        }
    }

    newimage.write("rgb.png");
}</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Current Code (Still little bug - <a href="http://tinypic.com/r/oistxi/8" rel="nofollow noopener">tinypic.com/r/oistxi/8</a>)</p>
<p>Close but still. Argh :-/</p>
<p>[code]///Headers<br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> </p>
<p><span class="hashtag">#include</span> &lt;stdio.h&gt;<br/>
<span class="hashtag">#include</span> &lt;stdlib.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;png++/png.hpp&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/image.hpp&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/rgb_pixel.hpp&gt;</p>
<p>using namespace std;</p>
<p>/// Terraub Functions<br/>
double * getFieldSquareTerrain(int x0,int y0, int x1, int y1, double iterations);<br/>
double displace(double iterations,int x, int y);<br/>
double getMaxDeviation(double iterations);<br/>
double PRH(unsigned iterations, int x, int y);<br/>
double * getFieldDiamondSquaredMap(int x, int y, int width, int height, double iterations);</p>
<p>//Size of the grid to generate<br/>
//This must be 2^n+1 (e.g. 257)<br/>
const int DATA_SIZE = 1024;</p>
<p>void SaveTerrFile(const double * image);</p>
<p>/// Main function<br/>
int main()<br/>
{<br/>
/// Define Settings<br/>
int width=1024;<br/>
int height=1024;<br/>
double iterations=12.0f;<br/>
int x=0;<br/>
int y=0;</p>
<pre><code>// allocate memory
double * map=new double[width*height];

map=getFieldDiamondSquaredMap(x,y,width,height,iterations);

SaveTerrFile(map);

return 1;
</code></pre>
<p>}</p>
<p>double * getFieldDiamondSquaredMap(int x, int y, int width, int height, double iterations)<br/>
{<br/>
/// Allocate memory for final mapdouble<br/>
double * map = new double[width*height];</p>
<pre><code>map = getFieldSquareTerrain(x, y, x+width, y+height, iterations);

double maxdeviation = getMaxDeviation(iterations);

for (unsigned int x = 0; x &lt; width; x++)
{
    for (unsigned int  y = 0; y &lt; height; y++)
    {
        map[x+(y*width)] = map[x+(y*width)] / maxdeviation;
    }
}

return map;
</code></pre>
<p>}</p>
<p>double * getFieldSquareTerrain(int x0, int y0, int x1, int y1, double iterations)<br/>
{<br/>
/// Define final height and width<br/>
int finalwidth  = x1 - x0;<br/>
int finalheight = y1 - y0;</p>
<pre><code>/// Allocate memory for final map
double * finalmap = new double[finalwidth*finalheight];

/// Test iteration
if (iterations == 0)
{
    for (unsigned int x = 0; x &lt; finalwidth; x++)
    {
        for (unsigned int y = 0; y &lt; finalheight; y++)
        {
            finalmap[x+(y*finalwidth)] =  displace(iterations,x0+x,y0+y) ;
        }
        return finalmap;
    }
}

/// Define ceil and floor
int upper_x0=floor(x0/2) - 1;
int upper_y0=floor(y0/2) - 1;
int upper_x1=ceil(x1/2)+1;
int upper_y1=ceil(y1/2)+1;

/// Define upper height and width for upper maps
int upper_xwidth= upper_x1-upper_x0;
int upper_yheight= upper_y1-upper_y0;

/// Allocate memory for upper map width and height
double * uppermap = new double[upper_xwidth*upper_yheight];

/// Pass another iteration
uppermap = getFieldSquareTerrain(upper_x0, upper_y0, upper_x1, upper_y1, iterations-1);

/// Define counter height and width
int counter_x0= upper_x0 * 2;
int counter_y0= upper_y0 * 2;

int counter_width = upper_xwidth*2-1;
int counter_height = upper_yheight*2-1;

/// Allocate memory for currentmap using counter height and width
double * currentmap = new double[counter_width*counter_height];

/// Copy information to double map
for (unsigned int x = 0; x &lt; upper_xwidth; x++)
{
    for (unsigned int y = 0; y&lt; upper_yheight; y++)
    {
        currentmap[(x*2)+((y*counter_width)*2)] = uppermap[x+(y*upper_xwidth)];
    }
}

/// Define offset
int xoff = x0 - counter_x0;
int yoff = y0 - counter_y0;

/// Use a diamond mehod algorithm
for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+((y-1)*counter_width)] + currentmap[(x - 1)+((y+1)*counter_width)] + currentmap[(x + 1)+((y-1)*counter_width)] + currentmap[(x + 1)+((y+1)*counter_width)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}
for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 2; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+(y*counter_width)]     + currentmap[(x + 1)+(y*counter_width)]     + currentmap[x+((y-1)*counter_width)]     + currentmap[x+((y+1)*counter_width)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}
for (unsigned int x = 2; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+(y*counter_width)]     + currentmap[(x + 1)+(y*counter_width)]     + currentmap[x+((y-1)*counter_width)]     + currentmap[x+((y+1)*counter_width) ]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}

/// Copy actual information to returned map
for (unsigned int x = 0; x &lt; finalwidth; x++)
{
    for (unsigned int y = 0; y &lt; finalheight; y++)
    {
        finalmap[x+(y*finalwidth)] = currentmap[(x+xoff)+((y+yoff)*counter_width)];

    }
}

return finalmap;
</code></pre>
<p>}</p>
<p>/// Random function to offset<br/>
double displace(double iterations,int x, int y)<br/>
{<br/>
return (((PRH(iterations,x,y) - 0.5)*2)) / (iterations+1);<br/>
}</p>
<p>/// Get maximum deviations<br/>
double getMaxDeviation(double iterations)<br/>
{<br/>
double dev = 0.5 / (iterations+1);<br/>
if (iterations &lt;= 0) return dev;<br/>
return getMaxDeviation(iterations-1) + dev;<br/>
}</p>
<p>///This function returns the same result for given values but should be somewhat random.<br/>
double PRH(unsigned iterations, int x, int y)<br/>
{<br/>
unsigned long long hash;<br/>
x &amp;= 0xFFF;<br/>
y &amp;= 0xFFF;<br/>
iterations &amp;= 0xFF;<br/>
hash = (iterations &lt;&lt; 24);<br/>
hash |= (y &lt;&lt; 12);<br/>
hash |= x;<br/>
unsigned long long rem = hash &amp; 3;<br/>
unsigned long long h = hash;</p>
<pre><code>switch (rem)
{
case 3:
    hash += h;
    hash ^= hash &lt;&lt; 32;
    hash ^= h &lt;&lt; 36;
    hash += hash &gt;&gt; 22;
    break;
case 2:
    hash += h;
    hash ^= hash &lt;&lt; 22;
    hash += hash &gt;&gt; 34;
    break;
case 1:
    hash += h;
    hash ^= hash &lt;&lt; 20;
    hash += hash &gt;&gt; 2;
}
hash ^= hash &lt;&lt; 6;
hash += hash &gt;&gt; 10;
hash ^= hash &lt;&lt; 8;
hash += hash &gt;&gt; 34;
hash ^= hash &lt;&lt; 50;
hash += hash &gt;&gt; 12;

return (hash &amp; 0xFFFF) / static_cast&lt;double&gt;(0xFFFF);
</code></pre>
<p>}</p>
<p>void SaveTerrFile(const double * image)<br/>
{<br/>
png::image&lt; png::rgb_pixel &gt; newimage(1024, 1024);</p>
<pre><code>for (unsigned int y = 0; y &lt; newimage.get_width(); ++y)
{
    for (unsigned int x = 0; x &lt; newimage.get_height(); ++x)
    {
        int col=(int)(image[x+(y*newimage.get_width())]+1)*255;
        newimage[y][x] = png::rgb_pixel(col,col,col);
        // non-checking equivalent of image.set_pixel(x, y, ...);
    }
}

newimage.write("rgb.png");
</code></pre>
<p>}</p>
<pre><code>[/code]</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1151_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">hdunderscore</div>
          <div class="post_content">
<p>You left out a few functions from the last snippet.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<aside class="quote">
<div class="title">
<div class="quote-controls"></div>
 hd_:</div>
<blockquote>
<p>You left out a few functions from the last snippet.</p>
</blockquote>
</aside>
<p>Thanks. I placed the whole code.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1151_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">hdunderscore</div>
          <div class="post_content">
<p>The last thing I can think of is this:</p>
<pre><code class="lang-auto"></code></pre>
<p>Probably should be double too.</p>
<p>Edit:</p>
<p>Nevermind, it should probably be a signed int:<br/>
<a href="http://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it" rel="nofollow noopener">stackoverflow.com/questions/1822 … you-use-it</a></p>
<p>In Javascript, numbers are usually doubles but when you bit shift them they are treated as signed ints. In JavaScript, there is a special operator for unsigned bit shift but the code supplied only uses the signed bit shift, so you probably want to use signed int on PRH.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>[quote=“hd_”]The last thing I can think of is this:</p>
<pre><code class="lang-auto"></code></pre>
<p>Probably should be double too.[/quote]</p>
<p>Changing that causes a  error.</p>
<p><code>/media/home2/vivienne/testingc++/HeightWidth.cpp||In function ?double PRH(double, int, int)?:|
/media/home2/vivienne/testingc++/HeightWidth.cpp|186|error: invalid operands of types ?double? and ?int? to binary ?operator&amp;?|
/media/home2/vivienne/testingc++/HeightWidth.cpp|186|error:   in evaluation of ?operator&amp;=(double, int)?|
/media/home2/vivienne/testingc++/HeightWidth.cpp|187|error: invalid operands of types ?double? and ?int? to binary ?operator&lt;&lt;?|</code></p>
<p>in</p>
<p><code>
    iterations &amp;= 0xFF;
    hash = (iterations &lt;&lt; 24);</code></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>This is a modification. I converted of final image to range to 0 to 1, then muiltiplied that to 255. Which gets better results but.</p>
<p>I rather the final image to be 0 and above only, no negative before saving without extra processing. I’m assuming the floor and ceil has to be changed??? This would allow infinite terrain a lot better. If it went from 0 to 1(or above)  without disturbing produced double data.</p>
<p>The extra c++ library I used is libpng.</p>
<p>Image produced from this method <a href="http://tinypic.com/r/2rr2cqt/8" rel="nofollow noopener">tinypic.com/r/2rr2cqt/8</a></p>
<p>[code]///Headers<br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> </p>
<p><span class="hashtag">#include</span> &lt;stdio.h&gt;<br/>
<span class="hashtag">#include</span> &lt;stdlib.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;png++/png.hpp&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/image.hpp&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/rgb_pixel.hpp&gt;</p>
<p>using namespace std;</p>
<p>/// Terraub Functions<br/>
double * getFieldSquareTerrain(int x0,int y0, int x1, int y1, double iterations);<br/>
double displace(double iterations,int x, int y);<br/>
double getMaxDeviation(double iterations);<br/>
double PRH(unsigned iterations, int x, int y);<br/>
double * getFieldDiamondSquaredMap(int x, int y, int width, int height, double iterations);</p>
<p>//Size of the grid to generate<br/>
//This must be 2^n+1 (e.g. 257)<br/>
const int DATA_SIZE = 1024;</p>
<p>void SaveTerrFile(const double * image);</p>
<p>/// Main function<br/>
int main()<br/>
{<br/>
/// Define Settings<br/>
int width=1024;<br/>
int height=1024;<br/>
double iterations=52.0f;<br/>
int x=0;<br/>
int y=0;</p>
<pre><code>// allocate memory
double * map=new double[width*height];

map=getFieldDiamondSquaredMap(x,y,width,height,iterations);

/// Set maxY and minY to 0.0f
double maxY = map[2];
double minY = map[2];

for (int x = 0; x&lt;width; x++)
{
    for(int y = 0; y&lt;height; y++)
    {
        if ((double)map[x+(y*width)] &gt; maxY)
        {
            maxY = map[x+(y*width)];
        }
        if ((double)map[x+(y*width)] &lt; minY)
        {
            minY = map[x+(y*width)];
        }
    }
}

/// Calculate height_ from 0 to 1
for(int x=0; x &lt; width; x++)
{
    for(int y=0; y &lt; height; y++)
    {
        //change range to 0..1
        map[x+(y*width)]  = (map[x+(y*width)] - minY) / (maxY - minY);


    }
}

SaveTerrFile(map);

return 1;
</code></pre>
<p>}</p>
<p>double * getFieldDiamondSquaredMap(int x, int y, int width, int height, double iterations)<br/>
{<br/>
/// Allocate memory for final mapdouble<br/>
double * map = new double[width*height];</p>
<pre><code>map = getFieldSquareTerrain(x, y, x+width, y+height, iterations);

double maxdeviation = getMaxDeviation(iterations);

for (unsigned int x = 0; x &lt; width; x++)
{
    for (unsigned int  y = 0; y &lt; height; y++)
    {
        map[x+(y*width)] = map[x+(y*width)] / maxdeviation;

    }
}

return map;
</code></pre>
<p>}</p>
<p>double * getFieldSquareTerrain(int x0, int y0, int x1, int y1, double iterations)<br/>
{<br/>
/// Define final height and width<br/>
int finalwidth  = x1 - x0;<br/>
int finalheight = y1 - y0;</p>
<pre><code>/// Allocate memory for final map
double * finalmap = new double[finalwidth*finalheight];

/// Test iteration
if (iterations == 0)
{
    for (unsigned int x = 0; x &lt; finalwidth; x++)
    {
        for (unsigned int y = 0; y &lt; finalheight; y++)
        {
            finalmap[x+(y*finalwidth)] =  displace(iterations,x0+x,y0+y) ;
        }
        return finalmap;
    }
}

/// Define ceil and floor
int upper_x0=floor(x0/2) - 1;
int upper_y0=floor(y0/2) - 1;
int upper_x1=ceil(x1/2)+1;
int upper_y1=ceil(y1/2)+1;

/// Define upper height and width for upper maps
int upper_xwidth= upper_x1-upper_x0;
int upper_yheight= upper_y1-upper_y0;

/// Allocate memory for upper map width and height
double * uppermap = new double[upper_xwidth*upper_yheight];

/// Pass another iteration
uppermap = getFieldSquareTerrain(upper_x0, upper_y0, upper_x1, upper_y1, iterations-1);

/// Define counter height and width
int counter_x0= upper_x0 * 2;
int counter_y0= upper_y0 * 2;

int counter_width = upper_xwidth*2-1;
int counter_height = upper_yheight*2-1;

/// Allocate memory for currentmap using counter height and width
double * currentmap = new double[counter_width*counter_height];

/// Copy information to double map
for (unsigned int x = 0; x &lt; upper_xwidth; x++)
{
    for (unsigned int y = 0; y&lt; upper_yheight; y++)
    {
        currentmap[(x*2)+((y*counter_width)*2)] = uppermap[x+(y*upper_xwidth)];
    }
}

/// Define offset
int xoff = x0 - counter_x0;
int yoff = y0 - counter_y0;

/// Use a diamond mehod algorithm
for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+((y-1)*counter_width)] + currentmap[(x - 1)+((y+1)*counter_width)] + currentmap[(x + 1)+((y-1)*counter_width)] + currentmap[(x + 1)+((y+1)*counter_width)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}
for (unsigned int x = 1; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 2; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+(y*counter_width)]     + currentmap[(x + 1)+(y*counter_width)]     + currentmap[x+((y-1)*counter_width)]     + currentmap[x+((y+1)*counter_width)]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}
for (unsigned int x = 2; x &lt; counter_width-1; x += 2)
{
    for (unsigned int y = 1; y &lt; counter_height-1; y += 2)
    {
        currentmap[x+(y*counter_width)] = ((currentmap[(x - 1)+(y*counter_width)]     + currentmap[(x + 1)+(y*counter_width)]     + currentmap[x+((y-1)*counter_width)]     + currentmap[x+((y+1)*counter_width) ]) / 4) + displace(iterations,counter_x0+x,counter_y0+y);
    }
}

/// Copy actual information to returned map
for (unsigned int x = 0; x &lt; finalwidth; x++)
{
    for (unsigned int y = 0; y &lt; finalheight; y++)
    {
        finalmap[x+(y*finalwidth)] = currentmap[(x+xoff)+((y+yoff)*counter_width)];

    }
}

/// Clear Memory
delete currentmap;
delete uppermap;

return finalmap;
</code></pre>
<p>}</p>
<p>/// Random function to offset<br/>
double displace(double iterations,int x, int y)<br/>
{<br/>
return (((PRH(iterations,x,y) - 0.5)*2)) / (iterations+1);<br/>
}</p>
<p>/// Get maximum deviations<br/>
double getMaxDeviation(double iterations)<br/>
{<br/>
double dev = 0.5 / (iterations+1);<br/>
if (iterations &lt;= 0) return dev;<br/>
return getMaxDeviation(iterations-1) + dev;<br/>
}</p>
<p>///This function returns the same result for given values but should be somewhat random.<br/>
double PRH(unsigned iterations, int x, int y)<br/>
{<br/>
unsigned long long hash;<br/>
x &amp;= 0xFFF;<br/>
y &amp;= 0xFFF;<br/>
iterations &amp;= 0xFF;<br/>
hash = (iterations &lt;&lt; 24);<br/>
hash |= (y &lt;&lt; 12);<br/>
hash |= x;<br/>
unsigned long long rem = hash &amp; 3;<br/>
unsigned long long h = hash;</p>
<pre><code>switch (rem)
{
case 3:
    hash += h;
    hash ^= hash &lt;&lt; 32;
    hash ^= h &lt;&lt; 36;
    hash += hash &gt;&gt; 22;
    break;
case 2:
    hash += h;
    hash ^= hash &lt;&lt; 22;
    hash += hash &gt;&gt; 34;
    break;
case 1:
    hash += h;
    hash ^= hash &lt;&lt; 20;
    hash += hash &gt;&gt; 2;
}
hash ^= hash &lt;&lt; 6;
hash += hash &gt;&gt; 10;
hash ^= hash &lt;&lt; 8;
hash += hash &gt;&gt; 34;
hash ^= hash &lt;&lt; 50;
hash += hash &gt;&gt; 12;

return (hash &amp; 0xFFFF) / static_cast&lt;double&gt;(0xFFFF);
</code></pre>
<p>}</p>
<p>void SaveTerrFile(const double * image)<br/>
{<br/>
png::image&lt; png::rgb_pixel &gt; newimage(1024, 1024);</p>
<pre><code>for (unsigned int y = 0; y &lt; newimage.get_width(); ++y)
{
    for (unsigned int x = 0; x &lt; newimage.get_height(); ++x)
    {
        int col = int(image[x+(y*newimage.get_width())]*255);
        newimage[y][x] = png::rgb_pixel(col,col,col);
        // non-checking equivalent of image.set_pixel(x, y, ...);
    }
}

newimage.write("rgb.png");
</code></pre>
<p>}<br/>
[/code]</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>