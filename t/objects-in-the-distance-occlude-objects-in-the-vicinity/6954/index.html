<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>Objects in the distance occlude objects in the vicinity</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>

  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="40" alt="Urho3D" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">Archive 17/01/2023.</div>
    <h1 class="topic-title">Objects in the distance occlude objects in the vicinity</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3546_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">heytao</div>
          <div class="post_content">
<p>Hello, everyone,<br/>
I follow the code of <a  rel="noopener nofollow ugc">Sample 10 RenderToTexture</a> to make a transformation.</p>
<p>Change one screen to two screens, and place the two screens face to face (Pic1).<br/>
<div class="lightbox-wrapper"><a class="lightbox"   rel="noopener nofollow ugc" title="pic1"><img alt="pic1" data-base62-sha1="jSmKNjeTQ16mCNUT1U4rANJZct5"  height="500" src="../../../images2/58db0ffb3c2a22a6330b34084bf3e02b.jpeg"  width="620"/><div class="meta">
<svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename">pic1</span><span class="informations">1028×828 63 KB</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>When I (the camera) is close to the screens, everything is normal, and the screen at a distance can block the screen at a distance (as shown in Pic2, Pic3).<br/>
<div class="lightbox-wrapper"><a class="lightbox"   rel="noopener nofollow ugc" title="pic2"><img alt="pic2" data-base62-sha1="xdzhOGQDST0xI5u1iiUVI23WPQa"  height="500" src="../../../images2/12fa7a8f0d0617b138537dbfd242d0b4.jpeg" width="620"/><div class="meta">
<svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename">pic2</span><span class="informations">1028×828 62 KB</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div><br/>
<div class="lightbox-wrapper"><a class="lightbox"   rel="noopener nofollow ugc" title="pic3"><img alt="pic3" data-base62-sha1="fwEIqKJ9vwhhW0NtaGqqE0fbjzd"  height="500" src="../../../images2/0c1edf4c4a195c184b200e9907e2ce91.jpeg"  width="620"/><div class="meta">
<svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename">pic3</span><span class="informations">1028×828 79.2 KB</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>When I (the camera) is far away from the screens, then strange things happen, the screen in the distance will block the screen in the vicinity (Pic4, Pic5, Pic6).<br/>
<div class="lightbox-wrapper"><a class="lightbox"   rel="noopener nofollow ugc" title="pic4"><img alt="pic4" data-base62-sha1="7Cfp2hPmAfMzd1ogcnElz7NpeWa"  height="500" src="../../../images2/9d219211ca2d5e22b72498c1e581054b.jpeg"  width="620"/><div class="meta">
<svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename">pic4</span><span class="informations">1028×828 60.1 KB</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div><br/>
<div class="lightbox-wrapper"><a class="lightbox"   rel="noopener nofollow ugc" title="pic5"><img alt="pic5" data-base62-sha1="bRxlnnRNkDuxbJdbLtxtsLeuY3u"  height="500" src="../../../images2/a7a369881d1bbfc93b9b5aff81db08fe.jpeg"  width="620"/><div class="meta">
<svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename">pic5</span><span class="informations">1028×828 56.1 KB</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div><br/>
<div class="lightbox-wrapper"><a class="lightbox"   rel="noopener nofollow ugc" title="pic6"><img alt="pic6" data-base62-sha1="pX59FT0cOvTQwldRsBxYzmSXQf9"  height="500" src="../../../images2/51b4b9d369c24ea5308416202c8ab2b9.jpeg"  width="620"/><div class="meta">
<svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename">pic6</span><span class="informations">1028×828 56.9 KB</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>I tried to modify various modes through <code>renderTexture-&gt;SetFilterMode</code>, but no effect;<br/>
I tried to set it to 0 and 1 through <code>screenTexture-&gt;SetNumLevels</code>, but it had no effect;<br/>
I tried to render a normal jpg image onto the texture, the same problem was also true.</p>
<p>Does anyone know how to solve this problem?<br/>
thanks.</p>
<p>Urho3d version: 1.7.1</p>
<p>test code below:</p>
<pre><code class="lang-cpp">//
// Copyright (c) 2008-2017 the Urho3D project.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#include &lt;Urho3D/Core/CoreEvents.h&gt;
#include &lt;Urho3D/Engine/Engine.h&gt;
#include &lt;Urho3D/Graphics/Camera.h&gt;
#include &lt;Urho3D/Graphics/Graphics.h&gt;
#include &lt;Urho3D/Graphics/Material.h&gt;
#include &lt;Urho3D/Graphics/Model.h&gt;
#include &lt;Urho3D/Graphics/Octree.h&gt;
#include &lt;Urho3D/Graphics/Renderer.h&gt;
#include &lt;Urho3D/Graphics/RenderSurface.h&gt;
#include &lt;Urho3D/Graphics/StaticModel.h&gt;
#include &lt;Urho3D/Graphics/Technique.h&gt;
#include &lt;Urho3D/Graphics/Texture2D.h&gt;
#include &lt;Urho3D/Graphics/Zone.h&gt;
#include &lt;Urho3D/Input/Input.h&gt;
#include &lt;Urho3D/Resource/ResourceCache.h&gt;
#include &lt;Urho3D/Scene/Scene.h&gt;
#include &lt;Urho3D/UI/Font.h&gt;
#include &lt;Urho3D/UI/Text.h&gt;
#include &lt;Urho3D/UI/UI.h&gt;

#include "RenderToTexture.h"
#include "Rotator.h"

#include &lt;Urho3D/DebugNew.h&gt;

URHO3D_DEFINE_APPLICATION_MAIN(RenderToTexture)

RenderToTexture::RenderToTexture(Context* context) :
    Sample(context)
{
    // Register an object factory for our custom Rotator component so that we can create them to scene nodes
    context-&gt;RegisterFactory&lt;Rotator&gt;();
}

void RenderToTexture::Start()
{
    // Execute base class startup
    Sample::Start();

    // Create the scene content
    CreateScene();

    // Create the UI content
    CreateInstructions();

    // Setup the viewport for displaying the scene
    SetupViewport();

    // Hook up to the frame update events
    SubscribeToEvents();

    // Set the mouse mode to use in the sample
    Sample::InitMouseMode(MM_RELATIVE);
}

void RenderToTexture::CreateScene()
{
    ResourceCache* cache = GetSubsystem&lt;ResourceCache&gt;();

    {
        // Create the scene which will be rendered to a texture
        rttScene_ = new Scene(context_);

        // Create octree, use default volume (-1000, -1000, -1000) to (1000, 1000, 1000)
        rttScene_-&gt;CreateComponent&lt;Octree&gt;();

        // Create a Zone for ambient light &amp; fog control
        Node* zoneNode = rttScene_-&gt;CreateChild("Zone");
        Zone* zone = zoneNode-&gt;CreateComponent&lt;Zone&gt;();
        // Set same volume as the Octree, set a close bluish fog and some ambient light
        zone-&gt;SetBoundingBox(BoundingBox(-1000.0f, 1000.0f));
        zone-&gt;SetAmbientColor(Color(0.05f, 0.1f, 0.15f));
        //zone-&gt;SetFogColor(Color(0.1f, 0.2f, 0.3f));
        zone-&gt;SetFogColor(Color(0.4f, 0.6f, 0.8f));
        zone-&gt;SetFogStart(10.0f);
        zone-&gt;SetFogEnd(100.0f);

        // Create randomly positioned and oriented box StaticModels in the scene
        const unsigned NUM_OBJECTS = 2000;
        for (unsigned i = 0; i &lt; NUM_OBJECTS; ++i)
        {
            Node* boxNode = rttScene_-&gt;CreateChild("Box");
            boxNode-&gt;SetPosition(Vector3(Random(200.0f) - 100.0f, Random(200.0f) - 100.0f, Random(200.0f) - 100.0f));
            // Orient using random pitch, yaw and roll Euler angles
            boxNode-&gt;SetRotation(Quaternion(Random(360.0f), Random(360.0f), Random(360.0f)));
            StaticModel* boxObject = boxNode-&gt;CreateComponent&lt;StaticModel&gt;();
            boxObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
            boxObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/Stone.xml"));

            // Add our custom Rotator component which will rotate the scene node each frame, when the scene sends its update event.
            // Simply set same rotation speed for all objects
            Rotator* rotator = boxNode-&gt;CreateComponent&lt;Rotator&gt;();
            rotator-&gt;SetRotationSpeed(Vector3(10.0f, 20.0f, 30.0f));
        }

        // Create a camera for the render-to-texture scene. Simply leave it at the world origin and let it observe the scene
        rttCameraNode_ = rttScene_-&gt;CreateChild("Camera");
        Camera* camera = rttCameraNode_-&gt;CreateComponent&lt;Camera&gt;();
        camera-&gt;SetFarClip(100.0f);

        // Create a point light to the camera scene node
        Light* light = rttCameraNode_-&gt;CreateComponent&lt;Light&gt;();
        light-&gt;SetLightType(LIGHT_POINT);
        light-&gt;SetRange(30.0f);
    }

    {
        // Create the scene in which we move around
        scene_ = new Scene(context_);

        // Create octree, use also default volume (-1000, -1000, -1000) to (1000, 1000, 1000)
        scene_-&gt;CreateComponent&lt;Octree&gt;();

        // Create a Zone component for ambient lighting &amp; fog control
        Node* zoneNode = scene_-&gt;CreateChild("Zone");
        Zone* zone = zoneNode-&gt;CreateComponent&lt;Zone&gt;();
        zone-&gt;SetBoundingBox(BoundingBox(-1000.0f, 1000.0f));
        zone-&gt;SetAmbientColor(Color(0.1f, 0.1f, 0.1f));
        zone-&gt;SetFogStart(100.0f);
        zone-&gt;SetFogEnd(300.0f);

        // Create a directional light without shadows
        Node* lightNode = scene_-&gt;CreateChild("DirectionalLight");
        lightNode-&gt;SetDirection(Vector3(0.5f, -1.0f, 0.5f));
        Light* light = lightNode-&gt;CreateComponent&lt;Light&gt;();
        light-&gt;SetLightType(LIGHT_DIRECTIONAL);
        //light-&gt;SetColor(Color(0.2f, 0.2f, 0.2f));
        light-&gt;SetColor(Color(0.8f, 0.8f, 0.8f));
        light-&gt;SetSpecularIntensity(1.0f);

        // Create a "floor" consisting of several tiles
        for (int y = -5; y &lt;= 5; ++y)
        {
            for (int x = -5; x &lt;= 5; ++x)
            {
                Node* floorNode = scene_-&gt;CreateChild("FloorTile");
                floorNode-&gt;SetPosition(Vector3(x * 20.5f, -0.5f, y * 20.5f));
                floorNode-&gt;SetScale(Vector3(20.0f, 1.0f, 20.f));
                StaticModel* floorObject = floorNode-&gt;CreateComponent&lt;StaticModel&gt;();
                floorObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
                floorObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/Stone.xml"));
            }
        }

        // Create a "screen" like object for viewing the second scene. Construct it from two StaticModels, a box for the frame
        // and a plane for the actual view
        {
            Node* boxNode = scene_-&gt;CreateChild("ScreenBox");
            boxNode-&gt;SetPosition(Vector3(0.0f, 10.0f, 0.0f));
            boxNode-&gt;SetScale(Vector3(21.0f, 16.0f, 0.5f));
            StaticModel* boxObject = boxNode-&gt;CreateComponent&lt;StaticModel&gt;();
            boxObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
            boxObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/Stone.xml"));
            //boxObject-&gt;GetMaterial()-&gt;GetTexture(TU_DIFFUSE)-&gt;SetNumLevels(4);
            //boxObject-&gt;GetMaterial()-&gt;GetTexture(TU_DIFFUSE)-&gt;SetFilterMode(FILTER_DEFAULT);


            Node* screenNode = scene_-&gt;CreateChild("Screen");
            screenNode-&gt;SetPosition(Vector3(0.0f, 10.0f, -0.27f));
            screenNode-&gt;SetRotation(Quaternion(-90.0f, 0.0f, 0.0f));
            screenNode-&gt;SetScale(Vector3(20.0f, 0.0f, 15.0f));
            StaticModel* screenObject = screenNode-&gt;CreateComponent&lt;StaticModel&gt;();
            screenObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Plane.mdl"));

            // Create a renderable texture (1024x768, RGB format), enable bilinear filtering on it
            SharedPtr&lt;Texture2D&gt; renderTexture(new Texture2D(context_));
            renderTexture-&gt;SetSize(1024, 768, Graphics::GetRGBFormat(), TEXTURE_RENDERTARGET);
            renderTexture-&gt;SetFilterMode(FILTER_BILINEAR);
            //renderTexture-&gt;SetFilterMode(MAX_FILTERMODES);
            //renderTexture-&gt;SetNumLevels(4);

            // Create a new material from scratch, use the diffuse unlit technique, assign the render texture
            // as its diffuse texture, then assign the material to the screen plane object
            SharedPtr&lt;Material&gt; renderMaterial(new Material(context_));
            renderMaterial-&gt;SetTechnique(0, cache-&gt;GetResource&lt;Technique&gt;("Techniques/DiffUnlit.xml"));
            renderMaterial-&gt;SetTexture(TU_DIFFUSE, renderTexture);
            // Since the screen material is on top of the box model and may Z-fight, use negative depth bias
            // to push it forward (particularly necessary on mobiles with possibly less Z resolution)
            renderMaterial-&gt;SetDepthBias(BiasParameters(-0.001f, 0.0f));
            screenObject-&gt;SetMaterial(renderMaterial);

            // Get the texture's RenderSurface object (exists when the texture has been created in rendertarget mode)
            // and define the viewport for rendering the second scene, similarly as how backbuffer viewports are defined
            // to the Renderer subsystem. By default the texture viewport will be updated when the texture is visible
            // in the main view
            RenderSurface* surface = renderTexture-&gt;GetRenderSurface();
            SharedPtr&lt;Viewport&gt; rttViewport(new Viewport(context_, rttScene_, rttCameraNode_-&gt;GetComponent&lt;Camera&gt;()));
            surface-&gt;SetViewport(0, rttViewport);
        }





        // +++++++++++++++++++    ADD SECOND SCREEN.  ++++++++++++++++++++++
        // Create a "screen" like object for viewing the second scene. Construct it from two StaticModels, a box for the frame
        // and a plane for the actual view
        {
          Node* boxNode = scene_-&gt;CreateChild("ScreenBox");
          boxNode-&gt;SetPosition(Vector3(0.0f, 10.0f, -20.0f));
          boxNode-&gt;SetScale(Vector3(21.0f, 16.0f, 0.5f));
          StaticModel* boxObject = boxNode-&gt;CreateComponent&lt;StaticModel&gt;();
          boxObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
          boxObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/Stone.xml"));
          //boxObject-&gt;GetMaterial()-&gt;GetTexture(TU_DIFFUSE)-&gt;SetNumLevels(4);
          //boxObject-&gt;GetMaterial()-&gt;GetTexture(TU_DIFFUSE)-&gt;SetFilterMode(FILTER_DEFAULT);


          Node* screenNode = scene_-&gt;CreateChild("Screen");
          screenNode-&gt;SetPosition(Vector3(0.0f, 10.0f, -19.57f));
          screenNode-&gt;SetRotation(Quaternion(-90.0f, 0.0f, 180.0f));
          screenNode-&gt;SetScale(Vector3(20.0f, 0.0f, 15.0f));
          StaticModel* screenObject = screenNode-&gt;CreateComponent&lt;StaticModel&gt;();
          screenObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Plane.mdl"));

          // Create a renderable texture (1024x768, RGB format), enable bilinear filtering on it
          SharedPtr&lt;Texture2D&gt; renderTexture(new Texture2D(context_));
          renderTexture-&gt;SetSize(1024, 768, Graphics::GetRGBFormat(), TEXTURE_RENDERTARGET);
          renderTexture-&gt;SetFilterMode(FILTER_BILINEAR);
          //renderTexture-&gt;SetFilterMode(MAX_FILTERMODES);
          //renderTexture-&gt;SetNumLevels(4);

          // Create a new material from scratch, use the diffuse unlit technique, assign the render texture
          // as its diffuse texture, then assign the material to the screen plane object
          SharedPtr&lt;Material&gt; renderMaterial(new Material(context_));
          renderMaterial-&gt;SetTechnique(0, cache-&gt;GetResource&lt;Technique&gt;("Techniques/DiffUnlit.xml"));
          renderMaterial-&gt;SetTexture(TU_DIFFUSE, renderTexture);
          // Since the screen material is on top of the box model and may Z-fight, use negative depth bias
          // to push it forward (particularly necessary on mobiles with possibly less Z resolution)
          renderMaterial-&gt;SetDepthBias(BiasParameters(-0.001f, 0.0f));
          screenObject-&gt;SetMaterial(renderMaterial);

          // Get the texture's RenderSurface object (exists when the texture has been created in rendertarget mode)
          // and define the viewport for rendering the second scene, similarly as how backbuffer viewports are defined
          // to the Renderer subsystem. By default the texture viewport will be updated when the texture is visible
          // in the main view
          RenderSurface* surface = renderTexture-&gt;GetRenderSurface();
          SharedPtr&lt;Viewport&gt; rttViewport(new Viewport(context_, rttScene_, rttCameraNode_-&gt;GetComponent&lt;Camera&gt;()));
          surface-&gt;SetViewport(0, rttViewport);
        }




        // Create the camera which we will move around. Limit far clip distance to match the fog
        cameraNode_ = scene_-&gt;CreateChild("Camera");
        Camera* camera = cameraNode_-&gt;CreateComponent&lt;Camera&gt;();
        camera-&gt;SetFarClip(300.0f);

        // Set an initial position for the camera scene node above the plane
        cameraNode_-&gt;SetPosition(Vector3(0.0f, 7.0f, -30.0f));
    }
}

void RenderToTexture::CreateInstructions()
{
    ResourceCache* cache = GetSubsystem&lt;ResourceCache&gt;();
    UI* ui = GetSubsystem&lt;UI&gt;();

    // Construct new Text object, set string to display and font to use
    Text* instructionText = ui-&gt;GetRoot()-&gt;CreateChild&lt;Text&gt;();
    instructionText-&gt;SetText("Use WASD keys and mouse/touch to move");
    instructionText-&gt;SetFont(cache-&gt;GetResource&lt;Font&gt;("Fonts/Anonymous Pro.ttf"), 15);

    // Position the text relative to the screen center
    instructionText-&gt;SetHorizontalAlignment(HA_CENTER);
    instructionText-&gt;SetVerticalAlignment(VA_CENTER);
    instructionText-&gt;SetPosition(0, ui-&gt;GetRoot()-&gt;GetHeight() / 4);
}

void RenderToTexture::SetupViewport()
{
    Renderer* renderer = GetSubsystem&lt;Renderer&gt;();

    // Set up a viewport to the Renderer subsystem so that the 3D scene can be seen
    SharedPtr&lt;Viewport&gt; viewport(new Viewport(context_, scene_, cameraNode_-&gt;GetComponent&lt;Camera&gt;()));
    renderer-&gt;SetViewport(0, viewport);
}

void RenderToTexture::MoveCamera(float timeStep)
{
    // Do not move if the UI has a focused element (the console)
    if (GetSubsystem&lt;UI&gt;()-&gt;GetFocusElement())
        return;

    Input* input = GetSubsystem&lt;Input&gt;();

    // Movement speed as world units per second
    const float MOVE_SPEED = 20.0f;
    // Mouse sensitivity as degrees per pixel
    const float MOUSE_SENSITIVITY = 0.1f;

    // Use this frame's mouse motion to adjust camera node yaw and pitch. Clamp the pitch between -90 and 90 degrees
    IntVector2 mouseMove = input-&gt;GetMouseMove();
    yaw_ += MOUSE_SENSITIVITY * mouseMove.x_;
    pitch_ += MOUSE_SENSITIVITY * mouseMove.y_;
    pitch_ = Clamp(pitch_, -90.0f, 90.0f);

    // Construct new orientation for the camera scene node from yaw and pitch. Roll is fixed to zero
    cameraNode_-&gt;SetRotation(Quaternion(pitch_, yaw_, 0.0f));

    // Read WASD keys and move the camera scene node to the corresponding direction if they are pressed
    if (input-&gt;GetKeyDown(KEY_W))
        cameraNode_-&gt;Translate(Vector3::FORWARD * MOVE_SPEED * timeStep);
    if (input-&gt;GetKeyDown(KEY_S))
        cameraNode_-&gt;Translate(Vector3::BACK * MOVE_SPEED * timeStep);
    if (input-&gt;GetKeyDown(KEY_A))
        cameraNode_-&gt;Translate(Vector3::LEFT * MOVE_SPEED * timeStep);
    if (input-&gt;GetKeyDown(KEY_D))
        cameraNode_-&gt;Translate(Vector3::RIGHT * MOVE_SPEED * timeStep);
}

void RenderToTexture::SubscribeToEvents()
{
    // Subscribe HandleUpdate() function for processing update events
    SubscribeToEvent(E_UPDATE, URHO3D_HANDLER(RenderToTexture, HandleUpdate));
}

void RenderToTexture::HandleUpdate(StringHash eventType, VariantMap&amp; eventData)
{
    using namespace Update;

    // Take the frame time step, which is stored as a float
    float timeStep = eventData[P_TIMESTEP].GetFloat();

    // Move the camera, scale movement with time step
    MoveCamera(timeStep);
}

</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vmost</div>
          <div class="post_content">
<p>I know this isn’t helpful but… oh the joys of floating point numbers.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>That’s depth bias for you. It can solve issues, it can create issues.<br/>
Consider not using depth bias by default.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3546_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">heytao</div>
          <div class="post_content">
<p><span class="mention">@Eugene</span><br/>
Thank you for your answer.<br/>
After deleting this line  <code>renderMaterial-&gt;SetDepthBias(BiasParameters(-0.001f, 0.0f));</code>, everything returned to normal.<br/>
I also found that changing the parameter <code>-0.001</code> to <code>-0.00001</code> can alleviate the problem to a certain extent.</p>
<p>When do I need to consider using <code>depth bias</code>?<br/>
Should I delete <code>SetDepthBias</code> or change the parameter to be small enough?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>Depth bias is basically magic constant that offsets perceived depth one way or another.</p>
<p>Good approach would be to try to make your scene look good without any biases by arranging geometry properly. If you fail to do so, use minimum sufficient bias.</p>
<p>I think the only “mandatory” bias in Urho are decal materials because decals are created right next to parent geometry. Use minimal bias value which is sufficient for your game.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3546_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">heytao</div>
          <div class="post_content">
<p><span class="mention">@Eugene</span><br/>
Thank you again for your help.<br/>
Your answer made me feel the strength of urho, but also the warmth of the urho community.<br/>
Have a nice weekend, brother.</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>