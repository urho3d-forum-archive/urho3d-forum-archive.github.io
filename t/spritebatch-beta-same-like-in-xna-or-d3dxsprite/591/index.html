<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>SpriteBatch BETA (same like in XNA or D3DXSprite)</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>

  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="40" alt="Urho3D" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">Archive 17/01/2023.</div>
    <h1 class="topic-title">SpriteBatch BETA (same like in XNA or D3DXSprite)</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">simple</div>
          <div class="post_content">
<p>Hello i made SpriteBatch class which are almost same like in XNA or D3DXSprite.</p>
<p>How to use this:</p>
<pre><code class="lang-auto">spritebatch = new SpriteBatch(context);
spritebatch-&gt;Initialize();</code></pre>
<p>these lines you must have to write somewhere in Start();<br/>
Initialize(numBatchs,numQuads); just create vertexbuffers and adding events.<br/>
numBatchs - maximum of texture changes.<br/>
numQuads - maximum of quads, possible maximum is 16300.</p>
<p>How to render (write this somewhere in OnHandleSceneUpdate):</p>
<pre><code class="lang-auto">// start draw
spritebatch-&gt;Begin();
// set a blend
spritebatch-&gt;SetBlendMode(BLEND_ALPHA);
// draw a texture
spritebatch-&gt;Draw(texture,Rect(0,0,100,100),Rect(0,0,256,256),color);
spritebatch-&gt;Draw(texture,Rect(100,100,200,200),Rect(0,0,256,256),rotation,origin,scale,color,SpriteBatch::SBFX_NONE);
// draw a text
spritebatch-&gt;DrawString(font,24,Vector2(10,10),"Hello World",11,color,SpriteBatch::TFX_NONE);
// draw a center text
spritebatch-&gt;DrawString(font,24,Vector2(400,10),"Hello World",11,color,SpriteBatch::TFX_HCENTER);
// draw a text using L"&lt;text&gt;" thing, because use TFX_UNICODE16.
spritebatch-&gt;DrawString(font,24,Vector2(10,10),L"Hello World",11,color,SpriteBatch::TFX_UNICODE16);
// draw a frame from texture from rect (0,0,96,96) and with borders (32,32,32,32)
spritebatch-&gt;DrawFrame(texture,Rect(200,200,300,300),Rect(0,0,96,96),Rect(32,32,32,32),color);
// end of draw
spritebatch-&gt;End();</code></pre>
<p>Draw() - function draw a texture.<br/>
DrawString() - function draw a text (ttf working weird, only works with bitmapfonts 32bit).<br/>
DrawFrame() - draw a frame.</p>
<p>Auto rescaling functions: (write somewhere around initialize() )</p>
<pre><code class="lang-auto">// now sprites will be rescaled to 800,600 and centrize if needed (similar like in flashplayer).
spritebatch-&gt;SetScreenSize(800,600);
// convert screen positions to rescaled position
Vector2 rs = spritebatch-&gt;GetPointTo(Vector2(mousex,mousey));
// convert rescaled position to screen position
Vector2 s = spritebatch-&gt;GetPointFrom(Vector2(0,0));</code></pre>
<p>Modifying exist draw() functions.</p>
<pre><code class="lang-auto">spritebatch-&gt;PushModifier();
spritebatch-&gt;Draw(texture,Rect(0,0,100,100),Rect(0,0,256,256),color);
// do gradient
spritebatch-&gt;ModifyGradientH(Color::WHITE,Color::RED);
// transformations
spritebatch-&gt;ModifyPRS(position,rotation,scale);
// etc
spritebatch-&gt;PopModifier();</code></pre>
<p>sorry for english.<br/>
<a href="https://drive.google.com/file/d/0B-0l276DEh6XTVBCZTUzR19kNFk/view" rel="nofollow noopener">drive.google.com/file/d/0B-0l27 … 9kNFk/view</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">v0van1981</div>
          <div class="post_content">
<p>How to drawing under UI? Is there any way draw 3d model over SpriteBatch?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Hevedy</div>
          <div class="post_content">
<aside class="quote no-group" data-username="v0van1981">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/91a5cffe3812a7839696419a8a5d28e4.png" width="20"/> v0van1981:</div>
<blockquote>
<p>How to drawing under UI? Is there any way draw 3d model over SpriteBatch?</p>
</blockquote>
</aside>
<p>This looks like a problem with vector3 z ?<br/>
No idea, but looks like the engine use z in 2D like a depth pos and all vector3 in this code point to 0 and the camera is in -10.0f ?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">v0van1981</div>
          <div class="post_content">
<p>I’m trying to modify the code so that the spritebatch does not overlap models in 3d space. (I’m trying to enable depth test.)</p>
<p>SpriteBatch.h</p>
<p>[code]<span class="hashtag">#ifndef</span> <em>SPRITEBATCH_H</em><br/>
<span class="hashtag">#define</span> <em>SPRITEBATCH_H</em></p>
<p><span class="hashtag">#include</span> </p>
<p>namespace Urho3D<br/>
{<br/>
class	Texture2D;<br/>
class	Font;<br/>
class	VertexBuffer;<br/>
class	IndexBuffer;<br/>
class	Graphics;<br/>
class	SpriteBatch : public Object<br/>
{<br/>
public:<br/>
OBJECT(SpriteBatch);</p>
<pre><code>	public:
		struct		VERTEX
		{
			Vector3		pos;
			int			color;
			Vector2		uv;
		};
		struct		BATCH
		{
			SharedPtr&lt;Texture2D&gt;	pTexture;
			int						iBlendMode;
			unsigned int			iStart,iCount;
		};
		enum
		{
			SBFX_NONE			=	0,
			SBFX_FLIPH			=	1,
			SBFX_FLIPV			=	2,
			SBFX_FLIPHV			=	3,
		};
		enum
		{
			TFX_NONE			=	0,
			TFX_VTOP			=	0,
			TFX_VCENTER			=	1,
			TFX_VBOTTOM			=	2,
			TFX_HLEFT			=	0,
			TFX_HCENTER			=	4,
			TFX_HRIGHT			=	8,
			TFX_UNICODE16		=	16,
		};

	public:
		SpriteBatch(Context *context);
		virtual ~SpriteBatch();
	public:
		// Size of screen where sprites will be drawn.
		// If width,height are lower than graphics-&gt;width,graphics-&gt;height
		// then class automatic rescale up and centrize (similar like in flashplayer).
		// if width,height will be 0, then graphics-&gt;width,graphis-&gt;height will be set.
		void						SetScreenSize(float fWidth=800,float fHeight=600);
		// convert screen positions to rescaled position
		Vector2						GetPointTo(const Vector2 &amp;screen);
		// convert rescaled position to screen position
		Vector2						GetPointFrom(const Vector2 &amp;view);

		// start modify sprites
		void						PushModifier();
		// modify sprites, modify functions must be between PushModifier()...Draw()...&lt;here&gt;...PopModifier().
		bool						ModifyPRS(const Vector2 &amp;pos=Vector2::ZERO,float rotation=0,const Vector2 &amp;scale=Vector2::ONE);
		bool						ModifyTransform(const Matrix4 &amp;matrix);
		bool						ModifyColor(const Color &amp;color=Color::WHITE);
		bool						ModifyGradientH(const Color &amp;color_up=Color::WHITE,const Color &amp;color_down=Color::RED);
		bool						ModifyGradientV(const Color &amp;color_lf=Color::WHITE,const Color &amp;color_rg=Color::RED);
		// end of modify sprites
		void						PopModifier();

		// initialize, create vertexbuffer and add event to render, must be called after constructor.
		bool						Initialize(unsigned int iBatchMax=512,unsigned int iQuadsMax=16300);
		// begin()...end() between them, must be all Draw() functions
		bool						Begin();
		// change blendmode
		void						SetBlendMode(int blendmode);
		// draw sprite
		bool						Draw(Texture2D *texture,const Rect &amp;dest,const Color &amp;color);
		bool						Draw(Texture2D *texture,const Rect &amp;dest,const Rect &amp;src,const Color &amp;color);
		bool						Draw(Texture2D *texture,const Rect &amp;dest,const Rect &amp;src,const Color &amp;color,float rotation,const Vector2 &amp;origin=Vector2::ZERO,const Vector2 &amp;scale=Vector2::ONE,int SpriteEffect = SBFX_NONE);
		bool						Draw(Texture2D *texture,const Vector2 &amp;dest,const Color &amp;color);
		bool						Draw(Texture2D *texture,const Vector2 &amp;dest,const Rect &amp;src,const Color &amp;color);
		bool						Draw(Texture2D *texture,const Vector2 &amp;dest,const Rect &amp;src,const Color &amp;color,float rotation,const Vector2 &amp;origin=Vector2::ZERO,const Vector2 &amp;scale=Vector2::ONE,int SpriteEffect = SBFX_NONE);

		// get x-size in pixels of textline
		float						GetWidthString(Font *font,int fontsize,const void *text,unsigned int textlength,int TextEffect = TFX_NONE);
		// get y-size in pixels of text
		float						GetHeightString(Font *font,int fontsize,const void *text,unsigned int textlength,int TextEffect = TFX_NONE);
		// draw text (TTF may not working like expected, tested only on bitmapfonts with 32bit color)
		// if texteffect will be TFX_UNICODE16 then text parameter must be: L"HelloWorld"
		bool						DrawString(Font *font,int fontsize,const Vector2 &amp;dest,const void *text,unsigned int textlength,const Color &amp;color,int TextEffect = TFX_NONE);
		// draw text with transformations (TTF may not working like expected, tested only on bitmapfonts with 32bit color)
		bool						DrawString(Font *font,int fontsize,const Vector2 &amp;dest,const void *text,unsigned int textlength,const Color &amp;color,float rotation,const Vector2 &amp;origin=Vector2::ZERO,const Vector2 &amp;scale=Vector2::ONE,int TextEffect = TFX_NONE);

		// draw frame (drawframe(tex,Rect(0,0,100,100),Rect(0,0,96,96),Rect(32,32,32,32),color::white)
		void						DrawFrame(Texture2D *texture,const Rect &amp;dest,const Rect &amp;src,const Rect &amp;borders,const Color &amp;color);
		// begin()...end() between them, must be all Draw() functions
		void						End();
		void SetView(Camera* camera, Engine* engine);

		void						OnRender(StringHash eventType, VariantMap&amp; eventData);

	protected:

	private:
		BATCH*						GetBatch(Texture2D *texture,int iBlendMode);
		static float				CalculateFixedScreenSize(float sw,float sh,float vw,float vh,float *ret);

		std::vector&lt;unsigned int&gt;	modifiers_;
		Graphics*					graphics_;
		SharedPtr&lt;VertexBuffer&gt;		vb_;
		BATCH*						batch_;
		unsigned int				maxbatch_,maxquads_,ibatch_,icount_;
		VERTEX*						vertex_;
		int							blendmode_;
		float						viewWidth_,viewHeight_;
		float						viewCalc_[5];

		Camera* camera_;
		Engine* engine_;

};
</code></pre>
<p>};</p>
<p><span class="hashtag">#endif</span><br/>
[/code]</p>
<p>SpriteBatch.cpp</p>
<p>[code]<span class="hashtag">#include</span> “stdafx.h”<br/>
<span class="hashtag">#include</span> “SpriteBatch.h”</p>
<p><span class="hashtag">#include</span> &lt;stdio.h&gt;</p>
<p>namespace Urho3D<br/>
{<br/>
static	int			 g_iIB = 0;<br/>
static	IndexBuffer	*g_pIB = 0;</p>
<pre><code>SpriteBatch::SpriteBatch(Context *context) : Object(context)
{
	blendmode_ = BLEND_ALPHA;
	vertex_ = 0;
	graphics_ = 0;
	batch_ = 0;
	maxbatch_ = maxquads_ = ibatch_ = icount_ = 0;
	viewWidth_ = 800;
	viewHeight_ = 600;
	viewCalc_[0] = viewCalc_[1] = 0;
	viewCalc_[2] = 800;	viewCalc_[3] = 600;	viewCalc_[4] = 1;

	if (g_iIB == 0)
	{
		// only one time we create indexbuffer for save memory
		g_pIB = new IndexBuffer(context);
		g_pIB-&gt;SetShadowed(true);
		g_pIB-&gt;SetSize(16300 * 6, false);
		unsigned short *index = (unsigned short *)g_pIB-&gt;Lock(0, 16300 * 6);
		if (index)
		{
			int s = 0;
			for (unsigned int i = 0; i &lt; 16300; i++)
			{
				index[(i * 6) + 0] = s + 0;		index[(i * 6) + 1] = s + 1;		index[(i * 6) + 2] = s + 2;
				index[(i * 6) + 3] = s + 2;		index[(i * 6) + 4] = s + 1;		index[(i * 6) + 5] = s + 3;
				s += 4;
			};
		};
		g_pIB-&gt;Unlock();
	};
	g_iIB++;
}

SpriteBatch::~SpriteBatch()
{
	UnsubscribeFromEvent(graphics_, E_ENDRENDERING);
	modifiers_.clear();
	if (batch_) delete[] batch_;
	vb_.Reset();

	g_iIB--;
	if (g_iIB &lt;= 0)
	{
		if (g_pIB) delete g_pIB;
		g_pIB = 0;
		g_iIB = 0;
	};
}

SpriteBatch::BATCH* SpriteBatch::GetBatch(Texture2D *texture, int iBlendMode)
{
	if (icount_ &gt;= (maxquads_ - 1) * 4 || texture == 0) return 0;
	BATCH *b = &amp;batch_[ibatch_];
	if (b-&gt;pTexture == texture &amp;&amp; b-&gt;iBlendMode == iBlendMode) return b;
	if (ibatch_ &gt;= maxbatch_) return 0;
	ibatch_++;
	batch_[ibatch_].pTexture = texture;
	batch_[ibatch_].iBlendMode = iBlendMode;
	batch_[ibatch_].iStart = icount_;
	batch_[ibatch_].iCount = 0;
	return &amp;batch_[ibatch_];
};

float SpriteBatch::CalculateFixedScreenSize(float sw, float sh, float vw, float vh, float *ret)
{
	float sAspect = sw / sh;
	float vAspect = vw / vh;
	float scale = 1;

	ret[0] = ret[1] = 0;  ret[2] = vw;  ret[3] = vh;
	if (sAspect &gt; vAspect)
	{
		scale = sh / vh;
		ret[0] = (sw - vw*scale)*0.5f;
	}
	else if (sAspect &lt; vAspect) {
		scale = sw / vw;
		ret[1] = (sh - vh*scale)*0.5f;
	}
	else {
		scale = sw / vw;
	};
	ret[2] *= scale; ret[3] *= scale;
	ret[4] = scale;

	//glViewport(ret[0], ret[1], ret[2], ret[3]);
	//glOrtho(0,0,vw,vh);
	return scale;
};

Vector2 SpriteBatch::GetPointTo(const Vector2 &amp;screen)
{
	return Vector2((screen.x_ - viewCalc_[0]) * (1.0f / viewCalc_[4]), (screen.y_ - viewCalc_[1]) * (1.0f / viewCalc_[4]));
};

Vector2 SpriteBatch::GetPointFrom(const Vector2 &amp;view)
{
	return Vector2((view.x_*viewCalc_[4]) + viewCalc_[0], (view.y_*viewCalc_[4]) + viewCalc_[1]);
};

bool SpriteBatch::Begin()
{
	ibatch_ = icount_ = 0;
	if (!vertex_) vertex_ = (VERTEX *)vb_-&gt;Lock(0, maxquads_ * 4);
	return (vertex_ != 0);
};

void SpriteBatch::End()
{
	if (vertex_)
	{
		vb_-&gt;Unlock();
		vertex_ = 0;
	};
};

void SpriteBatch::SetBlendMode(int blendmode)
{
	blendmode_ = blendmode;
};

bool SpriteBatch::Draw(Texture2D *texture, const Rect &amp;dest, const Color &amp;color)
{
	if (!texture) return false;
	float w = (float)texture-&gt;GetWidth();
	float h = (float)texture-&gt;GetHeight();
	return Draw(texture, dest, Rect(0, 0, w, h), color);
};

bool SpriteBatch::Draw(Texture2D *texture, const Rect &amp;dest, const Rect &amp;src, const Color &amp;color)
{
	if (color.a_ &lt;= 0) return true;
	BATCH *batch = GetBatch(texture, blendmode_);
	if (!batch) return false;

	vertex_[icount_ + 0].pos = Vector3(dest.min_.x_, dest.min_.y_, icount_ * -0.0001f);
	vertex_[icount_ + 1].pos = Vector3(dest.max_.x_, dest.min_.y_, icount_ * -0.0001f);
	vertex_[icount_ + 2].pos = Vector3(dest.min_.x_, dest.max_.y_, icount_ * -0.0001f);
	vertex_[icount_ + 3].pos = Vector3(dest.max_.x_, dest.max_.y_, icount_ * -0.0001f);

	vertex_[icount_ + 0].color = vertex_[icount_ + 1].color = vertex_[icount_ + 2].color = vertex_[icount_ + 3].color = color.ToUInt();

	float w = 1.0f / (float)texture-&gt;GetWidth();
	float h = 1.0f / (float)texture-&gt;GetHeight();

	vertex_[icount_ + 0].uv = Vector2(src.min_.x_*w, src.min_.y_*h);
	vertex_[icount_ + 1].uv = Vector2(src.max_.x_*w, src.min_.y_*h);
	vertex_[icount_ + 2].uv = Vector2(src.min_.x_*w, src.max_.y_*h);
	vertex_[icount_ + 3].uv = Vector2(src.max_.x_*w, src.max_.y_*h);

	icount_ += 4;
	batch-&gt;iCount += 4;
	return true;
};

bool SpriteBatch::Draw(Texture2D *texture, const Rect &amp;dest, const Rect &amp;src, const Color &amp;color, float rotation, const Vector2 &amp;origin, const Vector2 &amp;scale, int SpriteEffect)
{
	if (color.a_ &lt;= 0) return true;
	BATCH *batch = GetBatch(texture, blendmode_);
	if (!batch) return false;

	Vector2 startxy = -origin;
	Vector2 toxy = startxy + dest.Size();

	vertex_[icount_ + 0].pos = Vector3(startxy.x_, startxy.y_, icount_ * 0.0001f);
	vertex_[icount_ + 1].pos = Vector3(toxy.x_, startxy.y_, icount_ * 0.0001f);
	vertex_[icount_ + 2].pos = Vector3(startxy.x_, toxy.y_, icount_ * 0.0001f);
	vertex_[icount_ + 3].pos = Vector3(toxy.x_, toxy.y_, icount_ * 0.0001f);

	Matrix4 m(Matrix4::IDENTITY);
	m.m00_ = cosf(rotation) * scale.x_;		m.m10_ = sinf(rotation) * scale.x_;
	m.m01_ = -sinf(rotation) * scale.y_;	m.m11_ = cosf(rotation) * scale.y_;
	m.m03_ = dest.min_.x_;					m.m13_ = dest.min_.y_;
	for (int i = 0; i &lt; 4; i++)	vertex_[icount_ + i].pos = m * vertex_[icount_ + i].pos;

	vertex_[icount_ + 0].color = vertex_[icount_ + 1].color = vertex_[icount_ + 2].color = vertex_[icount_ + 3].color = color.ToUInt();

	float w = 1.0f / (float)texture-&gt;GetWidth();
	float h = 1.0f / (float)texture-&gt;GetHeight();

	Vector2 uv1 = src.min_;
	Vector2 uv2 = src.max_;
	if (SpriteEffect &amp; SBFX_FLIPH) { uv1.x_ = src.max_.x_; uv2.x_ = src.min_.x_; };
	if (SpriteEffect &amp; SBFX_FLIPV) { uv1.y_ = src.max_.y_; uv2.y_ = src.min_.y_; };

	vertex_[icount_ + 0].uv = Vector2(uv1.x_*w, uv1.y_*h);
	vertex_[icount_ + 1].uv = Vector2(uv2.x_*w, uv1.y_*h);
	vertex_[icount_ + 2].uv = Vector2(uv1.x_*w, uv2.y_*h);
	vertex_[icount_ + 3].uv = Vector2(uv2.x_*w, uv2.y_*h);

	icount_ += 4;
	batch-&gt;iCount += 4;
	return true;
};

bool SpriteBatch::Draw(Texture2D *texture, const Vector2 &amp;xy, const Color &amp;color)
{
	if (!texture) return false;
	Rect dest(xy.x_, xy.y_, xy.x_ + (float)texture-&gt;GetWidth(), xy.y_ + (float)texture-&gt;GetHeight());
	return Draw(texture, dest, color);
};

bool SpriteBatch::Draw(Texture2D *texture, const Vector2 &amp;xy, const Rect &amp;src, const Color &amp;color)
{
	Rect dest(xy.x_, xy.y_, xy.x_ + src.Size().x_, xy.y_ + src.Size().y_);
	return Draw(texture, dest, src, color);
};

bool SpriteBatch::Draw(Texture2D *texture, const Vector2 &amp;xy, const Rect &amp;src, const Color &amp;color, float rotation, const Vector2 &amp;origin, const Vector2 &amp;scale, int SpriteEffect)
{
	Rect dest(xy.x_, xy.y_, xy.x_ + src.Size().x_, xy.y_ + src.Size().y_);
	return Draw(texture, dest, src, color, rotation, origin, scale, SpriteEffect);
};

float SpriteBatch::GetHeightString(Font *font, int fontsize, const void *text, unsigned int textlength, int TextEffect)
{
	if (font == 0 || text == 0 || ((const char *)text)[0] == 0 || textlength == 0) return 0;
	FontFace *face = font-&gt;GetFace(fontsize);
	if (!face) return 0;

	float								row = (float)face-&gt;GetRowHeight();
	float								H = row;
	unsigned int						i = 0, chr = 0;

	if (TextEffect &amp; TFX_UNICODE16) textlength *= 2;
	for (i = 0; i &lt; textlength;)
	{
		chr = ((const char *)text)[i++];
		if (TextEffect &amp; TFX_UNICODE16) chr |= (((const char *)text)[i++]) &lt;&lt; 8;
		if (chr == 0) break;
		if (chr == 0x0A) { H += row; continue; };
	};
	if (TextEffect &amp; TFX_VCENTER) return H*0.5f;
	if (TextEffect &amp; TFX_VBOTTOM) return H;
	return H;
};

float SpriteBatch::GetWidthString(Font *font, int fontsize, const void *text, unsigned int textlength, int TextEffect)
{
	if (font == 0 || text == 0 || ((const char *)text)[0] == 0 || textlength == 0) return 0;
	FontFace *face = font-&gt;GetFace(fontsize);
	if (!face) return 0;

	float								W = 0;
	const FontGlyph						*glyph;
	unsigned int						i = 0, chr = 0, chrn = 0;

	if (TextEffect &amp; TFX_UNICODE16) textlength *= 2;
	for (i = 0; i &lt; textlength;)
	{
		chr = ((const char *)text)[i];
		if (TextEffect &amp; TFX_UNICODE16) chr |= (((const char *)text)[i + 1]) &lt;&lt; 8;
		if (chr == 0 || chr == 0x0A) break;

		if (TextEffect &amp; TFX_UNICODE16)
		{
			chrn = ((const char *)text)[i + 2];
			chrn |= (((const char *)text)[i + 3]) &lt;&lt; 8;
		}
		else {
			chrn = ((const char *)text)[i + 1];
		};

		glyph = face-&gt;GetGlyph(chr);
		if (glyph == 0) continue;

		W += glyph-&gt;advanceX_;
		W += face-&gt;GetKerning(chr, chrn);
		i += ((TextEffect &amp; TFX_UNICODE16) ? 2 : 1);
	};
	if (TextEffect &amp; TFX_HCENTER) return -W*0.5f;
	if (TextEffect &amp; TFX_HRIGHT) return -W;
	return W;
};

bool SpriteBatch::DrawString(Font *font, int fontsize, const Vector2 &amp;dest, const void *text, unsigned int textlength, const Color &amp;color, int TextEffect)
{
	if (color.a_ &lt;= 0 || text == 0 || ((const char *)text)[0] == 0 || textlength == 0) return true;
	if (!font) return false;
	FontFace *face = font-&gt;GetFace(fontsize);
	if (!face) return false;

	float	ZH = (float)face-&gt;GetRowHeight();
	Vector2 CPos = dest;
	if (TextEffect &amp; (TFX_VBOTTOM | TFX_VCENTER)) CPos.y_ -= GetHeightString(font, fontsize, text, textlength, TextEffect);
	if (TextEffect &amp; (TFX_HRIGHT | TFX_HCENTER))  CPos.x_ += GetWidthString(font, fontsize, text, textlength, TextEffect);

	Vector2								Scr;
	Rect								TexRect;
	const FontGlyph						*glyph;
	unsigned int						i = 0, chr = 0, chrn = 0, Step = 1;
	const Vector&lt;SharedPtr&lt;Texture2D&gt; &gt;	&amp;texs = face-&gt;GetTextures();

	if (TextEffect &amp; TFX_UNICODE16) { textlength *= 2; Step = 2; };
	for (i = 0; i &lt; textlength; i += Step)
	{
		chr = ((const char *)text)[i];
		if (TextEffect &amp; TFX_UNICODE16) chr |= (((const char *)text)[i + 1]) &lt;&lt; 8;
		if (chr == 0) break;

		if (TextEffect &amp; TFX_UNICODE16)
		{
			chrn = ((const char *)text)[i + 2];
			chrn |= (((const char *)text)[i + 3]) &lt;&lt; 8;
		}
		else {
			chrn = ((const char *)text)[i + 1];
		};

		if (chr == 0x0A)
		{
			CPos.x_ = dest.x_; CPos.y_ += ZH;
			if (TextEffect &amp; (TFX_HRIGHT | TFX_HCENTER)) CPos.x_ += GetWidthString(font, fontsize, &amp;((const char *)text)[i + Step], (textlength - (i + Step)) / Step, TextEffect);
			continue;
		};

		glyph = face-&gt;GetGlyph(chr);
		if (glyph == 0) continue;

		Scr = Vector2(glyph-&gt;offsetX_ + CPos.x_, glyph-&gt;offsetY_ + CPos.y_);
		TexRect = Rect((float)glyph-&gt;x_, (float)glyph-&gt;y_, (float)(glyph-&gt;x_ + glyph-&gt;width_), (float)(glyph-&gt;y_ + glyph-&gt;height_));
		CPos.x_ += glyph-&gt;advanceX_;
		CPos.x_ += face-&gt;GetKerning(chr, chrn);

		if (glyph-&gt;page_ &lt; texs.Size()) Draw(texs[glyph-&gt;page_], Scr, TexRect, color);
	};
	return true;
};

bool SpriteBatch::DrawString(Font *font, int fontsize, const Vector2 &amp;dest, const void *text, unsigned int textlength, const Color &amp;color, float rotation, const Vector2 &amp;origin, const Vector2 &amp;scale, int TextEffect)
{
	if (color.a_ &lt;= 0) return true;
	bool bOk = true;
	PushModifier();
	bOk = DrawString(font, fontsize, -origin, text, textlength, color, TextEffect);
	ModifyPRS(dest, rotation, scale);
	PopModifier();
	return bOk;
};

void SpriteBatch::DrawFrame(Texture2D *texture, const Rect &amp;dest, const Rect &amp;src, const Rect &amp;borders, const Color &amp;color)
{
	if (color.a_ &lt;= 0) return;
	//LT
	Draw(texture, Rect(dest.min_.x_, dest.min_.y_, dest.min_.x_ + borders.min_.x_, dest.min_.y_ + borders.min_.y_), Rect(src.min_.x_, src.min_.y_, src.min_.x_ + borders.min_.x_, src.min_.y_ + borders.min_.y_), color);
	//LB
	Draw(texture, Rect(dest.min_.x_, dest.max_.y_ - borders.max_.y_, dest.min_.x_ + borders.min_.x_, dest.max_.y_), Rect(src.min_.x_, src.max_.y_ - borders.max_.y_, src.min_.x_ + borders.min_.x_, src.max_.y_), color);
	//RT
	Draw(texture, Rect(dest.max_.x_ - borders.max_.x_, dest.min_.y_, dest.max_.x_, dest.min_.y_ + borders.min_.y_), Rect(src.max_.x_ - borders.max_.x_, src.min_.y_, src.max_.x_, src.min_.y_ + borders.min_.y_), color);
	//RB
	Draw(texture, Rect(dest.max_.x_ - borders.max_.x_, dest.max_.y_ - borders.max_.y_, dest.max_.x_, dest.max_.y_), Rect(src.max_.x_ - borders.max_.x_, src.max_.y_ - borders.max_.y_, src.max_.x_, src.max_.y_), color);

	//TOP
	Draw(texture, Rect(dest.min_.x_ + borders.min_.x_, dest.min_.y_, dest.max_.x_ - borders.max_.x_, dest.min_.y_ + borders.min_.y_), Rect(src.min_.x_ + borders.min_.x_, src.min_.y_, src.max_.x_ - borders.max_.x_, src.min_.y_ + borders.min_.y_), color);
	//BOTTOM
	Draw(texture, Rect(dest.min_.x_ + borders.min_.x_, dest.max_.y_ - borders.max_.y_, dest.max_.x_ - borders.max_.x_, dest.max_.y_), Rect(src.min_.x_ + borders.min_.x_, src.max_.y_ - borders.max_.y_, src.max_.x_ - borders.max_.x_, src.max_.y_), color);
	//LEFT
	Draw(texture, Rect(dest.min_.x_, dest.min_.y_ + borders.min_.y_, dest.min_.x_ + borders.min_.x_, dest.max_.y_ - borders.max_.y_), Rect(src.min_.x_, src.min_.y_ + borders.min_.y_, src.min_.x_ + borders.min_.x_, src.max_.y_ - borders.max_.y_), color);
	//RIGHT
	Draw(texture, Rect(dest.max_.x_ - borders.max_.x_, dest.min_.y_ + borders.min_.y_, dest.max_.x_, dest.max_.y_ - borders.max_.y_), Rect(src.max_.x_ - borders.max_.x_, src.min_.y_ + borders.min_.y_, src.max_.x_, src.max_.y_ - borders.max_.y_), color);

	//CENTER
	Draw(texture, Rect(dest.min_.x_ + borders.min_.x_, dest.min_.y_ + borders.min_.y_, dest.max_.x_ - borders.max_.x_, dest.max_.y_ - borders.max_.y_), Rect(src.min_.x_ + borders.min_.x_, src.min_.y_ + borders.min_.y_, src.max_.x_ - borders.max_.x_, src.max_.y_ - borders.max_.y_), color);
};

void SpriteBatch::PushModifier()
{
	modifiers_.push_back(icount_);
};

void					SpriteBatch::PopModifier()
{
	if (modifiers_.size() &gt; 0) modifiers_.pop_back();
};

bool					SpriteBatch::ModifyPRS(const Vector2 &amp;pos, float rotation, const Vector2 &amp;scale)
{
	if (modifiers_.size() == 0 || vertex_ == 0) return false;

	Matrix4 m(Matrix4::IDENTITY);
	m.m00_ = cosf(rotation) * scale.x_;		m.m10_ = sinf(rotation) * scale.x_;
	m.m01_ = -sinf(rotation) * scale.y_;	m.m11_ = cosf(rotation) * scale.y_;
	m.m03_ = pos.x_;						m.m13_ = pos.y_;

	unsigned int bk_icount = modifiers_.back();
	for (unsigned int i = bk_icount; i &lt; icount_; i++)	vertex_[i].pos = m * vertex_[i].pos;

	return true;
};

bool					SpriteBatch::ModifyTransform(const Matrix4 &amp;matrix)
{
	if (modifiers_.size() == 0 || vertex_ == 0) return false;
	unsigned int bk_icount = modifiers_.back();
	for (unsigned int i = bk_icount; i &lt; icount_; i++)	vertex_[i].pos = matrix * vertex_[i].pos;
	return true;
};

bool					SpriteBatch::ModifyColor(const Color &amp;color)
{
	if (modifiers_.size() == 0 || vertex_ == 0) return false;

	unsigned int col_uint = color.ToUInt();

	unsigned int bk_icount = modifiers_.back();
	for (unsigned int i = bk_icount; i &lt; icount_; i++)	vertex_[i].color = col_uint;

	return true;
};

bool					SpriteBatch::ModifyGradientH(const Color &amp;color_up, const Color &amp;color_down)
{
	if (modifiers_.size() == 0 || vertex_ == 0) return false;

	unsigned int col_1 = color_up.ToUInt();
	unsigned int col_2 = color_down.ToUInt();

	unsigned int bk_icount = modifiers_.back();
	for (unsigned int i = bk_icount; i &lt; icount_; i += 4)
	{
		vertex_[i + 0].color = vertex_[i + 1].color = col_1;
		vertex_[i + 2].color = vertex_[i + 3].color = col_2;
	};

	return true;
};

bool					SpriteBatch::ModifyGradientV(const Color &amp;color_lf, const Color &amp;color_rg)
{
	if (modifiers_.size() == 0 || vertex_ == 0) return false;

	unsigned int col_1 = color_lf.ToUInt();
	unsigned int col_2 = color_rg.ToUInt();

	unsigned int bk_icount = modifiers_.back();
	for (unsigned int i = bk_icount; i &lt; icount_; i += 4)
	{
		vertex_[i + 0].color = vertex_[i + 2].color = col_1;
		vertex_[i + 1].color = vertex_[i + 3].color = col_2;
	};

	return true;
};

bool					SpriteBatch::Initialize(unsigned int iBatchMax, unsigned int iQuadsMax)
{
	graphics_ = GetSubsystem&lt;Graphics&gt;();

	if (iQuadsMax &gt; 16300 || iQuadsMax == 0) iQuadsMax = 16300;
	if (iBatchMax == 0) iBatchMax = 512;

	vertex_ = 0;
	ibatch_ = icount_ = 0;
	maxbatch_ = iBatchMax;
	maxquads_ = iQuadsMax;
	if (batch_) delete[] batch_;
	batch_ = new BATCH[maxbatch_];

	vb_.Reset();
	vb_ = new VertexBuffer(context_);
	vb_-&gt;SetSize(iQuadsMax * 4, MASK_POSITION | MASK_COLOR | MASK_TEXCOORD1, true);

	//UnsubscribeFromEvent(graphics_, E_POSTRENDERUPDATE);
	//SubscribeToEvent(graphics_, E_POSTRENDERUPDATE, HANDLER(SpriteBatch, OnRender));
	return true;
};

void					SpriteBatch::SetScreenSize(float fWidth, float fHeight)
{
	if (fWidth &lt;= 0) fWidth = (float)graphics_-&gt;GetWidth();
	if (fHeight &lt;= 0) fHeight = (float)graphics_-&gt;GetHeight();
	viewWidth_ = fWidth;
	viewHeight_ = fHeight;
};

void					SpriteBatch::OnRender(StringHash eventType, VariantMap&amp; eventData)
{
	if (!(graphics_ &amp;&amp; graphics_-&gt;IsInitialized() &amp;&amp; !graphics_-&gt;IsDeviceLost())) return;
	if (icount_ == 0 || ibatch_ == 0) return;

	//engine_-&gt;Exit();
	


	ShaderVariation* vs = graphics_-&gt;GetShader(VS, "Basic", "DIFFMAP VERTEXCOLOR");
	ShaderVariation* ps = graphics_-&gt;GetShader(PS, "Basic", "DIFFMAP VERTEXCOLOR");


	graphics_-&gt;SetBlendMode(BLEND_REPLACE);
	graphics_-&gt;SetColorWrite(true);
	graphics_-&gt;SetCullMode(CULL_NONE);  // ??? ??? ????? ????? ???????? ??????? ??????? ?????????, ????? ?? ???? ????? ??? ???? ??????? (??? ?????????)
	
	graphics_-&gt;SetDepthWrite(true);
	graphics_-&gt;SetScissorTest(false);
	graphics_-&gt;SetStencilTest(false);
	graphics_-&gt;SetShaders(vs, ps);
	graphics_-&gt;SetShaderParameter(VSP_MODEL, Matrix3x4::IDENTITY);
	graphics_-&gt;SetShaderParameter(VSP_VIEWPROJ, camera_-&gt;GetProjection() * camera_-&gt;GetView());
	graphics_-&gt;SetShaderParameter(PSP_MATDIFFCOLOR, Color(1.0f, 1.0f, 1.0f, 1.0f));
	graphics_-&gt;SetVertexBuffer(vb_);
	graphics_-&gt;SetIndexBuffer(g_pIB);
	graphics_-&gt;SetDepthTest(CMP_LESSEQUAL);
	
	for (unsigned int i = 1; i &lt; ibatch_ + 1; i++)
	{
		BATCH *b = &amp;batch_[i];
		graphics_-&gt;SetBlendMode((BlendMode)b-&gt;iBlendMode);
		graphics_-&gt;SetTexture(0, b-&gt;pTexture);
		graphics_-&gt;Draw(TRIANGLE_LIST, (b-&gt;iStart / 4) * 6, (b-&gt;iCount / 4) * 6, 0, b-&gt;iCount);
	};
};

void SpriteBatch::SetView(Camera* camera, Engine* engine)
{
	camera_ = camera;
	engine_ = engine;
}
</code></pre>
<p>};<br/>
[/code]</p>
<p>stdafx.h</p>
<p>[code]<span class="hashtag">#pragma</span> once</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Urho3D.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Revision.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/Audio.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/AudioDefs.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/BufferedSoundStream.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/OggVorbisSoundStream.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/Sound.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/SoundListener.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/SoundSource.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/SoundSource3D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Audio/SoundStream.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Allocator.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/ArrayPtr.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/ForEach.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Hash.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/HashBase.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/HashMap.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/HashSet.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/LinkedList.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/List.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/ListBase.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Pair.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Ptr.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/RefCounted.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Sort.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Str.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Swap.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/Vector.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Container/VectorBase.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Attribute.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Condition.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Context.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/CoreEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Main.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/MiniDump.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Mutex.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Object.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/ProcessUtils.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Profiler.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Spline.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/StringUtils.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Thread.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Timer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/Variant.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Core/WorkQueue.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/Application.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/Console.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/DebugHud.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/Engine.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/EngineEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/AnimatedModel.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Animation.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/AnimationController.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/AnimationState.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Batch.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/BillboardSet.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Camera.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/ConstantBuffer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/CustomGeometry.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/DebugRenderer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/DecalSet.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Drawable.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/DrawableEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Geometry.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/GPUObject.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Graphics.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/GraphicsDefs.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/GraphicsEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/GraphicsImpl.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/IndexBuffer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Light.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Material.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Model.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/OcclusionBuffer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Octree.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/OctreeQuery.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/ParticleEffect.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/ParticleEmitter.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Renderer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/RenderPath.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/RenderSurface.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Shader.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/ShaderPrecache.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/ShaderProgram.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/ShaderVariation.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Skeleton.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Skybox.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/StaticModel.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/StaticModelGroup.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Tangent.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Technique.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Terrain.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/TerrainPatch.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Texture.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Texture2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Texture3D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/TextureCube.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/VertexBuffer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/VertexDeclaration.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/View.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Viewport.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Zone.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Input/Controls.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Input/Input.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Input/InputEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/Compression.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/Deserializer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/File.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/FileSystem.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/FileWatcher.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/IOEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/Log.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/MacFileWatcher.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/MemoryBuffer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/PackageFile.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/RWOpsWrapper.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/Serializer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/VectorBuffer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/AreaAllocator.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/BoundingBox.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Color.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Frustum.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/MathDefs.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Matrix3.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Matrix3x4.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Matrix4.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Plane.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Polyhedron.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Quaternion.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Random.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Ray.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Rect.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Sphere.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/StringHash.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Vector2.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Vector3.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Vector4.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Navigation/Navigable.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Navigation/NavigationMesh.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Navigation/OffMeshConnection.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Network/Connection.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Network/HttpRequest.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Network/Network.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Network/NetworkEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Network/NetworkPriority.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Network/Protocol.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/CollisionShape.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/Constraint.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/PhysicsEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/PhysicsUtils.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/PhysicsWorld.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/RigidBody.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/BackgroundLoader.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/Decompress.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/Image.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/JSONFile.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/JSONValue.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/PListFile.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/Resource.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/ResourceCache.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/ResourceEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/XMLElement.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Resource/XMLFile.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/Animatable.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/AnimationDefs.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/Component.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/LogicComponent.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/Node.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/ObjectAnimation.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/ReplicationState.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/Scene.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/SceneEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/SceneResolver.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/Serializable.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/SmoothedTransform.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/SplinePath.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/UnknownComponent.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/ValueAnimation.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/ValueAnimationInfo.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Script/Addons.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Script/APITemplates.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Script/Script.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Script/ScriptAPI.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Script/ScriptEventListener.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Script/ScriptFile.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Script/ScriptInstance.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/BorderImage.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Button.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/CheckBox.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Cursor.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/DropDownList.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/FileSelector.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Font.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/FontFace.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/FontFaceBitmap.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/FontFaceFreeType.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/LineEdit.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/ListView.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Menu.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/MessageBox.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/ScrollBar.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/ScrollView.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Slider.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Sprite.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Text.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Text3D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/ToolTip.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/UI.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/UIBatch.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/UIElement.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/UIEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/View3D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Window.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/AnimatedSprite2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/Animation2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/AnimationSet2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/CollisionBox2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/CollisionChain2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/CollisionCircle2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/CollisionEdge2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/CollisionPolygon2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/CollisionShape2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/Constraint2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintDistance2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintFriction2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintGear2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintMotor2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintMouse2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintPrismatic2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintPulley2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintRevolute2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintRope2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintWeld2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ConstraintWheel2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/Drawable2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ParticleEffect2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/ParticleEmitter2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/PhysicsEvents2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/PhysicsUtils2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/PhysicsWorld2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/Renderer2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/RigidBody2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/Sprite2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/SpriteSheet2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/StaticSprite2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/TileMap2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/TileMapDefs2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/TileMapLayer2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/TmxFile2D.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Urho2D/Urho2D.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/DebugNew.h&gt;</p>
<p>using namespace Urho3D;<br/>
[/code]</p>
<p>Game.cpp</p>
<p>[code]<span class="hashtag">#include</span> “stdafx.h”<br/>
<span class="hashtag">#include</span> “Game.h”</p>
<p>DEFINE_APPLICATION_MAIN(Game)</p>
<p>Game::Game(Context* context) :<br/>
Application(context),<br/>
yaw_(0.0f),<br/>
pitch_(0.0f)<br/>
{<br/>
}</p>
<p>void Game::Setup()<br/>
{<br/>
engineParameters_[“WindowTitle”] = GetTypeName();<br/>
engineParameters_[“LogName”] = GetSubsystem()-&gt;GetAppPreferencesDir(“urho3d”, “logs”) + GetTypeName() + “.log”;<br/>
engineParameters_[“FullScreen”] = false;<br/>
engineParameters_[“Headless”] = false;<br/>
engineParameters_[“WindowWidth”] = 800;<br/>
engineParameters_[“WindowHeight”] = 600;<br/>
//	engineParameters_[“ResourcePaths”] = “Data;CoreData;MyData”;<br/>
}</p>
<p>void Game::Start()<br/>
{<br/>
CreateScene();<br/>
SetupViewport();<br/>
SubscribeToEvents();<br/>
spriteBatch_ = new SpriteBatch(context_);<br/>
spriteBatch_-&gt;Initialize();<br/>
spriteBatch_-&gt;SetView(cameraNode_-&gt;GetComponent(), engine_);<br/>
ResourceCache* cache = GetSubsystem();<br/>
XMLFile* xmlFile = cache-&gt;GetResource(“UI/DefaultStyle.xml”);<br/>
DebugHud* debugHud = engine_-&gt;CreateDebugHud();<br/>
debugHud-&gt;SetDefaultStyle(xmlFile);<br/>
CreateText();<br/>
}</p>
<p>void Game::SetupViewport()<br/>
{<br/>
Renderer* renderer = GetSubsystem();<br/>
SharedPtr viewport(new Viewport(context_, scene_, cameraNode_-&gt;GetComponent()));<br/>
renderer-&gt;SetViewport(0, viewport);<br/>
}</p>
<p>void Game::CreateScene()<br/>
{<br/>
ResourceCache* cache = GetSubsystem();</p>
<pre><code>scene_ = new Scene(context_);
scene_-&gt;CreateComponent&lt;Octree&gt;();
scene_-&gt;CreateComponent&lt;DebugRenderer&gt;();

Node* planeNode = scene_-&gt;CreateChild("Plane");
planeNode-&gt;SetScale(Vector3(100.0f, 1.0f, 100.0f));
StaticModel* planeObject = planeNode-&gt;CreateComponent&lt;StaticModel&gt;();
planeObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Plane.mdl"));
planeObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/StoneTiled.xml"));

Node* lightNode = scene_-&gt;CreateChild("DirectionalLight");
lightNode-&gt;SetDirection(Vector3(0.6f, -1.0f, 0.8f));
Light* light = lightNode-&gt;CreateComponent&lt;Light&gt;();
light-&gt;SetColor(Color(0.6f, 0.5f, 0.2f));
light-&gt;SetLightType(LIGHT_DIRECTIONAL);
light-&gt;SetCastShadows(true);
light-&gt;SetShadowBias(BiasParameters(0.00025f, 0.5f));
light-&gt;SetShadowCascade(CascadeParameters(10.0f, 50.0f, 200.0f, 0.0f, 0.8f));
//light-&gt;SetShadowIntensity(0.5f);

Node* zoneNode = scene_-&gt;CreateChild("Zone");
Zone* zone = zoneNode-&gt;CreateComponent&lt;Zone&gt;();
zone-&gt;SetBoundingBox(BoundingBox(-1000.0f, 1000.0f));
zone-&gt;SetAmbientColor(Color(0.4f, 0.5f, 0.8f));
zone-&gt;SetFogColor(Color(0.4f, 0.5f, 0.8f));
zone-&gt;SetFogStart(100.0f);
zone-&gt;SetFogEnd(300.0f);

const unsigned NUM_OBJECTS = 0;
for (unsigned i = 0; i &lt; NUM_OBJECTS; ++i)
{
	Node* mushroomNode = scene_-&gt;CreateChild("Mushroom");
	mushroomNode-&gt;SetPosition(Vector3(Random(90.0f) - 45.0f, 0.0f, Random(90.0f) - 45.0f));
	mushroomNode-&gt;SetRotation(Quaternion(0.0f, Random(360.0f), 0.0f));
	mushroomNode-&gt;SetScale(0.1f + Random(.2f));
	StaticModel* mushroomObject = mushroomNode-&gt;CreateComponent&lt;StaticModel&gt;();
	mushroomObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Mushroom.mdl"));
	mushroomObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/Mushroom.xml"));
	mushroomObject-&gt;SetCastShadows(true);
}

Node* mushroomNode = scene_-&gt;CreateChild("Mushroom");
mushroomNode-&gt;SetPosition(Vector3(0, 0.0f, 0));
StaticModel* mushroomObject = mushroomNode-&gt;CreateComponent&lt;StaticModel&gt;();
mushroomObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Mushroom.mdl"));
mushroomObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/Mushroom.xml"));


cameraNode_ = scene_-&gt;CreateChild("Camera");
Camera* camera = cameraNode_-&gt;CreateComponent&lt;Camera&gt;();
cameraNode_-&gt;SetPosition(Vector3(0.0f, 0.5f, -10.0f));
cameraNode_-&gt;LookAt(Vector3(0.0f, 0.5f, 0.0f));
camera-&gt;SetOrthographic(true);
Graphics* graphics = GetSubsystem&lt;Graphics&gt;();
camera-&gt;SetOrthoSize((float)graphics-&gt;GetHeight() * PIXEL_SIZE);
</code></pre>
<p>}</p>
<p>void Game::MoveCamera(float timeStep)<br/>
{<br/>
Input* input = GetSubsystem();</p>
<pre><code>const float MOVE_SPEED = 20.0f;
const float MOUSE_SENSITIVITY = 0.1f;

IntVector2 mouseMove = input-&gt;GetMouseMove();
yaw_ += MOUSE_SENSITIVITY * mouseMove.x_;
pitch_ += MOUSE_SENSITIVITY * mouseMove.y_;
pitch_ = Clamp(pitch_, -90.0f, 90.0f);

cameraNode_-&gt;SetRotation(Quaternion(pitch_, yaw_, 0.0f));

if (input-&gt;GetKeyDown('Q'))
	cameraNode_-&gt;Translate(Vector3::UP * MOVE_SPEED * timeStep);
if (input-&gt;GetKeyDown('E'))
	cameraNode_-&gt;Translate(Vector3::DOWN * MOVE_SPEED * timeStep);
if (input-&gt;GetKeyDown('W'))
	cameraNode_-&gt;Translate(Vector3::FORWARD * MOVE_SPEED * timeStep);
if (input-&gt;GetKeyDown('S'))
	cameraNode_-&gt;Translate(Vector3::BACK * MOVE_SPEED * timeStep);
if (input-&gt;GetKeyDown('A'))
	cameraNode_-&gt;Translate(Vector3::LEFT * MOVE_SPEED * timeStep);
if (input-&gt;GetKeyDown('D'))
	cameraNode_-&gt;Translate(Vector3::RIGHT * MOVE_SPEED * timeStep);

if (input-&gt;GetKeyPress(KEY_F2))
	GetSubsystem&lt;DebugHud&gt;()-&gt;ToggleAll();
</code></pre>
<p>}</p>
<p>void Game::SubscribeToEvents()<br/>
{<br/>
SubscribeToEvent(E_UPDATE, HANDLER(Game, HandleUpdate));<br/>
SubscribeToEvent(E_SCENEUPDATE, HANDLER(Game, HandleSceneUpdate));<br/>
SubscribeToEvent(E_POSTRENDERUPDATE, HANDLER(Game, HandlePostRenderUpdate));<br/>
SubscribeToEvent(E_ENDRENDERING, HANDLER(Game, HandleEndRendering));<br/>
}</p>
<p>void Game::HandleUpdate(StringHash eventType, VariantMap&amp; eventData)<br/>
{<br/>
using namespace Update;</p>
<pre><code>float timeStep = eventData[P_TIMESTEP].GetFloat();

MoveCamera(timeStep);
</code></pre>
<p>}</p>
<p>void Game::HandleSceneUpdate(StringHash eventType, VariantMap&amp; eventData)<br/>
{<br/>
ResourceCache* cache = GetSubsystem();<br/>
spriteBatch_-&gt;Begin();<br/>
spriteBatch_-&gt;SetBlendMode(BLEND_ALPHA);<br/>
Texture2D* text1 = cache-&gt;GetResource(“Textures/Flare.dds”); // ??? ??? ?? ??? ? ??? ??? ? 50 ???<br/>
Texture2D* tex2 = cache-&gt;GetResource(“Urho2D/Ball.png”); // ??? ??? ???</p>
<pre><code>spriteBatch_-&gt;Draw(tex2, Rect(0, 0, 1, 1), Color::WHITE);

for (int i = 0; i &lt; 200; i++)
{
	//		spriteBatch_-&gt;Draw(text1, Rect(0, 0, 1, 1), Rect(0, 0, 256, 256), Color::WHITE);
}
for (int i = 0; i &lt; 200; i++)
{
	//		spriteBatch_-&gt;Draw(tex2, Rect(1, 0, 2, 1), Rect(0, 0, 256, 256), Color::WHITE);
	//spriteBatch_-&gt;Draw(text1, Rect(1, 0, 2, 1), Rect(0, 0, 256, 256), Color::WHITE);
	//spriteBatch_-&gt;Draw(tex2, Rect(1, 0.5f, 2, 1.5f), Color::WHITE);
}
for (int i = 0; i &lt; 200; i++)
	//		spriteBatch_-&gt;Draw(tex2, Rect(1, 0, 2, 1), Rect(0, 0, 256, 256), Color::WHITE);
spriteBatch_-&gt;End();
</code></pre>
<p>}</p>
<p>void Game::HandlePostRenderUpdate(StringHash eventType, VariantMap&amp; eventData)<br/>
{<br/>
//GetSubsystem()-&gt;DrawDebugGeometry(true);</p>
<pre><code>spriteBatch_-&gt;OnRender(eventType, eventData);
</code></pre>
<p>}</p>
<p>void Game::HandleEndRendering(StringHash eventType, VariantMap&amp; eventData)<br/>
{<br/>
//spriteBatch_-&gt;OnRender(eventType, eventData); // ??? ???, ?? ??? UI, ??? ??? ? HandlePostRenderUpdate<br/>
}</p>
<p>void Game::CreateText()<br/>
{<br/>
ResourceCache* cache = GetSubsystem();</p>
<pre><code>// Construct new Text object
SharedPtr&lt;Text&gt; helloText(new Text(context_));

// Set String to display
helloText-&gt;SetText("========================");

// Set font and text color
helloText-&gt;SetFont(cache-&gt;GetResource&lt;Font&gt;("Fonts/Anonymous Pro.ttf"), 30);
helloText-&gt;SetColor(Color(0.0f, 1.0f, 0.0f));

// Align Text center-screen
helloText-&gt;SetHorizontalAlignment(HA_CENTER);
helloText-&gt;SetVerticalAlignment(VA_CENTER);

// Add Text instance to the UI root element
GetSubsystem&lt;UI&gt;()-&gt;GetRoot()-&gt;AddChild(helloText);
</code></pre>
<p>} [/code]</p>
<p>Game.h</p>
<p>[code]<span class="hashtag">#pragma</span> once</p>
<p><span class="hashtag">#include</span> “SpriteBatch.h”</p>
<p>class Game : public Application<br/>
{<br/>
OBJECT(Game);</p>
<p>public:<br/>
Game(Context* context);</p>
<pre><code>virtual void Setup();
virtual void Start();

void CreateText();
</code></pre>
<p>protected:<br/>
void SetLogoVisible(bool enable);<br/>
SharedPtr scene_;<br/>
SharedPtr cameraNode_;<br/>
float yaw_;<br/>
float pitch_;</p>
<p>private:<br/>
SpriteBatch* spriteBatch_;<br/>
void CreateScene();<br/>
void SetupViewport();<br/>
void MoveCamera(float timeStep);<br/>
void SubscribeToEvents();<br/>
void HandleUpdate(StringHash eventType, VariantMap&amp; eventData);<br/>
void HandleSceneUpdate(StringHash eventType, VariantMap&amp; eventData);<br/>
void HandlePostRenderUpdate(StringHash eventType, VariantMap&amp; eventData);<br/>
void HandleEndRendering(StringHash eventType, VariantMap&amp; eventData);<br/>
}; [/code]</p>
<p>But I have problem.</p>
<p>When I call drawing SpriteBatch in HandleEndRendering it works, but SpriteBatch overlaps UI.</p>
<p><code>void Game::HandleEndRendering(StringHash eventType, VariantMap&amp; eventData)
{
	spriteBatch_-&gt;OnRender(eventType, eventData);
}</code></p>
<div class="spoiler">
<p><div class="lightbox-wrapper"><a class="lightbox" href="http://s020.radikal.ru/i700/1506/20/66a9d271926e.jpg" rel="nofollow noopener" title=""><img alt="" height="500" src="../../../images2/7e94b5aefe12bd8c0d11226a692e2ded.jpg" width="639"/><div class="meta"><svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename"></span><span class="informations">816×638</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg></div></a></div></p>
</div>
<p>When I call drawing SpriteBatch in HandlePostRenderUpdate (like DrawDebugGeometry) it does not work.</p>
<p><code>void Game::HandlePostRenderUpdate(StringHash eventType, VariantMap&amp; eventData)
{
	//GetSubsystem&lt;Renderer&gt;()-&gt;DrawDebugGeometry(true);
	spriteBatch_-&gt;OnRender(eventType, eventData);
}</code></p>
<div class="spoiler">
<p><div class="lightbox-wrapper"><a class="lightbox" href="http://s018.radikal.ru/i527/1506/c2/802267fcd892.jpg" rel="nofollow noopener" title=""><img alt="" height="500" src="../../../images2/1b51032e0540f6901d7cf473f4a3edee.jpg" width="639"/><div class="meta"><svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename"></span><span class="informations">816×638</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg></div></a></div></p>
</div>
<p>Pls help me <img alt=":slight_smile:" class="emoji" src="../../../images2/7bdd5ab4d67675d002d99e4b948c8cdb.png" title=":slight_smile:"/></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">v0van1981</div>
          <div class="post_content">
<p>I found the solution. If call rendering from E_ENDVIEWRENDER all works nice.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>This is a very useful thing, but public under unknown license. So, I decided to write my own implementation (and also for self-education).<br/>
<a href="https://github.com/1vanK/Urho3DSpriteBatch">github.com/1vanK/Urho3DSpriteBatch</a><br/>
I wrote the code for personal use, so there are a lot of comments in Russian, sorry. But still decided to publish his, perhaps it would be useful for someone.<br/>
Main differences:</p>
<ol>
<li>public domain license</li>
<li>infinite count of sprites</li>
<li>correct rendering ttf fonts (but still need to do some things)</li>
<li>possible to render canvas with sprites in 3d space<br/>
This is early version. And I do not know exactly when it will be finished. I will add functionality when I will to need anything.</li>
</ol>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Victor</div>
          <div class="post_content">
<p>This looks interesting! I’m not familiar with XNA or D3DXSprite implementations. It sounds like this could this be used to render fonts in world space? I’ve had this issue for a while where I couldn’t place text correctly onto terrain with a curve (and stroke effect), and so I’ve abandoned the idea temporarily, however if SpriteBatch renders text in world space coords perhaps that would solve my issue. Thanks man!</p>
<p>Reference post to the issue I’m having: <a href="http://discourse.urho3d.io/t/curved-text/2034/9">topic2130.html#p12857</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>It will not help you, it draw all spites in one plane</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Victor</div>
          <div class="post_content">
<aside class="quote">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/ef19ff5c6f85c4920b8ebf7eda2e2ed6.png" width="20"/> 1vanK:</div>
<blockquote>
<p>It will not help you, it draw all spites in one plane</p>
</blockquote>
</aside>
<p>Ah I see. Maybe I could modify it a bit to fit my needs. Either way, thanks for this man! I’m sure it can be helpful in other ways. <img alt=":slight_smile:" class="emoji" src="../../../images2/ab33f6c546ca85e7d84a4e3c32cd4034.png" title=":slight_smile:"/></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<aside class="quote">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/56d7526156403ea04e6f95c8231fbe4f.png" width="20"/> Victor:</div>
<blockquote>
<p>[quote=“1vanK”]It will not help you, it draw all spites in one plane</p>
</blockquote>
</aside>
<p>Ah I see. Maybe I could modify it a bit to fit my needs. Either way, thanks for this man! I’m sure it can be helpful in other ways. :)[/quote]</p>
<p>It is unlikely that all this will be somehow useful to you. The purpose of it - rendering of previously unknown number of sprites, that change every frame without overhead from nodes. Examle of using this: <a href="http://discourse.urho3d.io/t/terraria-like-game-in-urho3d/1698/1">topic1765.html</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>About <a href="https://github.com/1vanK/Urho3DSpriteBatch">github.com/1vanK/Urho3DSpriteBatch</a></p>
<p>Edit: in my tests with 20000 sprites on screen<br/>
MonoGame (Directx 11) - 64 fps<br/>
XNA (DirectX 9) - 46 fps<br/>
Urho3D OpenGL - 56 fps<br/>
Urho3D DrectX - 47 fps<br/>
Urho3D DrectX11 - 62 fps</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>SpriteBatch <a href="https://github.com/1vanK/Urho3DSpriteBatch">github.com/1vanK/Urho3DSpriteBatch</a> generally completed<br/>
The main purpose: tile-based 2D games</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>Currently I works on Sprite Font Generator for Sprite Batch with different special effects (for example blurred shadows):<br/>
<aside class="onebox whitelistedgeneric">
<header class="source">
<img class="site-icon" height="32" src="../../../images2/0973ea8ce7121c320f68413e2a2f23ab.svg" width="32"/>
<a href="https://github.com/1vanK/Urho3DBitmapFontGenerator" target="_blank">GitHub</a>
</header>
<article class="onebox-body">
<img class="thumbnail onebox-avatar" height="420" src="https://avatars1.githubusercontent.com/u/13021826?s=400&amp;v=4" width="420"/>
<h3><a href="https://github.com/1vanK/Urho3DBitmapFontGenerator" target="_blank">1vanK/Urho3DBitmapFontGenerator</a></h3>
<p>Contribute to 1vanK/Urho3DBitmapFontGenerator development by creating an account on GitHub.</p>
</article>
<div class="onebox-metadata">
</div>
<div style="clear: both"></div>
</aside>
<br/>
<div class="lightbox-wrapper"><a class="lightbox"   title="2.png"><img  height="468" src="../../../images2/586342c9c2e5db08773fbee066ac2db4.png"  width="690"/><div class="meta"><svg aria-hidden="true" class="fa d-icon d-icon-far-image svg-icon"><use xlink:href="#far-image"></use></svg><span class="filename">2.png</span><span class="informations">889×603 152 KB</span><svg aria-hidden="true" class="fa d-icon d-icon-discourse-expand svg-icon"><use xlink:href="#discourse-expand"></use></svg></div></a></div></p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>