<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>Moving to C++11</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>

  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="40" alt="Urho3D" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">Archive 17/01/2023.</div>
    <h1 class="topic-title">Moving to C++11</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>Inspired by <a  rel="nofollow noopener">https://github.com/urho3d/Urho3D/pull/1818</a><br/>
Are there any plans to migrate to C++11 and break old compilers support?</p>
<p>Urho doesn’t seem to be rapidly developed right now. It may make sense to publish some stable C++98 version and then go to C++11.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">cadaver</div>
          <div class="post_content">
<p>Apart from JSandusky’s upcoming PRs, it’s true there’s not a lot going on, so yes it sounds like a good idea to push a stable version out in near future.</p>
<p>After that it’s fine by me to break old compiler support, at least I test old VS versions very rarely by now.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>Then I want to raise another question.</p>
<p>C++ has nasty trend to bring style ambigity in new standards. I think that codestyle guidlines have to be updated <em>and most of new C++11 features shan’t be used in Urho core code</em>.</p>
<p>For example, there are some ambigity in the following cases:</p>
<ul>
<li>Variable declaration: explicit-type <strong>vs</strong> auto</li>
<li>Type declaration: typedef <strong>vs</strong> using</li>
<li>Variable initialization: <code>A a = 10</code> <strong>vs</strong> <code>A a(10)</code> <strong>vs</strong> <code>A a{10}</code>
</li>
<li>Member initialization: <code>: a_(10)</code> <strong>vs</strong> <code>a_ = 10</code> <strong>vs</strong> <code>a_{10}</code>
</li>
</ul>
<p>I suggest to <em>avoid</em> in Urho core things like auto, inplace member initialization, curly braces initialization. All <code>typedef</code>s are probably may be converted to <code>using</code> since it is not hard ‘regexpable’ change. Also, <code>nullptr</code> IMO shall be used instead of pure 0. Some <code>override</code>s are also useful.</p>
<p>I suggest it not because I hate C++11, but because I thing that style consistency of Urho costs more than minor benefit from syntax sugar like auto.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>I like initialisation members in class</p>
<pre><code class="lang-auto">class A
{
    int b_ = DEFAULT_VALUE;
}
</code></pre>
<p>This allows not forget initialisation for members (such errors have repeatedly been)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>auto can be used in iterators i think</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>I like inplace member init too! However, Urho shall IMO use either such notation everywhere or nowhere. So another option is to rewrite class declarations step by step into new style.</p>
<blockquote>
<p>auto can be used in iterators i think</p>
</blockquote>
<p>Such exceptions will also lead to inconsistent codestyle.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>First of all I disagree with the “all or nothing” approach because it usually means not doing anything because it will take huge effort and in the meanwhile you just pile up more legacy code, which makes it a huger effort which means it becomes less likelier, which means more legacy code, recursively, which converges to the “nothing” part of the “all or nothing”.</p>
<p>I’m in favor of writing new code in the most optimal way, and going back to refactor old code when revisiting it or when there’s nothing better to do.</p>
<p>regarding new C++11 features you mentioned, they aren’t a style choice.</p>
<p><strong>auto</strong></p>
<ul>
<li>removes the need to maintain and refactor code when changing types</li>
<li>eliminates the possibility of implicit conversion bugs</li>
<li>less writing. Container iterators are a good example</li>
<li>more readable. Container iterators are a good example</li>
<li>easy to use. No need to look up what type is being returned and such</li>
</ul>
<p>I only know 2 cases when you shouldn’t use auto - if you write something like an number type (f.e. auto = 0), in which case the intention behind the value itself is ambiguous (0/0.f/0.0? char/short/int/long?).<br/>
Second case is expression templates, in which they return some abstract reference instead of evaluating the expression.</p>
<p><strong>Alias declarations (using)</strong><br/>
Personally I prefer their syntax because it’s similar to variable assignment.<br/>
Alias declaration is compatible with templates, so AFAIK it’s always better than using typedef so there’s no reason to use typedef anymore.<br/>
<a class="onebox" href="http://stackoverflow.com/questions/10747810/what-is-the-difference-between-typedef-and-using-in-c11" rel="nofollow noopener" target="_blank">http://stackoverflow.com/questions/10747810/what-is-the-difference-between-typedef-and-using-in-c11</a></p>
<p><strong>List initialization</strong><br/>
This one is nuanced, and shouldn’t be used everywhere possible.<br/>
<a class="onebox" href="http://stackoverflow.com/questions/18222926/why-is-list-initialization-using-curly-braces-better-than-the-alternatives" rel="nofollow noopener" target="_blank">http://stackoverflow.com/questions/18222926/why-is-list-initialization-using-curly-braces-better-than-the-alternatives</a></p>
<p>They’re usually preferable because they provide better type safety &amp; correctness.<br/>
On the other hand you can write a constructor that takes an initializer_list and that means calling class{x,y,z} <strong><em>may</em></strong> not be the same as class(x,y,z)</p>
<p>Other features that can be useful constexpr, lambdas, unique_ptr, ranged for loops, Expression SFINAE…</p>
<p>BTW, we could use <a href="http://clang.llvm.org/extra/clang-tidy/" rel="nofollow noopener">Clang Tidy</a> to automatically refactor things to C++11.<br/>
Perhaps it can be used with CI too (?)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>When auto are everywhere it is very difficult to know what type of returns some functions. Currently I open any file on github and know it without looking function definition</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>In Visual Studio you just have to hover over a variable/function too see a tooltip with the type.<br/>
I assume this is a basic IDE feature.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>Even when I am writing my project in Visual Studio  I am using Alt+F7 in Total Commander for search in engine sources and F3 for looking, so no any tooltip xD</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="7" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>First of all I disagree with the “all or nothing” approach because it usually means not doing anything</p>
</blockquote>
</aside>
<p>I mean that there shall be somebody who has enough passion to refactor old codebase step by step to new style. E.g. I prefer inplace initialization and I am ready to periodically migrate old stuff.</p>
<blockquote>
<p>auto</p>
</blockquote>
<p>Absence of <code>auto</code> was the best thing in Urho codestyle. Yes, I dislike auto.</p>
<blockquote>
<p>removes the need to maintain and refactor code when changing types<br/>
eliminates the possibility of implicit conversion bugs</p>
</blockquote>
<p>I have never faced such bugs, so I think they are quite rare. However, I can also imagine bugs that are caused by implicit changing of type of <code>auto</code> variable. So it eliminates one kind of bugs and introduce another.</p>
<pre><code class="lang-auto">String A::foo(); // -&gt; const char* foo()
...
auto a = foo();
if (a == "1") { ... }
</code></pre>
<blockquote>
<p>less writing. Container iterators are a good example</p>
</blockquote>
<p>Of course, impossible to argue. I use auto when WIP or for some simple local projects.</p>
<blockquote>
<p>more readable. Container iterators are a good example- easy to use.</p>
</blockquote>
<p>No, no, no, NO. <code>auto</code> is more readable for some complex temporary types and <em>it completely ruins readability in most other cases</em>. It literally brings strong-typed language into don’t-give-a-fuck-about-type script language like python.</p>
<ul>
<li>It’s harder to explore code via file manager</li>
<li>It’s harder to code via browser</li>
<li>It’s harder to review diff in classical merge tools</li>
<li>It’s harder to review diff in browser</li>
<li>It’s harder to visually check dependencies of some piece of code</li>
<li>It’s harder to determine type usage among codebase</li>
<li>Search became useless</li>
</ul>
<p>Programmer saves a minute by writing <code>auto</code>. Readers waste an hour/day/??? by reading this mess.<br/>
So… Almost-Never-Auto is my choise.<br/>
Almost-Always-Auto guys say that reader don’t need to know about the type.<br/>
I say that if writer is writing code for people, he has no right to decide whether the reader needs type or not.<br/>
Almost-Always-Auto guys say that variable name is enough.<br/>
I say that type name is a ‘part’ of variable name and dropping of type is almost like dropping the name.</p>
<p>The worst thing is that experienced developeds have an immunity to such <code>auto</code> disadvantages because they are familiar with codebase and they really don’t need explicit type. Problems started to appear as time passes, old developers forget codebase and new developers come.</p>
<p>In such big project as Urho, usage of auto IMO shall be strictly limited. Otherwise, its currently perfect readability will be partially destroyed.</p>
<blockquote>
<p>This one is nuanced, and shouldn’t be used everywhere possible.</p>
</blockquote>
<p>It is just almost unneeded. So I see no reason to bring inconsistency to codebase.</p>
<p>Huh, I finihed.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>I encountered bugs that auto would avoid, implicit conversions.<br/>
Your auto “bug” example is wrong, it just shows you don’t understand what auto is. if you don’t want to use the type foo returns you shouldn’t use auto.</p>
<p>auto doesn’t disable strong typing, I’m not sure if you know what that means.<br/>
It isn’t dynamic typing, you can’t change the type of a variable defined with auto, and it’s statically checked.</p>
<p>all auto does it tell the compiler “this variable is of the same type that is being assigned to it”. If that’s your intent, auto is <strong>the correct</strong> way to write your code.</p>
<p>Did you use auto? I never encountered any of the “harder” problems you describe.<br/>
I suspect the reason is because they’re problems caused by not using auto in the first place, like changing the return value of a function and now you have to use search to replaces all the types of the variables that use it.</p>
<p>Herb Sutter had a talk in CppCon 2014 - “Back to the Basics! Essentials of Modern C++ Style”, at ~28:20 he talks about auto:</p><div class="onebox lazyYT lazyYT-container" data-parameters="feature=oembed&amp;wmode=opaque&amp;start=1703" data-youtube-id="xnqTKD8uD64" data-youtube-title='CppCon 2014: Herb Sutter "Back to the Basics! Essentials of Modern C++ Style"'>
<a href="https://www.youtube.com/watch?v=xnqTKD8uD64" rel="noopener nofollow ugc" target="_blank">
<img class="ytp-thumbnail-image" height="360" src="../../../images2/767a027a06c9689cdb7d55ef238a03fc.jpg" title='CppCon 2014: Herb Sutter "Back to the Basics! Essentials of Modern C++ Style"' width="480"/>
</a>
</div>
<aside class="quote no-group" data-post="11" data-topic="2788" data-username="Eugene">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/ae663b3d37eca5ee603f9e0610f8f829.png" width="20"/> Eugene:</div>
<blockquote>
<p>It is just almost unneeded. So I see no reason to bring inconsistency to codebase.</p>
</blockquote>
</aside>
<p>Show me a better way to initialize a vector with the following values than this:</p>
<pre><code class="lang-auto">std::vector&lt;int&gt; v{5, 10, 3, 9, -3, 2500};
</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<aside class="quote" data-post="12" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>Herb Sutter had a talk in CppCon 2014 - “Back to the Basics! Essentials of Modern C++ Style”, at ~28:20 he talks about auto:</p>
</blockquote>
</aside>
<p>He can say any thing, but if I had to guess the type or move mouse to read the tooltip, it does not simplify my life <img alt=":slight_smile:" class="emoji" src="../../../images2/ab33f6c546ca85e7d84a4e3c32cd4034.png" title=":slight_smile:"/> it just slows down the perception of the code</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>I open random files:</p>
<pre><code class="lang-auto">    XMLElement rootElem = file-&gt;GetRoot();
    XMLElement paramElem = rootElem.GetChild();
</code></pre>
<pre><code class="lang-auto">    UI* ui = GetSubsystem&lt;UI&gt;();
    UIElement* uiRoot = ui-&gt;GetRoot();
</code></pre>
<p>Imagine this code with auto.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="12" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>Show me a better way to initialize a vector with the following values than this</p>
</blockquote>
</aside>
<p><code>std::vector&lt;int&gt; v = {5, 10, 3, 9, -3, 2500};</code><br/>
is good enough</p>
<blockquote>
<p>auto doesn’t disable strong typing, I’m not sure if you know what that means.</p>
</blockquote>
<p>I didn’t say ‘disable’. I meant that strong-typed language with <code>auto</code> loses its readability advantages and became scripty.</p>
<blockquote>
<p>Did you use auto?</p>
</blockquote>
<p>Yes.<br/>
I always use <code>auto</code> in small projects that I am not going to maintain. It’s okay.<br/>
I also use <code>auto</code> at work because it is our style. I put up with it.</p>
<blockquote>
<p>I never encountered any of the “harder” problems you describe.</p>
</blockquote>
<p>I did.<br/>
Have you ever tried to explore big infamiliar codebase written in AAA?</p>
<p>Look at <span class="mention">@1vanK</span> example and imange that you know nothing about types <code>XMLElement</code>, <code>UI</code> and <code>UIElement</code>.<br/>
How do you recognize this piece of code then?</p>
<pre><code>auto rootElem = file-&gt;GetRoot();
auto paramElem = rootElem.GetChild();
//&lt; These guys might be similar, yep?
//&lt; Nodes of some hierarchy, probably. What hierarchy?
//&lt; Values or pointers? Must be values because I see dot.
//&lt; What about const?

auto ui = GetSubsystem&lt;UI&gt;();
//&lt; Ok, here I can guess the type. It is some singleton.
//&lt; So it's non-unique pointer
//&lt; Is it shared or raw? What about const?
//&lt; Probably it is just UI*, because it is a singleton.
//&lt; Or maybe weak ptr, who knows?

auto uiRoot = ui-&gt;GetRoot();
//&lt; No ideas WTF is it
//&lt; Root element of some hierarchy.
//&lt; Is the same type as rootElem from first part of code??</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>I had to make this:<br/>
<div class="lazyYT" data-height="270" data-parameters="feature=oembed&amp;wmode=opaque" data-width="480" data-youtube-id="V4DkJtT2jdE" data-youtube-title="autophobia"></div></p>
<p>:^)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>I hope you understand that IDE tooltops is not a solution for explained problem.<br/>
Code shall be readable enough for reviewing via notepad/browser/difftool/etc.<br/>
Code is all that we always have. IDE is optional.</p>
<p>So, briefly, my thoughts and proposal:</p>
<ul>
<li>
<code>auto</code> saves time when writitng code
<ul>
<li>It is the main advantage of <code>auto</code> and the main reason for programmers to use it
<ul>
<li>Other advantages are less important and affect some rare corner cases</li>
</ul>
</li>
</ul>
</li>
<li>You can comfortable work with <code>auto</code> variable if one of the following conditions is true:
<ul>
<li>If you ask IDE for tooltips (i.e. use mouse when reading code)</li>
<li>If you explore variable context (i.e. spend time on checking related functions and objects)</li>
<li>If you are familiar enough with codebase/architecture to guess the type by name and context</li>
</ul>
</li>
<li>Explicit variable decalration is easy to read and understand without any conditions or extra effort.
<ul>
<li>So explicit type is <em>objectively</em> more readable than <code>auto</code>
</li>
<li>Exception: ugly big types
<ul>
<li>Probably such types need or already have an alias
<ul>
<li>If they don’t, <code>auto</code> is a perfect solution!</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Programmers always say that good readablility is more important than quick writing
<ul>
<li>Why <code>auto</code> shall be an exception?</li>
</ul>
</li>
<li>It’s not so hard to replace dozen of <code>auto</code>s in your commit when you finish your work
<ul>
<li>Especially with these nice tooltips
<ul>
<li>Why not to make life easier for others?</li>
</ul>
</li>
</ul>
</li>
</ul>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>Consider the following piece of code:</p>
<pre><code class="lang-auto">int x = f();
</code></pre>
<p>Can you know the return type of f() from reading it?</p>
<p>The answer is no.</p>
<p>auto isn’t about quick writing.<br/>
If that’s your understanding of auto, you didn’t watch the video I linked or wasn’t capable of understanding it.</p>
<p>If you want to stick with C++98 why did you suggest moving to C++11?<br/>
Especially considering you don’t understand and like C++11.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>if f() return not int it should be fixed - “I need int, but it not, wtf” - auto hide this problem</p>
<blockquote>
<p>auto isn’t about quick writing</p>
</blockquote>
<p>auto not about quick learning unknown code</p>
<blockquote>
<p>you didn’t watch the video</p>
</blockquote>
<p>I can found 1000 links criticized auto</p>
<blockquote>
<p>Herb Sutter (Microsoft)</p>
</blockquote>
<p>I will not say anything about quality of code in Microsoft’s products xD</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="18" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>auto isn’t about quick writing</p>
</blockquote>
</aside>
<p>Phew. If auto was long and complex, would anybody use it? I am sure no.<br/>
There are two groups of people who use auto: ones use auto because it is shorther, others don’t want to admit it and try to find another reasons. A kind of lying to yourself.</p>
<blockquote>
<p>If that’s your understanding of auto, you didn’t watch the video I linked or wasn’t capable of understanding it.</p>
</blockquote>
<p>If somebody change return type of function, he <strong>must</strong> revise all places where function is used just because they are affected by this change. Regardless of using or not using auto.</p>
<p>I didn’t watched the video because:</p>
<ul>
<li>I’ve read Sutter and Co and know almost all this stuff about <code>auto</code>
</li>
<li>Nobody explains how to solve readability issues except selfish phrases like &gt;&gt;you don’t need to know a type because I don’t&lt;&lt;</li>
<li>When project is big and maintained by many people, other pros and cons of auto are negilible comparing to readability problem</li>
</ul>
<blockquote>
<p>If you want to stick with C++98 why did you suggest moving to C++11?<br/>
Especially considering you don’t understand and like C++11.</p>
</blockquote>
<p>С++11 has many cool features (including auto) but it doesn’t mean that they shall be thoughtlessly used everywhere.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>Okay, here is another, style question.</p>
<p>Without <code>auto</code> there is only one style of declaring variables.<br/>
With <code>auto</code> there are two styles, because <code>auto</code> can’t replace all explicit declarations.</p>
<p>I dislike this ambigity, but it’s not very bad.</p>
<p>In <em>your</em> opinion, where <code>auto</code> shall be used and where shan’t?<br/>
Do you have some strict rules that can be enforced in guideline?</p>
<p>This criteria is very subjective:</p>
<aside class="quote" data-post="12" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>if you don’t want to use the type foo returns you shouldn’t use auto.</p>
</blockquote>
</aside>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3290_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Modanung</div>
          <div class="post_content">
<h3>See also: <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">C++ Core Guidelines</a>.</h3>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>I tried to read it some time ago. It’s quite big, I am on 25% now.<br/>
Did you want to accent some part of this document?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>It isn’t a stylistic issue.<br/>
It’s correctness, type safety, and maintainability.</p>
<p>I think the same as Herb Sutter: if you want to track a type you should use auto, if you want to stick with a type you shouldn’t. Tracking is the common case.<br/>
Also auto can be used in other cases to keep things DRY, like new, static casts, example:</p>
<pre><code class="lang-auto">auto user = static_cast&lt;Node*&gt;(eventData[Use::P_USER].GetPtr()); // type already mentioned in the static cast
</code></pre>
<p>Watch the video I linked, it has excellent examples of cases that not using auto will cause problems.</p>
<p>"This criteria is very subjective:"<br/>
This isn’t subjective at all, it’s a fact.</p>
<pre><code class="lang-auto">int f();
long x = f(); // f() returns int, we want long. using auto here will result int
</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<aside class="quote" data-post="24" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>int f();<br/>
long x = f(); // f() returns int, we want long. using auto here will result int</p>
</blockquote>
</aside>
<p>long and int is same type <img alt=":slight_smile:" class="emoji" src="../../../images2/ab33f6c546ca85e7d84a4e3c32cd4034.png" title=":slight_smile:"/></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>Wrong, it’s compiler implementation defined and the requirements are different:<br/>
<a class="onebox" href="http://en.cppreference.com/w/cpp/language/types#Integer_types" rel="nofollow noopener" target="_blank">http://en.cppreference.com/w/cpp/language/types#Integer_types</a></p>
<p>So you just created a very subtle bug that may or may not happen to some users on different compilers (including different versions of the same compiler).</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>Ok, I posted answer above already. I expect one type, but function return other. Complier (VS at least) will warn. But if a will using auto, I would not notice this problem</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>they won’t warn because there’s no truncation unless they’re implemented as different sizes. (and even then only VC++ by default)</p>
<p>This was an example for not using auto anyway, when the intention is to stick with long.<br/>
(the bug is something else - assuming long is same type as int)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>Ah, ok I understood what you mean</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="24" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>if you want to track a type you should use auto, if you want to stick with a type you shouldn’t.<br/>
…<br/>
"This criteria is very subjective:"<br/>
This isn’t subjective at all, it’s a fact.</p>
</blockquote>
</aside>
<p>Okay, let’s imagine. One guy insist that the type of some variable shall be explicit. Another guy insist that type of some variable shall be auto. If your criteria is a fact, please logically solve this argument.</p>
<pre><code>const String::operator std::string() { /* cast to std string here with copying */}
const String&amp; Node::GetName();
...
const auto&amp; name = node-&gt;GetName(); // vs const String&amp; name
if (name == "Player") { ... }
</code></pre>
<p>One guy said that explicit type is better because if we change String to const char* the nasty bug will appear:</p>
<blockquote>
<p>if you don’t want to use the type foo returns you shouldn’t use auto.</p>
</blockquote>
<p>Another guy said that auto type is better because if we write explicit <code>String</code> and change <code>String</code> to <code>std::string</code> in function signature, the redundand copying will appear. Also, code is generic enough to work with different types of strings. According to all guidelines, <code>auto</code> shall be used here.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1151_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">hdunderscore</div>
          <div class="post_content">
<p>In practice code will be contributed to Urho using the contributors preference, and it is unlikely an issue will arise unless they are going full-auto and it has become hard to read. If there is a bug identified, the contributor will surely feel compelled to correct the bug.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="31" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/02d61e3060a688b67b1e19db1fd8be9b.png" width="20"/> hdunderscore:</div>
<blockquote>
<p>In practice code will be contributed to Urho using the contributors preference, and it is unlikely an issue will arise unless they are going full-auto and it has become hard to read.</p>
</blockquote>
</aside>
<p>That’s the problem.<br/>
Some guys like me will probably almost avoid <code>auto</code> in commits.<br/>
Some guys like <span class="mention">@1vanK</span> will use <code>auto</code> somewhere for long types.<br/>
Some guys like <span class="mention">@Enhex</span> will prefer using <code>auto</code> in declarations.<br/>
Then, code <em>may</em> stay readable enough.<br/>
However, code will be a mess of different styles. That’s ugly.<br/>
Urho3D has so nice style now, because it was written by single person in a languare that has no <code>auto</code>.<br/>
It’s hard for me to admit that this will be lost.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1151_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">hdunderscore</div>
          <div class="post_content">
<p>Looking through the urho codebase, I don’t see many instances of where code would be improved by auto. For entertainment value, an automated tool can be used to put that to the test (eg, <a href="https://github.com/steveire/clazy" rel="nofollow noopener">https://github.com/steveire/clazy</a>).</p>
<p>Moving on to other C++11 features, I think brace initialization is clearer and more convenient when extended with initialization_lists. I think <code>typedef</code>s should be upgraded to use <code>using</code>. <code>enum</code>s upgraded to <code>enum class</code>es (as long as scripting doesn’t choke on it).</p>
<p>I think an upgrade to use <code>move</code> could be worthwhile. With the change to c++11 we could maybe re-evaluate using our custom containers vs the stl.</p>
<p>I would probably avoid lambdas for the most part.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>I hate such disputes, trust me… <em>sigh</em> <img alt=":weary:" class="emoji" src="../../../images2/7f97e70f0fa83965cdd1e044ca6a6ed0.png" title=":weary:"/></p>
<p>There is interface-oriented AAA (yep, I’ve read Sutter and his articles).<br/>
There is type-oriented… huh, let’s call it 98</p>
<p>AAA is nice-looking. 98 is bulky.<br/>
AAA is theorectically perfect. 98 has theoretical pitfalls.<br/>
Yes, they are more theorethical than practical since function signature is rarerly changed.<br/>
You have much more chances to inject bug e.g. in logic or catch a problem with implicit casting from SharedPtr to T*.</p>
<p>98 is used for all legacy code. AAA is used nowhere.<br/>
98 is simpler to understand. AAA is more puzzled.</p>
<p>I don’t say that AAA has no benefits.<br/>
However, I think that benefits of 98 cost more than benefits of AAA when we are talking about Urho (old big project).<br/>
If we were talking about new small project, AAA’d be better.<br/>
If we were talking about new big project… questionable. Maybe I have to try big AAA project at some point.</p>
<aside class="quote" data-post="33" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/02d61e3060a688b67b1e19db1fd8be9b.png" width="20"/> hdunderscore:</div>
<blockquote>
<p>enums upgraded to enum classes</p>
</blockquote>
</aside>
<p>Then we will have to write some migration script to Find&amp;Replace old enums with new ones in client (and Urho) code.</p>
<blockquote>
<p>With the change to c++11 we could maybe re-evaluate using our custom containers vs the stl.</p>
</blockquote>
<p>Unsure that it’s good idea. This will break a lot of code unless wrappers over STL are written.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">cadaver</div>
          <div class="post_content">
<p>Guaranteed binary size is to me still the biggest advantage of the custom containers, which allows storing them “inside” Variant. Moving to STL containers the only safe thing to do would be to always heap allocate them instead, which would add some overhead. I don’t pretend that the custom containers are a performance advantage nowadays, and if I was starting a new engine today I would likely avoid them, just to reduce maintenance cost / codebase size / possibility of errors.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/768_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">1vanK</div>
          <div class="post_content">
<p>In <a href="https://github.com/1vanK/Urho3DSpriteBatch/blob/master/SpriteBatch.h">https://github.com/1vanK/Urho3DSpriteBatch/blob/master/SpriteBatch.h</a> I compared Urho3D::PODVector vs std::vector, and Urho3D::PODVector won <img alt=":slight_smile:" class="emoji" src="../../../images2/ab33f6c546ca85e7d84a4e3c32cd4034.png" title=":slight_smile:"/></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="35" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/17ea6233fe86521c2e3179bd3849d219.png" width="20"/> cadaver:</div>
<blockquote>
<p>I don’t pretend that the custom containers are a performance advantage nowadays, and if I was starting a new engine today I would likely avoid them, just to reduce maintenance cost / codebase size / possibility of errors.</p>
</blockquote>
</aside>
<p>However, your containers are much faster than STL ones in debug mode.<br/>
It’s getting too hard to debug something when you have 5 FPS on complex scene with these safe iterators.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">cadaver</div>
          <div class="post_content">
<p>Does the iterator debug level help, though?</p>
<p><a class="onebox" href="https://msdn.microsoft.com/en-us/library/hh697468.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/hh697468.aspx</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>I haven’t managed to make it work last time when I tried it. It was long time ago.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<aside class="quote no-group" data-post="35" data-topic="2788" data-username="cadaver">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/b36d360b4fce73300b0e56f725288d21.png" width="20"/> cadaver:</div>
<blockquote>
<p>Guaranteed binary size is to me still the biggest advantage of the custom containers</p>
</blockquote>
</aside>
<p>What about STL implementations which aren’t bundled with the compiler? Like <a href="https://github.com/electronicarts/EASTL" rel="nofollow noopener">EASTL</a> (haven’t looked into it myself).</p>
<p><a href="http://www.boost.org/doc/libs/1_63_0/doc/html/container.html" rel="nofollow noopener">Boost.Container</a> also provides some nice optimized containers.<br/>
I benchmarked its small_vector and it’s very fast for its purpose:<br/>
<aside class="onebox whitelistedgeneric">
<header class="source">
<img class="site-icon" height="32" src="../../../images2/d0490478adfca47a45166681e4ca041f.ico" width="32"/>
<a href="https://chart-studio.plotly.com/~Enhex/74.embed" rel="nofollow noopener" target="_blank">chart-studio.plotly.com</a>
</header>
<article class="onebox-body">
<div class="aspect-image" style="--aspect-ratio:690/492;"><img class="thumbnail" height="492" src="../../../images2/ce960cb7792e913526a70e10061fa442.png" width="690"/></div>
<h3><a href="https://chart-studio.plotly.com/~Enhex/74.embed" rel="nofollow noopener" target="_blank">boost small_vector | line chart made by Enhex | plotly</a></h3>
<p>Enhex's interactive graph and data of "boost small_vector" is a line chart, showing vector, vector reserve 10, small_vector 10; with Elements in the x-axis and Baseline in the y-axis..</p>
</article>
<div class="onebox-metadata">
</div>
<div style="clear: both"></div>
</aside>
<br/>
(source: <a href="https://github.com/Enhex/Benchmarks/tree/master/boost%20small_vector" rel="nofollow noopener">https://github.com/Enhex/Benchmarks/tree/master/boost%20small_vector</a>)<br/>
Tho I’m getting off topic.</p>
<aside class="quote no-group" data-post="37" data-topic="2788" data-username="Eugene">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/ae663b3d37eca5ee603f9e0610f8f829.png" width="20"/> Eugene:</div>
<blockquote>
<p>much faster than STL ones in debug mode.</p>
</blockquote>
</aside>
<p>That’s because they don’t provide any debugging information, which defeats the purpose.<br/>
I know that in my code I had to replace things like HashMap with std::unordered_map to be able to debug their content.</p>
<p>it’s like saying:</p>
<pre><code class="lang-auto">int main() {
  while(true) {}
}
</code></pre>
<p>is the fastest game engine. It’s fast because it doesn’t do anything useful.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote no-group" data-post="40" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2c165096ad375255e0c52a6a81137cd8.png" width="20"/> Enhex:</div>
<blockquote>
<p>What about STL implementations which aren’t bundled with the compiler? Like EASTL (haven’t looked into it myself).</p>
</blockquote>
</aside>
<p>I think that the biggest issue is not about implementation, but about interfaces. There are a lot of downstream projects. It would be cruel to make their authors to fix their code.<br/>
It is possible to rewrite e.g. EASTL to fit it into legacy interface of Urho containers, but it will require some effort.</p>
<blockquote>
<p>That’s because they don’t provide any debugging information, which defeats the purpose.<br/>
I know that in my code I had to replace things like HashMap with std::unordered_map to be able to debug their content.</p>
</blockquote>
<p>wat? <img alt=":confused:" class="emoji" src="/images/emoji/twitter/confused.png?v=9" title=":confused:"/></p>
<p>What kind of STL debug garbage do you need?<br/>
If I want to debug Urho containers, I do it in debugger.</p>
<p><img height="167" src="//cdck-file-uploads-global.s3.dualstack.us-west-2.amazonaws.com/standard17/uploads/urho3d/original/1X/c94cbcd77f2bc21120ed6809214bc8d18272a7dd.png" width="690"/></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<aside class="quote no-group" data-post="41" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/ae663b3d37eca5ee603f9e0610f8f829.png" width="20"/> Eugene:</div>
<blockquote>
<p>If I want to debug Urho containers, I do it in debugger.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-post="40" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2c165096ad375255e0c52a6a81137cd8.png" width="20"/> Enhex:</div>
<blockquote>
<p>…be able to debug their content.</p>
</blockquote>
</aside>
<p>Try doing that.</p>
<p>Here’s what I see:<br/>
<img src="//cdck-file-uploads-global.s3.dualstack.us-west-2.amazonaws.com/standard17/uploads/urho3d/original/1X/9c2c5aeb5fcf1e4954fa6b85e444d4eb3251aaf4.png"/></p>
<p>Which doesn’t happen with std containers.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>Huh.<br/>
Additionally, you’ll need some knowledge about debug visualizers. Complex stuff like HashMap also requires VS 2015.<br/>
It’s not very hard to make it work, check this.<br/>
<aside class="onebox whitelistedgeneric">
<header class="source">
<img class="site-icon" height="32" src="../../../images2/0973ea8ce7121c320f68413e2a2f23ab.svg" width="32"/>
<a href="https://github.com/eugeneko/Urho3D-Debug" rel="nofollow noopener" target="_blank">GitHub</a>
</header>
<article class="onebox-body">
<img class="thumbnail onebox-avatar" height="420" src="https://avatars0.githubusercontent.com/u/8576192?s=400&amp;v=4" width="420"/>
<h3><a href="https://github.com/eugeneko/Urho3D-Debug" rel="nofollow noopener" target="_blank">eugeneko/Urho3D-Debug</a></h3>
<p>Urho3D Debug Visualizer for Visual Studio 2017. Contribute to eugeneko/Urho3D-Debug development by creating an account on GitHub.</p>
</article>
<div class="onebox-metadata">
</div>
<div style="clear: both"></div>
</aside>
</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1163_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">yushli1</div>
          <div class="post_content">
<p>Thanks for the VS2015 Visualizer file! That really works. It helps a lot when debugging.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>Thanks!</p>
<p>BTW when debugging std::unordered_map you can see the original strings (with the visualizer you only see hashes).<br/>
I assume std::unordered_map stores the strings in debug which makes it slower, but provides useful information.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="45" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>with the visualizer you only see hashes</p>
</blockquote>
</aside>
<p>That’s because <code>Urho3D::VariantMap</code> is <code>HashMap&lt;StringHash, Variant&gt;</code> and don’t contain names.<br/>
So, that’s not a question to visualizer or debug info. More likely, it’s about performance and amount of allocations made by <code>VariantMap</code>.</p>
<p><code>HashMap&lt;String, Variant&gt;</code> will give you real strings, of course.<br/>
I mean I hope so because I tested my visulaized long time ago.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Sinoid</div>
          <div class="post_content">
<p>Don’t wait on me. An upgrade to C++11 will be massively beneficial to most of the pending stuff. Variadic templates could really simplify shaders (aside from the hash-code … which will just get fatter, but the pipeline looks pretty fixed now so that’s just 64bit int).</p>
<p>The only thing I’d like to push out before then would be cubemap filtering (that also means DDS writing, have to write those mipmaps for filtering them to really be worth anything).</p>
<ul>
<li>Offtopic, is there a footer sytem so I can indicate “keep it on technical point” or such? I want to keep my involvement to task at hand, not idealogy and such.</li>
</ul>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/74_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">TheSHEEEP</div>
          <div class="post_content">
<p>Rule no. 1 for system changes:<br/>
If it ain’t broken, don’t fix it.</p>
<p>If the custom containers work just fine and impose no performance/memory downside, there’s no reason to switch to STL ones. Obviously, this can be tested and it seems some did that already (and seemingly there’s no reason to switch).</p>
<p>Auto… oh, auto… Let’s not. Please. I like to read my code and understand it without having to move back through functions until a <strong>real</strong> type appears somewhere.<br/>
I see the point in using it for abbreviation purposes, though. Iterators are a good example, because their type declaration usually looks like it was made to make people suffer. If there is a “auto iter = someContainer.begin();”, everybody will understand it and some (like me) will be thankful. A typedef is IMO not a solution here because it just moves the problem out of sight (you got the ugly piece of code elsewhere, but it is still present).<br/>
But in all other cases, auto just adds confusion instead of clarity.<br/>
Either way, there is no gain in replacing working existing code with it.</p>
<p>I can’t say much about other issues like with variadic templates. Personally, I avoid templates like the plague, because I like to retain my sanity when reading error outputs. Of course, I see the point in them, so if existing code can actually be made <strong>more</strong> readable or more performant with them, I’m all for it.<br/>
As long as I don’t have to write them, I really don’t care if a library I use makes use of them <img alt=":smiley:" class="emoji" src="../../../images2/c16ddadcbd525aa6d219a1df596d362f.png" title=":smiley:"/></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-post="48" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/6426f7dffe1147b9888a7457752fca5d.png" width="20"/> TheSHEEEP:</div>
<blockquote>
<p>A typedef is IMO not a solution here because it just moves the problem out of sight (you got the ugly piece of code elsewhere, but it is still present).</p>
</blockquote>
</aside>
<p>If you need iterator, you probably have container, e.g. <code>Vector&lt;SharedPtr&lt;Object&gt;&gt;</code>.<br/>
Such container is probably used in several places and may be typedef-ed.<br/>
<code>ObjectArray::Iterator</code> is much less scary, isn’t it?<br/>
But it is an issue what is more readable: long name with all related types or typedef abbreviation.</p>
<aside class="quote" data-post="48" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/6426f7dffe1147b9888a7457752fca5d.png" width="20"/> TheSHEEEP:</div>
<blockquote>
<p>But in all other cases, auto just adds confusion instead of clarity.</p>
</blockquote>
</aside>
<p>This is not a problem of <code>auto</code> itself. It’s mostly about ‘interface-oriented’ programming style when you work with public interfaces (e.g. public methods or properties) instead of concrete types. C++ templates are usually written in such style, and this style is common for script languages like Lua or Pyhton.<br/>
And I agree that ‘interface-oriented’ code is harder to understand than classic ‘object-oriented’.</p>
<aside class="quote" data-post="48" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/6426f7dffe1147b9888a7457752fca5d.png" width="20"/> TheSHEEEP:</div>
<blockquote>
<p>I see the point in using it for abbreviation purposes, though. Iterators are a good example, because their type declaration usually looks like it was made to make people suffer. If there is a “auto iter = someContainer.begin();”,</p>
</blockquote>
</aside>
<p>Urho has a bucket of rules like ‘no tabs’, ‘use camel case’ etc. They are strict and easy to follow.</p>
<p>The probem with <code>auto</code> is that anybody have his own criteria where to use <code>auto</code> and where not to use.<br/>
If <span class="mention">@cadaver</span> just say ‘follow the common sence’, Urho may end up in codestyle mess because everybody has its own (of course, evident) rules.</p>
<p>Just look at these examples and try to answer where to use <code>auto</code> and where not to (and why):</p>
<ol>
<li>
<p><code>Vector&lt;HashMap&lt;String, Pair&lt;Node, Component&gt;&gt;&gt;::Iterator</code><br/>
very long and ugly iterator</p>
</li>
<li>
<p><code>Vector&lt;SharedPtr&lt;Component&gt;&gt;::Iterator</code><br/>
just quite long iterator</p>
</li>
<li>
<p><code>Vector&lt;SharedPtr&lt;Component&gt;&gt;</code><br/>
this type is not an iterator, but still long</p>
</li>
<li>
<p><code>Vector&lt;SharedPtr&lt;Component::Data&gt;&gt;</code><br/>
as long as 2) but <em>almost</em> the same as 3)</p>
</li>
<li>
<p><code>const Vector&lt;SharedPtr&lt;Component&gt;&gt;&amp;</code><br/>
as long as 2) but <em>the same</em> as 3)</p>
</li>
<li>
<p><code>Vector&lt;int&gt;::Iterator</code><br/>
pretty short iterator</p>
</li>
<li>
<p><code>HashMap&lt;String, int&gt;</code><br/>
as long as 6) but not an iterator</p>
</li>
<li>
<p><code>const HashMap&lt;String, int&gt;&amp;</code><br/>
longer than 6) but not an iterator</p>
</li>
</ol>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">cadaver</div>
          <div class="post_content">
<p>I just looked at the Turso3D codebase and there I have used auto for iterators only (shortening &amp; convenience). That could be one possible rule that’s at least easy to follow. But I don’t want to say it should be <em>the</em> rule, or that I’d want final authority on this matter. I agree that it’s just important that we decide something that is clear to follow.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Victor</div>
          <div class="post_content">
<aside class="quote">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/17ea6233fe86521c2e3179bd3849d219.png" width="20"/> cadaver:</div>
<blockquote>
<p>I just looked at the Turso3D codebase and there I have used auto for iterators only (shortening &amp; convenience). That could be one possible rule that’s at least easy to follow. But I don’t want to say it should be the rule, or that I’d want final authority on this matter. I agree that it’s just important that we decide something that is clear to follow.</p>
</blockquote>
</aside>
<p>That’s pretty much how I’ve been using ‘auto’ as well.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<p>I have two more cases. <code>auto</code> shall (may?) be used</p>
<ul>
<li>with <em>any</em> iterators if there is no one-word alias</li>
<li>with <em>any</em> pairs and pair-like structures (e.g. <code>HashMap&lt;T, U&gt;::KeyValue&gt;</code>) if there is no one-word alias
<ul>
<li>However, prefer to extract pair content into variables with meaningful names</li>
</ul>
</li>
<li>with unknown template types if there is no one-word alias
<ul>
<li>So, use <code>auto</code> instead of those ugly <code>typename</code>s and <code>decltype</code>s</li>
</ul>
</li>
</ul>
<p>Such rules are also pretty clear to follow, IMO.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3200_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">rku</div>
          <div class="post_content">
<aside class="quote" data-post="48" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/6426f7dffe1147b9888a7457752fca5d.png" width="20"/> TheSHEEEP:</div>
<blockquote>
<p>If the custom containers work just fine and impose no performance/memory downside, there’s no reason to switch to STL ones. Obviously, this can be tested and it seems some did that already (and seemingly there’s no reason to switch).</p>
</blockquote>
</aside>
<p>I am in favor of using standard containers. Less confusion and better interoperability with other libraries not to mention not having to maintain said containers. Custom stuff is only useful if it provides something standard stuff does not. But is there really any benefit nowdays?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>Urho’s HashMap doesn’t handle collisions, so it’s faster but less reliable than std::unordered_map.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/902_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Eugene</div>
          <div class="post_content">
<aside class="quote" data-full="true" data-post="54" data-topic="2788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/2a544a080a692659db243ae9ac8c57ef.png" width="20"/> Enhex:</div>
<blockquote>
<p>Urho’s HashMap doesn’t handle collisions, so it’s faster but less reliable than std::unordered_map.</p>
</blockquote>
</aside>
<p>Why do you think so? This sounds <em>very</em> strange. Generic HashMap container must handle collisions.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/81_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Enhex</div>
          <div class="post_content">
<p>It seems I’m wrong, for some reason I remembered it doesn’t handle collisions.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3200_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">rku</div>
          <div class="post_content">
<p>At the same note we really should drop old cmake support. New versions have some useful goodies that would help simplifying build system, and boy oh boy we do need that. For example i came upon <a href="https://cmake.org/cmake/help/v3.0/command/target_compile_definitions.html" rel="nofollow noopener">target_compile_definitions</a> just now. The only reason to hold back on cmake would be having easy support for linux distributions, however new ubuntu LTS (16.04) already ships cmake v3.5. For windows it does not matter as user just installs latest and greatest from cmake website.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Sinoid</div>
          <div class="post_content">
<p>I rescind a desire to squeeze out cubemap filtering, I’m butting heads intensely with just interacting with cmft and the like remotely without crashing as a post process, that’s a red flag. It’s also just not going to fit even in a case of relying on other tools. I would much rather see a hard release and then work on finishing surround and LFE sound.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1493_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">TheComet</div>
          <div class="post_content">
<p>Travis CI still uses an ancient version of cmake. You’d break integration tests by using newer cmake stuff.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/4_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">weitjong</div>
          <div class="post_content">
<p>Just dropping by to say that there is no reason to set the minimum required CMake version higher than it needs to be. That is, we should only increase the version to the level our script really utilizes. Setting a high version number does not automatically make our build system better. I do agree on the point that we should modernize the scripts to take the advantage of some of the newer features and idioms provided by newer CMake though.</p>
<p>Also keep in mind there is more Linux distros out there than Ubuntu. So what CMake version it shipped in what LTS version does not have too much bearing on our decision making, except for our CI need as highlighted by TheComet.</p>
<p>And lastly. please stay on topic.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3290_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Modanung</div>
          <div class="post_content">
<p><a href="https://repology.org/metapackage/cmake/versions">Here</a>’s an overview of CMake versions in different repositories.</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>