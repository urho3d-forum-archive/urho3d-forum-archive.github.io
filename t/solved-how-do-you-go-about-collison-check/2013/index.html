<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>[SOLVED]how do you go about collison check?</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>

  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="40" alt="Urho3D" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">Archive 17/01/2023.</div>
    <h1 class="topic-title">[SOLVED]how do you go about collison check?</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>hi,</p>
<p>my project start to looks like something but i need to do some collision check<br/>
<a data-bbcode="true" href="http://www.hostingpics.net/viewer.php?id=901234cooltest3.png" rel="nofollow noopener"><img alt="" height="" src="../../../images2/52b52ae60908f2b7f6f910025cf185b2.png" width=""/></a></p>
<p>after checking the wiki, i think that for each of my module, i need to add this to get a precise bounding box</p>
<pre><code class="lang-auto">//add physic        dont forget to include RigidBody and CollisionShape
        RigidBody* m_Body=moduleNode-&gt;CreateComponent&lt;RigidBody&gt;();
        m_Body-&gt;SetMass(0);  //0 for static object
        m_Body-&gt;SetFriction(0.6);        // friction with other objects (like the ground)
//add collision shape
        CollisionShape* m_BBox=moduleNode-&gt;CreateComponent&lt;CollisionShape&gt;();      
        m_BBox-&gt;SetTriangleMesh(cache-&gt;GetResource&lt;Model&gt;(path));</code></pre>
<p>then i can use layers</p>
<pre><code class="lang-auto">m_body-&gt;SetCollisionLayer(2)</code></pre>
<p>but how do you do a collision check between two bounding box ? what must i use ?<br/>
so that if a module spawn on another, i change it or delete it or whatever.</p>
<p>and by the way, i have a little question :  is there a way to get  a list of all the scene child ?</p>
<p>thx</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i found this page : <a href="http://urho3d.github.io/documentation/1.5/_physics.html" rel="nofollow noopener">urho3d.github.io/documentation/1.5/_physics.html</a> that direct me to <a data-bbcode="true" href="http://urho3d.github.io/documentation/1.5/class_urho3_d_1_1_rigid_body.html#ae8efeb02d37b545321b84f35ed355b34" rel="nofollow noopener">GetCollidingBodies()</a></p>
<p>so i guess it could work with :</p>
<pre><code class="lang-auto">if(m_Body-&gt;GetCollidingBodies() != 0)  //or NULL ?
{
    //there is a collision with another module : do something.
}
else
{
    //there is no collision, the module can stay here.
}</code></pre>
<p>i will try that and see.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<p>in my project iam working with the E_NODECOLLISION event.</p>
<p>[code]<br/>
SubscribeToEvent(mynode, E_NODECOLLISION, HANDLER(objectevents, HandleObjectCollision)); //for every node that should trigger something on collision</p>
<p>void objectevents::HandleObjectCollision(StringHash eventT, VariantMap&amp; eData)<br/>
{<br/>
RigidBody* body = static_cast&lt;RigidBody*&gt;(eData[P_BODY].GetPtr());<br/>
Component* comp;<br/>
comp=body-&gt;GetComponent(“StaticModel”);<br/>
Node* myobject;<br/>
myobject=comp-&gt;GetNode ();</p>
<p>…</p>
<p>}[/code]</p>
<p>I have a xml file looks like this to load and subscribe the events per level in a function:</p>
<p>[code]&lt;?xml version="1.0"?&gt;<br/>
<br/>
<br/>
<br/>
</p>
 
    
    
[/code]
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>your method seems a bit complicated to me but thx anyway. i didn’t tryed anything yet, i will check it out later, the SubscribeToEvent could be usefull.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<aside class="quote no-group" data-username="noals">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/a5e8b4bb38a57a1c8db086db537a8e5d.png" width="20"/> noals:</div>
<blockquote>
<p>your method seems a bit complicated to me but thx anyway. i didn’t tryed anything yet, i will check it out later, the SubscribeToEvent could be usefull.</p>
</blockquote>
</aside>
<p>yep i try to don’t hardcode too much in my game, so i need this xml solution. You can do it with urho node variables too, or just hardcode it <img alt=":wink:" class="emoji" src="../../../images2/58bcd684421190f24be1944e2a997a04.png" title=":wink:"/></p>
<p>and yep you will need SubscribeToEvent.</p>
<p>You can also only subscribe your mainchar and look with what he collude. (setting variables or names to the nodes to choose the trigger), but then your objects don’t interact between each other</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2367_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">jmiller</div>
          <div class="post_content">
<aside class="quote no-group" data-username="noals">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/a5e8b4bb38a57a1c8db086db537a8e5d.png" width="20"/> noals:</div>
<blockquote>
<p>and by the way, i have a little question :  is there a way to get  a list of all the scene child ?</p>
</blockquote>
</aside>
<p>Hi,<br/>
Scene::GetChildren() is one way.<br/>
Here is a quick and dirty recursive print method, copypasta untested, Using Urho head revision… should not be too different for 1.5.<br/>
<a data-bbcode="true" href="http://urho3d.github.io/documentation/HEAD/class_urho3_d_1_1_scene.html">Scene</a> is a type of Node, so this works with both types.</p>
<p>[details=Code][code]<br/>
decl:<br/>
void PrintTree(Urho3D::Node* node, unsigned level = 0);</p>
<p>void SceneManager::PrintTree(Node* node, unsigned level /* = 0 */) {<br/>
// if you do not like spam<br/>
// if (node-&gt;HasComponent()) return;</p>
<p>String s(’+’, level); // indentation<br/>
s += “&lt;” + node-&gt;GetName() + “&gt;” + " pos:" + String(node-&gt;GetPosition());</p>
<p>URHO3D_LOGRAW(s + ‘\n’); // opt. URHO3D_LOGINFO etc.</p>
<p>if (!node-&gt;GetChildren().Empty()) {<br/>
const Vector&lt;SharedPtr&gt; children(node-&gt;GetChildren()); // pre-C++11 needs a space: &lt;SharedPtr &gt;<br/>
for (unsigned i = 0; i &lt; children.Size(); ++i) {<br/>
PrintTree(children[i], level + 1);<br/>
}<br/>
}<br/>
}<br/>
[/code][/details]</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>[quote=“Nerrik”]</p>
<p>yep i try to don’t hardcode too much in my game, so i need this xml solution. You can do it with urho node variables too, or just hardcode it <img alt=":wink:" class="emoji" src="../../../images2/95940790c23d98635b2a6d3f22657158.png" title=":wink:"/></p>
<p>and yep you will need SubscribeToEvent.</p>
<p>You can also only subscribe your mainchar and look with what he collude. (setting variables or names to the nodes to choose the trigger), but then your objects don’t interact between each other[/quote]<br/>
i also use xml, i code so that when it is compiled, you can just change the modules at your liking with the xml. (or other things later)</p>
<pre><code class="lang-auto"></code></pre>
<p>i didn’t do a character yet but i know i will at least need 3 physics layer because i think modules side by side would return a collision==true;</p>
<p>[quote=“carnalis”]</p>
<p>Hi,<br/>
Scene::GetChildren() is one way.<br/>
Here is a quick and dirty recursive print method, copypasta untested, Using Urho head revision… should not be too different for 1.5.<br/>
<a data-bbcode="true" href="http://urho3d.github.io/documentation/HEAD/class_urho3_d_1_1_scene.html" rel="nofollow noopener">Scene</a> is a type of Node, so this works with both types.</p>
<p>[spoiler][code]<br/>
decl:<br/>
void PrintTree(Urho3D::Node* node, unsigned level = 0);</p>
<p>void SceneManager::PrintTree(Node* node, unsigned level /* = 0 */) {<br/>
// if you do not like spam<br/>
// if (node-&gt;HasComponent()) return;</p>
<p>String s(’+’, level); // indentation<br/>
s += “&lt;” + node-&gt;GetName() + “&gt;” + " pos:" + String(node-&gt;GetPosition());</p>
<p>URHO3D_LOGRAW(s + ‘\n’); // opt. URHO3D_LOGINFO etc.</p>
<p>if (!node-&gt;GetChildren().Empty()) {<br/>
const Vector&lt;SharedPtr&gt; children(node-&gt;GetChildren()); // pre-C++11 needs a space: &lt;SharedPtr &gt;<br/>
for (unsigned i = 0; i &lt; children.Size(); ++i) {<br/>
PrintTree(children[i], level + 1);<br/>
}<br/>
}<br/>
}<br/>
[/code][/spoiler][/quote]<br/>
ah ok, so you can make a vector of children and incremente until your pointer is* empty when you get them from the scene. thx, that’s good to know. (edit: i reread and the node method too is good to know ^^)<br/>
*edit 2 &gt;&lt;</p>
<p>i go do some tries, i also need to check the physic demo to see what <span class="hashtag">#include</span> i need, etc…</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>another question, is it possible to change the color of the collision layer when i render it ? how should i do ?<br/>
in the physic example, you can use the SPACE key to see the physic stuff so i put different layers for the first module and the others module but i can’t see the difference when rendering.</p>
<p><a data-bbcode="true" href="http://www.hostingpics.net/viewer.php?id=646635physicstuff.png" rel="nofollow noopener"><img alt="" height="" src="../../../images2/a725b65af7194d052de355dcddb10b13.png" width=""/></a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<aside class="quote">
<blockquote>
<p>i didn’t do a character yet but i know i will at least need 3 physics layer because i think modules side by side would return a collision==true;</p>
</blockquote>
</aside>
<p>there is also an NodeCollisionEnd event, to handle double collisions if you mean that. (with an “lastcollision” array or something like this).</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i saw that in the doc : <a data-bbcode="true" href="http://urho3d.github.io/documentation/1.5/_event_list.html" rel="nofollow noopener">http://urho3d.github.io/documentation/1.5/_event_list.html</a></p>
<aside class="quote">
<blockquote>
<p>NodeCollisionEnd</p>
<pre><code>Body : RigidBody pointer
OtherNode : Node pointer
OtherBody : RigidBody pointer
Trigger : bool
</code></pre>
</blockquote>
</aside>
<p>so if the two RigidBody are side by side, i can define them as “false” so they will not be seen as colliding ?<br/>
yes i would need that, thx.<br/>
but how do i use it ?</p>
<p>[quote](with an “lastcollision” array or something like this)[/quote] ?<br/>
i’m lost already lol.</p>
<p>i put the m_Body on the same layer and i will try that tomorrow :</p>
<p>[code]        c_light=scene-&gt;CreateChild(“collision_light”);<br/>
c_light-&gt;SetPosition(Vector3(position.x_, position.y_+1, position.z_));<br/>
{<br/>
Light* Elight=e_light-&gt;CreateComponent();<br/>
Elight-&gt;SetLightType(LIGHT_POINT);<br/>
Elight-&gt;SetRange(2);</p>
<pre><code>        if(m_Body-&gt;GetCollidingBodies() != 0)  //or NULL ?
        {
            //there is a collision with another module : do something.
            Elight-&gt;SetBrightness(2.0);
            Elight-&gt;SetColor(Color(1.0,0.5,0.1,1.0));
        }
        else
        {
            //there is no collision, the module can stay here.
            Elight-&gt;SetBrightness(2.0);
            Elight-&gt;SetColor(Color(.0,.0,1.0,1.0));
        }
    }[/code]
</code></pre>
<p>i should see an orange or a blue light if it work at all.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>ok, i just understood that i need to check the somethingEvents.h in the source with the <a data-bbcode="true" href="http://urho3d.github.io/documentation/1.5/_event_list.html" rel="nofollow noopener">documentation</a> to see what’s going on but it’s still confusing to me.</p>
<p>[code]<br/>
SubscribeToEvent(mynode, E_NODECOLLISION, HANDLER(objectevents, HandleObjectCollision)); //for every node that should trigger something on collision</p>
<p>void objectevents::HandleObjectCollision(StringHash eventT, VariantMap&amp; eData)<br/>
{<br/>
RigidBody* body = static_cast&lt;RigidBody*&gt;(eData[P_BODY].GetPtr());[/code]</p>
<p><span class="bbcode-b">mynode</span> ? why are you able to put it in the <span class="bbcode-b">SubscribeToEvent()</span> ?<br/>
can i name <span class="bbcode-b">HandleObjectCollision</span> as i want ?<br/>
and so, <span class="bbcode-b">eData[P_BODY].GetPtr()</span> point to what excatly ?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<aside class="quote no-group" data-username="noals">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/a5e8b4bb38a57a1c8db086db537a8e5d.png" width="20"/> noals:</div>
<blockquote>
<p>ok, i just understood that i need to check the somethingEvents.h in the source with the <a data-bbcode="true" href="http://urho3d.github.io/documentation/1.5/_event_list.html" rel="noopener nofollow ugc">documentation</a> to see what’s going on but it’s still confusing to me.</p>
<pre><code class="lang-auto">SubscribeToEvent(mynode, E_NODECOLLISION, HANDLER(objectevents, HandleObjectCollision)); //for every node that should trigger something on collision

void objectevents::HandleObjectCollision(StringHash eventT, VariantMap&amp; eData)
{
RigidBody* body = static_cast&lt;RigidBody*&gt;(eData[P_BODY].GetPtr());
</code></pre>
<p><span class="bbcode-b">mynode</span> ? why are you able to put it in the <span class="bbcode-b">SubscribeToEvent()</span> ?<br/>
can i name <span class="bbcode-b">HandleObjectCollision</span> as i want ?<br/>
and so, <span class="bbcode-b">eData[P_BODY].GetPtr()</span> point to what excatly ?</p>
</blockquote>
</aside>
<p>first of all, there was some 1.5 changes:</p>
<pre><code class="lang-auto">SubscribeToEvent(mynode, E_NODECOLLISION, HANDLER(objectevents, HandleObjectCollision)); </code></pre>
<p>should be written:</p>
<pre><code class="lang-auto">SubscribeToEvent(mynode, E_NODECOLLISION, URHO3D_HANDLER(objectevents, HandleObjectCollision));</code></pre>
<p><span class="bbcode-b">mynode</span> ? why are you able to put it in the <span class="bbcode-b">SubscribeToEvent()</span> ?</p>
<p>if it has a RigidBody and a CollisionShape, you’ll can set this event on every node you want.</p>
<p>can i name <span class="bbcode-b">HandleObjectCollision</span> as i want ?<br/>
yes (Also different notes to different functions)</p>
<p>and so, <span class="bbcode-b">eData[P_BODY].GetPtr()</span> point to what excatly ?</p>
<p>to the RigidBody of the collision target. (node rbody that get colluded by something)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<pre><code class="lang-auto">URHO3D_EVENT(E_NODECOLLISION, NodeCollision)
{
    URHO3D_PARAM(P_BODY, Body);                    // RigidBody pointer
    URHO3D_PARAM(P_OTHERNODE, OtherNode);          // Node pointer
    URHO3D_PARAM(P_OTHERBODY, OtherBody);          // RigidBody pointer
    URHO3D_PARAM(P_TRIGGER, Trigger);              // bool
    URHO3D_PARAM(P_CONTACTS, Contacts);            // Buffer containing position (Vector3), normal (Vector3), distance (float), impulse (float) for each contact
}</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2367_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">jmiller</div>
          <div class="post_content">
<aside class="quote no-group" data-username="noals">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/a5e8b4bb38a57a1c8db086db537a8e5d.png" width="20"/> noals:</div>
<blockquote>
<pre><code class="lang-auto">SubscribeToEvent(mynode, E_NODECOLLISION, HANDLER(objectevents, HandleObjectCollision)); //for every node that should trigger something on collision
</code></pre>
<p><span class="bbcode-b">mynode</span> ? why are you able to put it in the <span class="bbcode-b">SubscribeToEvent()</span> ?</p>
</blockquote>
</aside>
<p><a data-bbcode="true" href="http://urho3d.github.io/documentation/HEAD/class_urho3_d_1_1_object.html#ac9ea95ee6f24e7fbeede16ba149dbc2d">This class method</a> is described in the docs, events subsection <span class="bbcode-b">Sending events through another object</span><br/>
<a href="http://urho3d.github.io/documentation/HEAD/_events.html#Events_AnotherObject">urho3d.github.io/documentation/H … therObject</a><br/>
<a href="http://urho3d.github.io/documentation/1.5/_events.html#Events_AnotherObject">urho3d.github.io/documentation/1 … therObject</a> (1.5 - same)</p>
<p>I think that section could be clearer by giving an example of the method.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>this <code>SubscribeToEvent(mynode, E_NODECOLLISION, HANDLER(objectevents, HandleObjectCollision))
</code><br/>
is actually : <code>SubscribeToEvent(mynode, P_BODY, P_OTHERNODE, P_OTHERBODY, P_TRIGGER, P_CONTACTS, HANDLER(objectevents, HandleObjectCollision))</code><br/>
and im starting to get the idea but i will need to test things up anyway.</p>
<aside class="quote">
<blockquote>
<p>This class method is described in the docs, events subsection Sending events through another object</p>
</blockquote>
</aside>
<p>yes, that’s what i meant. i wasn’t able to find it in the doc at this time, thx.<br/>
i though we were able to put whatever we wanted in the function somehow.</p>
<p>yeah an exemple would be nice through i will still try the other thing again later as well</p>
<aside class="quote">
<blockquote>
<p>GetCollidingBodies (PODVector&lt; RigidBody * &gt; &amp;result) const</p>
</blockquote>
</aside>
<p>i’m rethinking my whole code now, i need a better organisation.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<p>come home from a party and iam drunk, but have extended the 11_Physics (1.5) sample a little bit…just search for “//itsnew” replace the code and watch in to the log (F1)</p>
<details>
<summary>
11_Physics.h</summary>
<pre><code class="lang-auto">//
// Copyright (c) 2008-2015 the Urho3D project.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#pragma once

#include "Sample.h"

namespace Urho3D
{

class Node;
class Scene;

}
    using namespace NodeCollision; //itsnew
/// Physics example.
/// This sample demonstrates:
///     - Creating both static and moving physics objects to a scene
///     - Displaying physics debug geometry
///     - Using the Skybox component for setting up an unmoving sky
///     - Saving a scene to a file and loading it to restore a previous state
class Physics : public Sample
{
    URHO3D_OBJECT(Physics, Sample);

public:
    /// Construct.
    Physics(Context* context);

    /// Setup after engine initialization and before running the main loop.
    virtual void Start();

protected:
    /// Return XML patch instructions for screen joystick layout for a specific sample app, if any.
    virtual String GetScreenJoystickPatchString() const { return
        "&lt;patch&gt;"
        "    &lt;remove sel=\"/element/element[./attribute[@name='Name' and @value='Button0']]/attribute[@name='Is Visible']\" /&gt;"
        "    &lt;replace sel=\"/element/element[./attribute[@name='Name' and @value='Button0']]/element[./attribute[@name='Name' and @value='Label']]/attribute[@name='Text']/@value\"&gt;Spawn&lt;/replace&gt;"
        "    &lt;add sel=\"/element/element[./attribute[@name='Name' and @value='Button0']]\"&gt;"
        "        &lt;element type=\"Text\"&gt;"
        "            &lt;attribute name=\"Name\" value=\"MouseButtonBinding\" /&gt;"
        "            &lt;attribute name=\"Text\" value=\"LEFT\" /&gt;"
        "        &lt;/element&gt;"
        "    &lt;/add&gt;"
        "    &lt;remove sel=\"/element/element[./attribute[@name='Name' and @value='Button1']]/attribute[@name='Is Visible']\" /&gt;"
        "    &lt;replace sel=\"/element/element[./attribute[@name='Name' and @value='Button1']]/element[./attribute[@name='Name' and @value='Label']]/attribute[@name='Text']/@value\"&gt;Debug&lt;/replace&gt;"
        "    &lt;add sel=\"/element/element[./attribute[@name='Name' and @value='Button1']]\"&gt;"
        "        &lt;element type=\"Text\"&gt;"
        "            &lt;attribute name=\"Name\" value=\"KeyBinding\" /&gt;"
        "            &lt;attribute name=\"Text\" value=\"SPACE\" /&gt;"
        "        &lt;/element&gt;"
        "    &lt;/add&gt;"
        "&lt;/patch&gt;";
    }

private:
    /// Construct the scene content.
    void CreateScene();
    /// Construct an instruction text to the UI.
    void CreateInstructions();
    /// Set up a viewport for displaying the scene.
    void SetupViewport();
    /// Subscribe to application-wide logic update and post-render update events.
    void SubscribeToEvents();
    /// Read input and moves the camera.
    void MoveCamera(float timeStep);
    /// Spawn a physics object from the camera position.
    void SpawnObject();
    /// Handle the logic update event.
    void HandleUpdate(StringHash eventType, VariantMap&amp; eventData);
    /// Handle the post-render update event.
    void HandlePostRenderUpdate(StringHash eventType, VariantMap&amp; eventData);
    void HandleObjectCollision(StringHash eventType, VariantMap&amp; eventData); //itsnew
    /// Flag for drawing debug geometry.
    bool drawDebug_;
};
</code></pre>
</details>
<details>
<summary>
11_Physics.cpp</summary>
<pre><code class="lang-auto">//
// Copyright (c) 2008-2015 the Urho3D project.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#include &lt;Urho3D/Core/CoreEvents.h&gt;
#include &lt;Urho3D/Engine/Engine.h&gt;
#include &lt;Urho3D/Graphics/Camera.h&gt;
#include &lt;Urho3D/Graphics/DebugRenderer.h&gt;
#include &lt;Urho3D/Graphics/Graphics.h&gt;
#include &lt;Urho3D/Graphics/Light.h&gt;
#include &lt;Urho3D/Graphics/Material.h&gt;
#include &lt;Urho3D/Graphics/Model.h&gt;
#include &lt;Urho3D/Graphics/Octree.h&gt;
#include &lt;Urho3D/Graphics/Renderer.h&gt;
#include &lt;Urho3D/Graphics/Skybox.h&gt;
#include &lt;Urho3D/Graphics/Zone.h&gt;
#include &lt;Urho3D/Input/Input.h&gt;
#include &lt;Urho3D/IO/File.h&gt;
#include &lt;Urho3D/IO/FileSystem.h&gt;
#include &lt;Urho3D/Physics/CollisionShape.h&gt;
#include &lt;Urho3D/Physics/PhysicsWorld.h&gt;
#include &lt;Urho3D/Physics/RigidBody.h&gt;
#include &lt;Urho3D/Physics/PhysicsEvents.h&gt; //itsnew
#include &lt;Urho3D/Resource/ResourceCache.h&gt;
#include &lt;Urho3D/Scene/Scene.h&gt;
#include &lt;Urho3D/UI/Font.h&gt;
#include &lt;Urho3D/UI/Text.h&gt;
#include &lt;Urho3D/UI/UI.h&gt;
#include &lt;Urho3D/IO/Log.h&gt; //itsnew
#include "Physics.h"

#include &lt;Urho3D/DebugNew.h&gt;

URHO3D_DEFINE_APPLICATION_MAIN(Physics)


Physics::Physics(Context* context) :
    Sample(context),
    drawDebug_(false)
{
}

void Physics::Start()
{
    // Execute base class startup
    Sample::Start();

    // Create the scene content
    CreateScene();

    // Create the UI content
    CreateInstructions();

    // Setup the viewport for displaying the scene
    SetupViewport();

    // Hook up to the frame update and render post-update events
    SubscribeToEvents();
}

void Physics::CreateScene()
{
    ResourceCache* cache = GetSubsystem&lt;ResourceCache&gt;();

    scene_ = new Scene(context_);

    // Create octree, use default volume (-1000, -1000, -1000) to (1000, 1000, 1000)
    // Create a physics simulation world with default parameters, which will update at 60fps. Like the Octree must
    // exist before creating drawable components, the PhysicsWorld must exist before creating physics components.
    // Finally, create a DebugRenderer component so that we can draw physics debug geometry
    scene_-&gt;CreateComponent&lt;Octree&gt;();
    scene_-&gt;CreateComponent&lt;PhysicsWorld&gt;();
    scene_-&gt;CreateComponent&lt;DebugRenderer&gt;();

    // Create a Zone component for ambient lighting &amp; fog control
    Node* zoneNode = scene_-&gt;CreateChild("Zone");
    Zone* zone = zoneNode-&gt;CreateComponent&lt;Zone&gt;();
    zone-&gt;SetBoundingBox(BoundingBox(-1000.0f, 1000.0f));
    zone-&gt;SetAmbientColor(Color(0.15f, 0.15f, 0.15f));
    zone-&gt;SetFogColor(Color(1.0f, 1.0f, 1.0f));
    zone-&gt;SetFogStart(300.0f);
    zone-&gt;SetFogEnd(500.0f);

    // Create a directional light to the world. Enable cascaded shadows on it
    Node* lightNode = scene_-&gt;CreateChild("DirectionalLight");
    lightNode-&gt;SetDirection(Vector3(0.6f, -1.0f, 0.8f));
    Light* light = lightNode-&gt;CreateComponent&lt;Light&gt;();
    light-&gt;SetLightType(LIGHT_DIRECTIONAL);
    light-&gt;SetCastShadows(true);
    light-&gt;SetShadowBias(BiasParameters(0.00025f, 0.5f));
    // Set cascade splits at 10, 50 and 200 world units, fade shadows out at 80% of maximum shadow distance
    light-&gt;SetShadowCascade(CascadeParameters(10.0f, 50.0f, 200.0f, 0.0f, 0.8f));

    // Create skybox. The Skybox component is used like StaticModel, but it will be always located at the camera, giving the
    // illusion of the box planes being far away. Use just the ordinary Box model and a suitable material, whose shader will
    // generate the necessary 3D texture coordinates for cube mapping
    Node* skyNode = scene_-&gt;CreateChild("Sky");
    skyNode-&gt;SetScale(500.0f); // The scale actually does not matter
    Skybox* skybox = skyNode-&gt;CreateComponent&lt;Skybox&gt;();
    skybox-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
    skybox-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/Skybox.xml"));

    {
        // Create a floor object, 1000 x 1000 world units. Adjust position so that the ground is at zero Y
        Node* floorNode = scene_-&gt;CreateChild("Floor");
        floorNode-&gt;SetPosition(Vector3(0.0f, -0.5f, 0.0f));
        floorNode-&gt;SetScale(Vector3(1000.0f, 1.0f, 1000.0f));
        StaticModel* floorObject = floorNode-&gt;CreateComponent&lt;StaticModel&gt;();
        floorObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
        floorObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/StoneTiled.xml"));

        // Make the floor physical by adding RigidBody and CollisionShape components. The RigidBody's default
        // parameters make the object static (zero mass.) Note that a CollisionShape by itself will not participate
        // in the physics simulation
        /*RigidBody* body = */floorNode-&gt;CreateComponent&lt;RigidBody&gt;();
        CollisionShape* shape = floorNode-&gt;CreateComponent&lt;CollisionShape&gt;();
        // Set a box shape of size 1 x 1 x 1 for collision. The shape will be scaled with the scene node scale, so the
        // rendering and physics representation sizes should match (the box model is also 1 x 1 x 1.)
        shape-&gt;SetBox(Vector3::ONE);
    }

    {
        // Create a pyramid of movable physics objects
        for (int y = 0; y &lt; 8; ++y)
        {
            for (int x = -y; x &lt;= y; ++x)
            {
                int z=0;
                String MyBoxname = "x:" + (String)float(x) + ", y:" + (String)-(float(y + 8.0f))+", z:" + (String)float(z); //itsnew - generate a unique name (starting position)
                Node* boxNode = scene_-&gt;CreateChild(MyBoxname); //itsnew
                boxNode-&gt;SetPosition(Vector3((float)x, -(float)y + 8.0f, 0.0f));
                StaticModel* boxObject = boxNode-&gt;CreateComponent&lt;StaticModel&gt;();
                boxObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
                boxObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/StoneEnvMapSmall.xml"));
                boxObject-&gt;SetCastShadows(true);

                // Create RigidBody and CollisionShape components like above. Give the RigidBody mass to make it movable
                // and also adjust friction. The actual mass is not important; only the mass ratios between colliding
                // objects are significant
                RigidBody* body = boxNode-&gt;CreateComponent&lt;RigidBody&gt;();
                body-&gt;SetMass(1.0f);
                body-&gt;SetFriction(0.75f);
                CollisionShape* shape = boxNode-&gt;CreateComponent&lt;CollisionShape&gt;();
                shape-&gt;SetBox(Vector3::ONE);
                SubscribeToEvent(boxNode, E_NODECOLLISION, URHO3D_HANDLER(Physics, HandleObjectCollision)); //itsnew
            }
        }
    }

    // Create the camera. Set far clip to match the fog. Note: now we actually create the camera node outside the scene, because
    // we want it to be unaffected by scene load / save
    cameraNode_ = new Node(context_);
    Camera* camera = cameraNode_-&gt;CreateComponent&lt;Camera&gt;();
    camera-&gt;SetFarClip(500.0f);

    // Set an initial position for the camera scene node above the floor
    cameraNode_-&gt;SetPosition(Vector3(0.0f, 5.0f, -20.0f));
}

void Physics::CreateInstructions()
{

    ResourceCache* cache = GetSubsystem&lt;ResourceCache&gt;();
    UI* ui = GetSubsystem&lt;UI&gt;();

    // Construct new Text object, set string to display and font to use
    Text* instructionText = ui-&gt;GetRoot()-&gt;CreateChild&lt;Text&gt;();
    instructionText-&gt;SetText(
        "Use WASD keys and mouse/touch to move\n"
        "LMB to spawn physics objects\n"
        "F5 to save scene, F7 to load\n"
        "Space to toggle physics debug geometry"
    );
    instructionText-&gt;SetFont(cache-&gt;GetResource&lt;Font&gt;("Fonts/Anonymous Pro.ttf"), 15);
    // The text has multiple rows. Center them in relation to each other
    instructionText-&gt;SetTextAlignment(HA_CENTER);

    // Position the text relative to the screen center
    instructionText-&gt;SetHorizontalAlignment(HA_CENTER);
    instructionText-&gt;SetVerticalAlignment(VA_CENTER);
    instructionText-&gt;SetPosition(0, ui-&gt;GetRoot()-&gt;GetHeight() / 4);
}

void Physics::SetupViewport()
{
    Renderer* renderer = GetSubsystem&lt;Renderer&gt;();

    // Set up a viewport to the Renderer subsystem so that the 3D scene can be seen
    SharedPtr&lt;Viewport&gt; viewport(new Viewport(context_, scene_, cameraNode_-&gt;GetComponent&lt;Camera&gt;()));
    renderer-&gt;SetViewport(0, viewport);
}

void Physics::SubscribeToEvents()
{
    // Subscribe HandleUpdate() function for processing update events
    SubscribeToEvent(E_UPDATE, URHO3D_HANDLER(Physics, HandleUpdate));

    // Subscribe HandlePostRenderUpdate() function for processing the post-render update event, during which we request
    // debug geometry
    SubscribeToEvent(E_POSTRENDERUPDATE, URHO3D_HANDLER(Physics, HandlePostRenderUpdate));
}

void Physics::MoveCamera(float timeStep)
{
    // Do not move if the UI has a focused element (the console)
    if (GetSubsystem&lt;UI&gt;()-&gt;GetFocusElement())
        return;

    Input* input = GetSubsystem&lt;Input&gt;();

    // Movement speed as world units per second
    const float MOVE_SPEED = 20.0f;
    // Mouse sensitivity as degrees per pixel
    const float MOUSE_SENSITIVITY = 0.1f;

    // Use this frame's mouse motion to adjust camera node yaw and pitch. Clamp the pitch between -90 and 90 degrees
    IntVector2 mouseMove = input-&gt;GetMouseMove();
    yaw_ += MOUSE_SENSITIVITY * mouseMove.x_;
    pitch_ += MOUSE_SENSITIVITY * mouseMove.y_;
    pitch_ = Clamp(pitch_, -90.0f, 90.0f);

    // Construct new orientation for the camera scene node from yaw and pitch. Roll is fixed to zero
    cameraNode_-&gt;SetRotation(Quaternion(pitch_, yaw_, 0.0f));

    // Read WASD keys and move the camera scene node to the corresponding direction if they are pressed
    if (input-&gt;GetKeyDown('W'))
        cameraNode_-&gt;Translate(Vector3::FORWARD * MOVE_SPEED * timeStep);
    if (input-&gt;GetKeyDown('S'))
        cameraNode_-&gt;Translate(Vector3::BACK * MOVE_SPEED * timeStep);
    if (input-&gt;GetKeyDown('A'))
        cameraNode_-&gt;Translate(Vector3::LEFT * MOVE_SPEED * timeStep);
    if (input-&gt;GetKeyDown('D'))
        cameraNode_-&gt;Translate(Vector3::RIGHT * MOVE_SPEED * timeStep);

    // "Shoot" a physics object with left mousebutton
    if (input-&gt;GetMouseButtonPress(MOUSEB_LEFT))
        SpawnObject();

    // Check for loading/saving the scene. Save the scene to the file Data/Scenes/Physics.xml relative to the executable
    // directory
    if (input-&gt;GetKeyPress(KEY_F5))
    {
        File saveFile(context_, GetSubsystem&lt;FileSystem&gt;()-&gt;GetProgramDir() + "Data/Scenes/Physics.xml", FILE_WRITE);
        scene_-&gt;SaveXML(saveFile);
    }
    if (input-&gt;GetKeyPress(KEY_F7))
    {
        File loadFile(context_, GetSubsystem&lt;FileSystem&gt;()-&gt;GetProgramDir() + "Data/Scenes/Physics.xml", FILE_READ);
        scene_-&gt;LoadXML(loadFile);
    }

    // Toggle physics debug geometry with space
    if (input-&gt;GetKeyPress(KEY_SPACE))
        drawDebug_ = !drawDebug_;
}

void Physics::SpawnObject()
{
    ResourceCache* cache = GetSubsystem&lt;ResourceCache&gt;();

    // Create a smaller box at camera position
    Node* boxNode = scene_-&gt;CreateChild("SmallBox");
    boxNode-&gt;SetPosition(cameraNode_-&gt;GetPosition());
    boxNode-&gt;SetRotation(cameraNode_-&gt;GetRotation());
    boxNode-&gt;SetScale(0.25f);
    StaticModel* boxObject = boxNode-&gt;CreateComponent&lt;StaticModel&gt;();
    boxObject-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/Box.mdl"));
    boxObject-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/StoneEnvMapSmall.xml"));
    boxObject-&gt;SetCastShadows(true);

    // Create physics components, use a smaller mass also
    RigidBody* body = boxNode-&gt;CreateComponent&lt;RigidBody&gt;();
    body-&gt;SetMass(0.25f);
    body-&gt;SetFriction(0.75f);
    CollisionShape* shape = boxNode-&gt;CreateComponent&lt;CollisionShape&gt;();
    shape-&gt;SetBox(Vector3::ONE);

    const float OBJECT_VELOCITY = 10.0f;

    // Set initial velocity for the RigidBody based on camera forward vector. Add also a slight up component
    // to overcome gravity better
    body-&gt;SetLinearVelocity(cameraNode_-&gt;GetRotation() * Vector3(0.0f, 0.25f, 1.0f) * OBJECT_VELOCITY);
}

void Physics::HandleUpdate(StringHash eventType, VariantMap&amp; eventData)
{
    using namespace Update;

    // Take the frame time step, which is stored as a float
    float timeStep = eventData[P_TIMESTEP].GetFloat();

    // Move the camera, scale movement with time step
    MoveCamera(timeStep);
}

void Physics::HandlePostRenderUpdate(StringHash eventType, VariantMap&amp; eventData)
{
    // If draw debug mode is enabled, draw physics debug geometry. Use depth test to make the result easier to interpret
    if (drawDebug_)
        scene_-&gt;GetComponent&lt;PhysicsWorld&gt;()-&gt;DrawDebugGeometry(true);
}


//itsnew all now.......


void Physics::HandleObjectCollision(StringHash eventT, VariantMap&amp; eData)
{

RigidBody* body = static_cast&lt;RigidBody*&gt;(eData[P_BODY].GetPtr());
Component* comp;
comp=body-&gt;GetComponent("StaticModel");
Node* myobject;
myobject=comp-&gt;GetNode ();
String nodename=myobject-&gt;GetName();


Node* otherNode = static_cast&lt;Node*&gt;(eData[P_OTHERNODE].GetPtr());
String othernodename=otherNode-&gt;GetName();

URHO3D_LOGRAW("\n nodename: " + nodename + " collude with: " + othernodename);


}
</code></pre>
</details>
<p>its no rockedsience…</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>it took me some time but i rewrited my stuff and i tryed your method to see what it actually does but it doesn’t seem to return anything at all.<br/>
i just got this message in the terminal :</p>
<p>[quote]warning btCollisionDispatcher::needsCollision: static-static collision!<br/>
[/quote]<br/>
i guess i need a static-static collision test but that don’t help me much at this point.<br/>
what should i use ?</p>
<p>the code i tryed :</p>
<pre><code class="lang-auto">        SubscribeToEvent(E_NODECOLLISION, URHO3D_HANDLER(projet, HandleCollisionUpdate)); //collision test  

    void HandleCollisionUpdate(StringHash eventType, VariantMap&amp; eventData)
    {

        RigidBody* body = static_cast&lt;RigidBody*&gt;(eventData[P_BODY].GetPtr());
        Component* comp;
        comp=body-&gt;GetComponent("AnimatedModel");
        Node* myobject;
        myobject=comp-&gt;GetNode ();
        String nodename=myobject-&gt;GetName();


        Node* otherNode = static_cast&lt;Node*&gt;(eventData[P_OTHERNODE].GetPtr());
        String othernodename=otherNode-&gt;GetName();

        URHO3D_LOGRAW("\n nodename: " + nodename + " collide with: " + othernodename);
    }</code></pre>
<p><a data-bbcode="true" href="http://www.hostingpics.net/viewer.php?id=605187collisiontest.png" rel="nofollow noopener"><img alt="" height="" src="../../../images2/270bbf1a8e99979d8720f1f09beccfb4.png" width=""/></a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<p>you dont give the SubscribeToEvent a node.<br/>
SubscribeToEvent(E_NODECOLLISION, URHO3D_HANDLER(projet, HandleCollisionUpdate)); //collision test</p>
<p>but you have set this event to a specific node  that should send this event on a collision (with whatever)</p>
<p>nodes: <a data-bbcode="true" href="http://urho3d.github.io/documentation/1.3/class_urho3_d_1_1_node.html" rel="nofollow noopener">http://urho3d.github.io/documentation/1.3/class_urho3_d_1_1_node.html</a></p>
<p>SubscribeToEvent(<span class="bbcode-b">boxNode</span>, E_NODECOLLISION, URHO3D_HANDLER(Physics, HandleObjectCollision)); //itsnew</p>
<p>this nodes also should have a rigidbody: <a data-bbcode="true" href="http://urho3d.github.io/documentation/1.5/class_urho3_d_1_1_rigid_body.html" rel="nofollow noopener">http://urho3d.github.io/documentation/1.5/class_urho3_d_1_1_rigid_body.html</a><br/>
and a collisionshape: <a data-bbcode="true" href="http://urho3d.github.io/documentation/1.5/class_urho3_d_1_1_collision_shape.html" rel="nofollow noopener">http://urho3d.github.io/documentation/1.5/class_urho3_d_1_1_collision_shape.html</a></p>
<p>AND</p>
<pre><code>void HandleCollisionUpdate(StringHash eventType, VariantMap&amp; eventData)
</code></pre>
<p>normaly it should be wirtten:<br/>
void YOURCLASSNAME::HandleCollisionUpdate(StringHash eventType, VariantMap&amp; eventData)</p>
<p>so</p>
<p>SubscribeToEvent(<span class="bbcode-b">boxNode</span>, E_NODECOLLISION, URHO3D_HANDLER(YOURCLASSNAME, HandleObjectCollision)); //itsnew</p>
<p>can point to the right class and function(void)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>ok, sorry if i’m annoying but be rassured that i am as much or even more annoyed than you could be.<br/>
this shit doesn’t really make sense to me when trying to include it in my code so i will describe what i understand and what i don’t plus my actual problem in hope you will can enlight me.</p>
<p>first of all, i have my urho3D main class that represent my project :</p>
<pre><code class="lang-auto">class projet : public Application
{
    URHO3D_OBJECT(projet, Application)</code></pre>
<p>and within the virtual void Start(), i have the SubscribeToEvent stuff including :</p>
<p><code>
        SubscribeToEvent(E_UPDATE, URHO3D_HANDLER(projet, HandleUpdate));
        SubscribeToEvent(E_POSTRENDERUPDATE,URHO3D_HANDLER(projet,HandlePostRenderUpdate));     
        SubscribeToEvent(E_KEYDOWN, URHO3D_HANDLER(projet, HandleKeyDown));</code><br/>
so no problem here.</p>
<p>then, i have a “Dungeon” class in separates files that use  r_Rooms (for random rooms), r_Cors (for random corridors), r_Juncs (for random junctions) and Module classes to build the dungeon.<br/>
example, the first loaded module :</p>
<pre><code class="lang-auto">Dungeon::Dungeon(int MODULE_MAX, Scene* scene, ResourceCache* cache)
{
   MODULE_COUNT = 0;
   roomJuncSwitch = 0;

   while(MODULE_COUNT&lt;MODULE_MAX)
   {
       if(mainExitList.size()==0)
       {
            room_p = new r_Rooms(); //i start with a room
            module_p = new Module(MODULE_COUNT, room_p-&gt;type, room_p-&gt;std_name, 
                                  room_p-&gt;exits, room_p-&gt;path, room_p-&gt;texturepath,
                                  scene, cache);
            
            for(int x=0;x&lt;module_p-&gt;exitList.size();x++)
            {
                mainExitList.push_back(module_p-&gt;exitList[x]);
            }       

            temp_Body = module_p-&gt;m_Body;  
            MODULE_COUNT++;
        }
        else
        {</code></pre>
<p>each module object have its Node, AnimatedModel, RigidBody and CollisionShape that i can access with the pointer <span class="bbcode-b">module_p-&gt;</span> and that should be this node that is collision tested for each loaded module…<br/>
so i need to put the subscribeToEvent stuff within my class i guess but that’s where i don’t really get it.</p>
<p>if i want to make a fonction within my class, first i declare it as a public member :</p>
<pre><code class="lang-auto"></code></pre>
<p>and then, in the .cpp, i can define what the function does :</p>
<p><code>
void Dungeon::testCollision(Node* whatever)
{
    collisionTest(whatever);
}</code></p>
<p>but here, i guess i should have something like this in my class.h public member :</p>
<pre><code class="lang-auto"></code></pre>
<p>but i also guess it won’t work if it isn’t define in the projet class so i’m not sure how to use it<br/>
and for the function :</p>
<p>[code]void Dungeon(?)::HandleCollisionUpdate(StringHash eventType, VariantMap&amp; eventData)<br/>
{</p>
<pre><code>    RigidBody* body = static_cast&lt;RigidBody*&gt;(eventData[P_BODY].GetPtr());
    Component* comp;
    comp=body-&gt;GetComponent("AnimatedModel");
    Node* myobject;
    myobject=comp-&gt;GetNode ();
    String nodename=myobject-&gt;GetName();[/code]
</code></pre>
<p>i guess i have to put it in my class.cpp somehow but since it’s a function definition, can i put it in the constructor of my class ?<br/>
anyway, i kinda understand a few things but with this method i’m lost, i don’t know where to put what because i don’t need it in the main.cpp and the way the function is defined just confuse me.</p>
<p>you have the main.cpp,  the class.h and the class.cpp.    what do you write in each stuff for an event to work ?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2369_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Dave82</div>
          <div class="post_content">
<p>Thats because you doing it wrong.Are you trying to make a wrapper or i can’t really understand what are you trying to do ? <img alt=":confused:" class="emoji" src="../../../images2/5fc0af8f196734b5bf5c1aacdc718a17.png" title=":confused:"/></p>
<p>You don’t have SubscribeToEvent in your class because its not derived from Urho3D::Object… Here are few advices :</p>
<p>Get rid of these Module , Dungeon and other classes you try to implement.You don’t need them. Urho doesn’t work this way. Follow the rules that the developers <a href="http://provided.In" rel="nofollow noopener">provided.In</a> this case Component based programming.<br/>
Instead of creating a Dungeon and other external classes , you should use Urho3d::Node and add your collision body , AnimatedModel etc components to it. Define a Corridor , and Dungeon components derived from Urho3D::LogicComponent. Now you have a valid Urho Object that can properly subscribed to events , collision checks and network updates.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i use nodes and pointers, in my module class :</p>
<p><span class="bbcode-b">.h</span></p>
<pre><code class="lang-auto">class Module
{
    public:
    Node* m_Node;
    AnimatedModel* m_Object;
    RigidBody* m_Body;
    CollisionShape* m_BBox;
    Node* light;    

    ExitList exitList;

    Module (int m_COUNT, 
            int type, std::string std_name, int exits, String path, String texturepath,
            Scene* scene, ResourceCache* cache);
            
    private:
};</code></pre>
<p><span class="bbcode-b">.cpp</span></p>
<p>[code]<br/>
Module::Module(int m_COUNT,<br/>
int type, std::string std_name, int exits, String path, String texturepath,<br/>
Scene* scene, ResourceCache* cache)<br/>
{</p>
<pre><code>std::string std_sceneName = IntString(m_COUNT, std_name);
String sceneName = string2urhoString(std_sceneName);
//m_Node = new Node();
m_Node = scene-&gt;CreateChild(sceneName);
m_Node-&gt;SetWorldPosition(Vector3::ZERO);   //room.position          
m_Node-&gt;SetWorldRotation(Quaternion::IDENTITY);   //room.rotation (1,0,0,0) 

//m_Object = new AnimatedModel();    
m_Object=m_Node-&gt;CreateComponent&lt;AnimatedModel&gt;();
m_Object-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;(path));
m_Object-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;(texturepath));
</code></pre>
<p>//add physic<br/>
//m_Body = new RigidBody();<br/>
m_Body = m_Node-&gt;CreateComponent();<br/>
m_Body-&gt;SetMass(0);  //0 for static object<br/>
m_Body-&gt;SetFriction(0.6);        // friction with other objects (like the ground)<br/>
m_Body-&gt;SetCollisionLayer(1);<br/>
//add collision shape<br/>
//m_BBox = new CollisionShape();<br/>
m_BBox = m_Node-&gt;CreateComponent();<br/>
m_BBox-&gt;SetTriangleMesh(cache-&gt;GetResource(path));</p>
<p>//etc…[/code]</p>
<p>the Module constructor use infos from the “rooms”, “cors” and “juncs” that return infos from a .xml, like the “path” to load the model.<br/>
i simplified my code so it doesn’t have X time the same function repeated again and again and i needed to separate the code this way because i needed a before rendering step and a while rendering step plus the differentiation of each module type “rooms”, “cors”, etc… so i can chose which one i want.</p>
<p>basicaly, what i had in mind after seeing the GetCollidingBody() function was to make a vector of RigidBody pointer from previously loaded module so i can compare the last loaded module rigidbody with the vector and return true or whatever if there is a collision, but already the GetCollidingBody() is a void function so i don’t know how to use it either. i need to check the source to see what’s going on i think.</p>
<p>few month ago, i wasn’t able to initialize class members properly. now i kinda understand classes but i didn’t learned about derived one yet.<br/>
i guess it’s maybe the time to do that.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2369_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Dave82</div>
          <div class="post_content">
<p>Well i HIGHLY RECOMMEND to look up some c++ tutorials and books and practice few months before you jump into Urho3d… It is completely abstract and relies on polymorphism and other “design standards” that i don’t think it could be understand by trial and error… Once again you don’t need the Module and Corridor and other classes ! It’s not that is unnecessary but it won’t work ! It is absolutely against the whole c++ Urho Component based programming concept. Try it as  i suggested in my previous post.Use Nodes for Modules and create components for Corridors and other stuff… That’s the ONLY way it will ever work.</p>
<p>If you using your own classes which are not derived form Urho3D::Object , it breaks the OOP rules of the engine.You can’t access the Urho context from outside.</p>
<p>But if i were you i would start reading/watching some c++ tutorials first because this way it will take ages to take a leap forward<br/>
Regards</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>well, i ask for a collision test method and i get a whole framework.</p>
<p>you’re telling me the whole urho3D concept is about object, component and the kind.<br/>
in the doc, there is only that kinda :<br/>
<a data-bbcode="true" href="http://urho3d.github.io/documentation/1.4/_object_types.html" rel="nofollow noopener">http://urho3d.github.io/documentation/1.4/_object_types.html</a><br/>
and in the wiki as a “latest activity” :<br/>
<a data-bbcode="true" href="http://urho3d.wikia.com/wiki/Creating_your_own_C%2B%2B_components" rel="nofollow noopener">http://urho3d.wikia.com/wiki/Creating_your_own_C%2B%2B_components</a><br/>
those are not for beginner like me when i check some .cpp in the source as examples, can’t i use bullet or something directly ?</p>
<p>there is no way to actually test if 2 RigidBody are colliding not having to write a whole urho3D object or whatever ?!  <img alt=":angry:" class="emoji" src="../../../images2/dda96664c6d9e61674679e7c70394270.png" title=":angry:"/></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i will try to use bullet directly with its library.</p>
<p>from urho i can get the bullet collision shape</p>
<p><code>btCollisionShape * 	GetCollisionShape () const
 	Return Bullet collision shape. </code></p>
<p>with bullet, i can create a btCollisionObject and assign it the collision shape</p>
<pre><code class="lang-auto"></code></pre>
<p>then i should be able somehow to test the collision with contactTest() or contactPairTest() from bullet<br/>
what annoy me is that it seem i will still need to use simulation steps while it isn’t really needed yet for my need but i will see how it goes anyway.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>well…</p>
<p>i get a Program received signal SIGSEGV, Segmentation fault because of the second line :</p>
<pre><code class="lang-auto">    bt_BBox = m_BBox-&gt;GetCollisionShape();  //urho BBox to bullet BBox (collision shape)
    bt_CollisionObj-&gt;setCollisionShape(bt_BBox); //bullet collision object</code></pre>
<p>and i don’t know what argument is needed to get a PhysicsWorld pointer</p>
<pre><code class="lang-auto">    PhysicsWorld* urhoPhysics = scene-&gt;GetComponent&lt;PhysicsWorld&gt;( ??? );</code></pre>
<p>how come physic in engines is never user friendly ?<br/>
and how come there is no understandable tutorial about urho custom objects and components while it seem to be the base of the engine ?</p>
<p>edit: bah, i guess i will just use bullet as it come and won’t use urho3D physic at all. it will be simplier, i saw i can use .obj from blender to bullet so that should be ok.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2369_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Dave82</div>
          <div class="post_content">
<p>[quote]how come physic in engines is never user friendly ?<br/>
and how come there is no understandable tutorial about urho custom objects and components while it seem to be the base of the engine ?[/quote]</p>
<p>I never saw an engine where using Physics is easier than Urho.<br/>
Object oriented  and component based programming are <span class="bbcode-b">NOT</span> Urho features but c++ and other OOP language features.You can’t expect form anyone here to explain you the basics of c++.<br/>
The tutorials are extremely straightforward and explain the engine usage very well.</p>
<aside class="quote">
<blockquote>
<p>edit: bah, i guess i will just use bullet as it come and won’t use urho3D physic at all. it will be simplier, i saw i can use .obj from blender to bullet so that should be ok.</p>
</blockquote>
</aside>
<p>That’s bad idea ! Don’t use the engine’s lower layer if you’re not a experienced programmer.After few days your code will turn into an unreadable spagetti and no one can help you afterewards.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i would like to try as you say but i don’t really know what i must do exaclty.</p>
<p>when i check <a data-bbcode="true" href="http://www.tutorialspoint.com/cplusplus/cpp_inheritance.htm" rel="nofollow noopener">HERE</a>, it doesn’t seem very hard to me to derive a class (and i kinda understand the custom component thing) but which class must i derive from ?<br/>
must i do some kind of Node, Component, LogicComponent, AnimatedModel ? i’m confused.</p>
<p>and then, that’s when i derive the class that i must add the SubscribeToEvent ? i’m confused by the organisation/hierarchy of it all.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<p>you can look into the characterdemo(or other samples with more than one class) source how to implement a new class as a urho3d logiccomponent. In the characterdemo it is the “Character” class.</p>
<aside class="quote">
<blockquote>
<p>and then, that’s when i derive the class that i must add the SubscribeToEvent ? i’m confused by the organisation/hierarchy of it all.</p>
</blockquote>
</aside>
<p>You dont have to subscribe your event into an diffrent class. You can do it in every class you want. (it only has to be a “urho3d class”)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>ok, now i kinda see what i must do but the how seems more difficult to me.<br/>
from what i understand, i should end up adding the logic component to my module node and so urho should do the collision check for me as long as i can define the component well.<br/>
example :</p>
<pre><code class="lang-auto"></code></pre>
<p>or i could even do a new urho Object for my rooms, corridors, modules, … but it seems even harder.</p>
<p>this is a new level of abstraction to me.<br/>
i’m puzzled by how things are initialized, i need to get into it and try things, i will surely have more questions about it later.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Nerrik</div>
          <div class="post_content">
<aside class="quote">
<blockquote>
<p>from what i understand, i should end up adding the logic component to my module node and so urho should do the collision check for me as long as i can define the component well.</p>
</blockquote>
</aside>
<p>thats right (if you call up the function with the SubscribeToEvent command from your CollisionTester class in the mainclass - one time)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1493_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">TheComet</div>
          <div class="post_content">
<aside class="quote no-group" data-username="noals">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/a5e8b4bb38a57a1c8db086db537a8e5d.png" width="20"/> noals:</div>
<blockquote>
<p>i’m puzzled by how things are initialized, i need to get into it and try things, i will surely have more questions about it later.</p>
</blockquote>
</aside>
<p>During start-up, all components that can be instantiated are registered to the context object. The best way to learn about this mechanism is by writing your own component. Example:</p>
<p>[code]class MyComponent : public Urho3D::Component {<br/>
public:<br/>
MyComponent(Urho3D::Context* context) : Component(context) {}</p>
<pre><code>static void RegisterObject(Urho3D::Context* context)
{
    context-&gt;RegisterFactory&lt;MyComponent&gt;("Custom Component");
}
</code></pre>
<p>};[/code]</p>
<p>If you were to try and execute the following code without registering your component:</p>
<pre><code class="lang-auto">node_ = CreateComponent&lt;MyComponent&gt;();</code></pre>
<p>then Urho3D would not know how to create “MyComponent”. It will return a default component that does nothing instead of instantiating MyComponent (or it might return NULL, I’m not sure any more).</p>
<p>You have to first register your component once:</p>
<p><code>// Do this once
MyComponent::RegisterObject(context_);</code></p>
<p>And now CreateComponent(); will do what you expect it to do.</p>
<p>You can look in Object.h:241 to see how it is implemented.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i have a little question.</p>
<p>i use the Ragdolls sample as example.<br/>
in the CreateRagdoll.cpp:115, there is that :</p>
<p><code>void CreateRagdoll::CreateRagdollBone(const String&amp; boneName, ShapeType type, const Vector3&amp; size, const Vector3&amp; position,
    const Quaternion&amp; rotation)
{
    // Find the correct child scene node recursively
    Node* boneNode = node_-&gt;GetChild(boneName, true);</code><br/>
<span class="bbcode-b">node_</span> is actually the node on which the ragdoll is created right ?<br/>
the same node the custom component is assigned to with :</p>
<p><code>protected:
    /// Handle node being assigned.
    virtual void OnNodeSet(Node* node);</code></p>
<p>i guess it is that but since i don’t see it being initialized, i wonder where it come from.<br/>
this <span class="bbcode-b">node_</span> is a member of what originally ?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">cadaver</div>
          <div class="post_content">
<p>It’s a member of the Component base class, and has been initialized when the component was created to the node.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<aside class="quote">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/17ea6233fe86521c2e3179bd3849d219.png" width="20"/> cadaver:</div>
<blockquote>
<p>It’s a member of the Component base class, and has been initialized when the component was created to the node.</p>
</blockquote>
</aside>
<pre><code class="lang-auto">    /// Scene node.
    Node* node_;
    /// Unique ID within the scene.
    unsigned id_;
    /// Network update queued flag.
    bool networkUpdate_;
    /// Enabled flag.
    bool enabled_;</code></pre>
<p>thx, that’s great.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>the dumb question of the day.</p>
<p>i initialized my component like that :</p>
<pre><code class="lang-auto">        Node* m_Node = my_scene-&gt;CreateChild("Test");
        m_Node-&gt;CreateComponent&lt;Module&gt;();</code></pre>
<p>but then, how do i use component’s functions that are public member ?<br/>
can i make a pointer of a component or something ?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/3_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">cadaver</div>
          <div class="post_content">
<p>To retrieve a component for calling its functions, it’s easiest to use the template overload of GetComponent:</p>
<pre><code class="lang-auto">Module* module = m_Node-&gt;GetComponent&lt;Module&gt;();
module-&gt;MyFunction();</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>ok thx.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>well, i’m at the same point.</p>
<aside class="quote">
<blockquote>
<p>warning btCollisionDispatcher::needsCollision: static-static collision!</p>
</blockquote>
</aside>
<p>why shouldn’t i be able to do some static-static collision check ? did i miss something ?</p>
<pre><code class="lang-auto">//add physic         
    RigidBody* m_Body = node_-&gt;CreateComponent&lt;RigidBody&gt;();
    m_Body-&gt;SetMass(0);  //0 for static object</code></pre>
<p>my component is made like that :</p>
<p>CreateModule.h</p>
<pre><code class="lang-auto">#pragma once

#include &lt;Urho3D/Physics/CollisionShape.h&gt;
#include "ModuleInfos.h"

using namespace Urho3D;

/// Custom component (that creates a ragdoll upon collision.)
class Module : public Component
{
    URHO3D_OBJECT(Module, Component);
    
public:
    /// Construct.
    Module(Context* context);

    //ExitList exitList;
	
    void createRoom(Scene* scene, ResourceCache* cache);
    void createCor(Scene* scene, ResourceCache* cache);
    void createJunc(Scene* scene, ResourceCache* cache);

	
    
protected:
    /// Handle node being assigned.
    virtual void OnNodeSet(Node* node);
    
private:
    /// Handle scene node's physics collision.
    void OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData);
    

//to load different modules type infos
    r_Rooms* room_p;
    r_Cors* cor_p;
    r_Juncs* junc_p;
};</code></pre>
<p>CreateModule.cpp</p>
<pre><code class="lang-auto">
#include &lt;Urho3D/Engine/Application.h&gt;
#include &lt;Urho3D/Engine/Engine.h&gt;
#include &lt;Urho3D/Input/Input.h&gt;
#include &lt;Urho3D/Input/InputEvents.h&gt;
#include &lt;Urho3D/Graphics/Graphics.h&gt;

#include &lt;Urho3D/Resource/ResourceCache.h&gt;
#include &lt;Urho3D/Scene/Scene.h&gt;
#include &lt;Urho3D/Math/Vector3.h&gt;
#include &lt;Urho3D/Math/Quaternion.h&gt;
#include &lt;Urho3D/Graphics/Model.h&gt;
#include &lt;Urho3D/Graphics/AnimatedModel.h&gt;
#include &lt;Urho3D/Graphics/Material.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "fonctions.h"
#include "conversions.h"
#include "Counts.h"
#include "Exit.h"

#include "tinyxml2.h"
#include &lt;Urho3D/IO/Log.h&gt;
#include &lt;Urho3D/DebugNew.h&gt;

//physic
#include &lt;Urho3D/Physics/CollisionShape.h&gt;
//#include &lt;Urho3D/Physics/PhysicsWorld.h&gt;
#include &lt;Urho3D/Physics/RigidBody.h&gt;
#include &lt;Urho3D/Physics/PhysicsEvents.h&gt;


#include "CreateModule.h"
#include "ModuleInfos.h"


using namespace Urho3D;



Module::Module(Context* context) :
    Component(context)
{
}

void Module::createRoom(Scene* scene, ResourceCache* cache)
{
    room_p = new r_Rooms();
	
    std::string std_sceneName = IntString(id_, room_p-&gt;std_name);
    String sceneName = string2urhoString(std_sceneName);

    node_ = scene-&gt;CreateChild(sceneName);
    node_-&gt;SetWorldPosition(Vector3::ZERO);   //room.position          
    node_-&gt;SetWorldRotation(Quaternion::IDENTITY);   //room.rotation (1,0,0,0) 
    
    //m_Object = new AnimatedModel();    
    AnimatedModel* m_Object = node_-&gt;CreateComponent&lt;AnimatedModel&gt;();
    m_Object-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;(room_p-&gt;path));
    m_Object-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;(room_p-&gt;texturepath));
    
//add physic          
    RigidBody* m_Body = node_-&gt;CreateComponent&lt;RigidBody&gt;();
    m_Body-&gt;SetMass(0);  //0 for static object
    m_Body-&gt;SetFriction(0.6);        // friction with other objects (like the ground)
    m_Body-&gt;SetCollisionLayer(1);
//add collision shape
    CollisionShape* m_BBox = node_-&gt;CreateComponent&lt;CollisionShape&gt;();
    m_BBox-&gt;SetTriangleMesh(cache-&gt;GetResource&lt;Model&gt;(room_p-&gt;path));


//add light
    Node* light=node_-&gt;CreateChild("m_light");
    light-&gt;SetPosition(Vector3(0, 5, 0));
    {
        Light* Mlight=light-&gt;CreateComponent&lt;Light&gt;();
        Mlight-&gt;SetLightType(LIGHT_POINT);
        Mlight-&gt;SetRange(20);
        Mlight-&gt;SetBrightness(1.0);
        Mlight-&gt;SetColor(Color(.8,.8,.8,1.0));
    }

}

void Module::createCor(Scene* scene, ResourceCache* cache)
{
   //same thing...
}

void Module::createJunc(Scene* scene, ResourceCache* cache)
{
   //same thing...
}

//protected
void Module::OnNodeSet(Node* node)
{
    // If the node pointer is non-null, this component has been created into a scene node. Subscribe to physics collisions that concern this scene node
    if (node)
    {
        SubscribeToEvent(node, E_NODECOLLISION, URHO3D_HANDLER(Module, OnCollisionEvent)); 
    }
}

//private
void Module::OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData)
{
    using namespace NodeCollision;

    // Get the other colliding body
    RigidBody* otherBody = static_cast&lt;RigidBody*&gt;(eventData[P_OTHERBODY].GetPtr());

    if (otherBody)
    {

        URHO3D_LOGINFO("collide"); 

        // Finally remove self from the scene node. Note that this must be the last operation performed in the function
        //Remove();  ??
    }
}</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Lumak</div>
          <div class="post_content">
<p>[quote=“noals”]well, i’m at the same point.</p>
<aside class="quote">
<blockquote>
<p>warning btCollisionDispatcher::needsCollision: static-static collision!</p>
</blockquote>
</aside>
<p>why shouldn’t i be able to do some static-static collision check ? did i miss something ?<br/>
[/quote]</p>
<p>There shouldn’t be a static-static collision check in Bullet, as you don’t expect static geometries to move.  That is the point of static objects.</p>
<p>If you’re trying to place objects randomly in the scene, what I’d suggest is that you set the mass of &gt; 0 so you can get a collision call back and rely on dynamic-static collision callback.  And once it’s placed properly in the world <span class="bbcode-b">then</span> set the mass back to 0.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i think i misunderstood the warning message :</p>
<aside class="quote">
<blockquote>
<p>warning btCollisionDispatcher::needsCollision: static-static collision!</p>
</blockquote>
</aside>
<p>i fast checked the bullet forum and it seems that the collision actually happen and bullet just warn me that it is a collision between 2 static models. (and that’s what i want here)</p>
<p>but if the collision happens, then i don’t understand urho3D again because this part of code don’t do what i expect it to do :</p>
<pre><code class="lang-auto">
void Module::OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData)
{
    using namespace NodeCollision;

    // Get the other colliding body
    RigidBody* otherBody = static_cast&lt;RigidBody*&gt;(eventData[P_OTHERBODY].GetPtr());

    if (otherBody)
    {
        URHO3D_LOGINFO("collide");
    }
}</code></pre>
<p>it doesn’t show “collide” in my log.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>[quote=“Lumak”][quote=“noals”]well, i’m at the same point.</p>
<aside class="quote">
<blockquote>
<p>warning btCollisionDispatcher::needsCollision: static-static collision!</p>
</blockquote>
</aside>
<p>why shouldn’t i be able to do some static-static collision check ? did i miss something ?<br/>
[/quote]</p>
<p>There shouldn’t be a static-static collision check in Bullet, as you don’t expect static geometries to move.  That is the point of static objects.</p>
<p>If you’re trying to place objects randomly in the scene, what I’d suggest is that you set the mass of &gt; 0 so you can get a collision call back and rely on dynamic-static collision callback.  And once it’s placed properly in the world <span class="bbcode-b">then</span> set the mass back to 0.[/quote]</p>
<p>we posted at the same time. ^^;</p>
<p>i though about this solution while thinking about my problem but you’re right,  i don’t want my module to move. i will check about call back, i’m not familiar with this either.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Lumak</div>
          <div class="post_content">
<p>The warning:<br/>
printf(“warning btCollisionDispatcher::needsCollision: static-static collision!\n”);</p>
<p>is reported in bullet’s code, specifiacally in:<br/>
bool	btCollisionDispatcher::needsCollision(const btCollisionObject* body0,const btCollisionObject* body1) - in btCollisionDispatcher.cpp</p>
<p>And because of it, it never reports back to Urho.  There are two choices to your solution: 1) write static-static collision dispatcher as complained in btCollisionDispatcher.cpp 2) temporarily assign some mass to a placing object.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Lumak</div>
          <div class="post_content">
<p>Ha, you posted your conclusion as I was typing another response.</p>
<p>I think you’re on the right track now. good luck!</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>still doesn’t work, dunno what’s wrong with my code.<br/>
this doesn’t do anything :</p>
<pre><code class="lang-auto">void Module::OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData)
{
    using namespace NodeCollision;
    RigidBody* otherBody = static_cast&lt;RigidBody*&gt;(eventData[P_OTHERBODY].GetPtr());

    if (otherBody-&gt;GetMass() &gt; 0.0f)
    {
        URHO3D_LOGINFO("collide");
        Light* light;
        light = node_-&gt;GetComponent&lt;Light&gt;();
        light-&gt;SetColor(Color(.8,.4,.4,1.0));
    }
}</code></pre>
<p>and i set my RigidBody like that so my modules are non-static but they don’t move either.</p>
<pre><code class="lang-auto">    m_Body-&gt;SetMass(1);  //0 for static object
	m_Body-&gt;SetUseGravity(false);
	m_Body-&gt;SetTrigger(true);	 //In trigger mode collisions are reported but do not apply forces. </code></pre>
<p>and my component is registered in my main.cpp</p>
<pre><code class="lang-auto">    projet(Context* context) : Application(context)
    {
        context-&gt;RegisterFactory&lt;Module&gt;();
    }</code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>the component doesn’t even work at all.</p>
<pre><code class="lang-auto">void Module::OnNodeSet(Node* node)
{
    // If the node pointer is non-null, this component has been created into a scene node. Subscribe to physics collisions that concern this scene node
    if (node)
    {
        SubscribeToEvent(node, E_NODECOLLISIONSTART, URHO3D_HANDLER(Module, OnCollisionEvent));
        URHO3D_LOGINFO("node set");
    }
}</code></pre>
<p>this actually return me “node set” in the log but that’s all this fucking component can do !<br/>
in my main.cpp, if i try to move the node with the component on it with SetWorldPosition(), nothing move at all.</p>
<p>i’m losing my time with this shit.  <img alt=":imp:" class="emoji" src="../../../images2/d92a6cee49a31cd20cb8144794305762.png" title=":imp:"/><br/>
how da fuck do this shit work really ?!</p>
<p>main</p>
<p>[spoiler][code]//engine<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/Application.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/Engine.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Input/Input.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Input/InputEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Graphics.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Resource/ResourceCache.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/Scene.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/SceneEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Octree.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/DebugRenderer.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Camera.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Viewport.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Renderer.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Graphics/Model.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/StaticModel.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/AnimatedModel.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Material.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Graphics/Light.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Core/CoreEvents.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Math/Vector3.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/UI/Window.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Text.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/Font.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/UI/UI.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/Log.h&gt;</p>
<p>//my class<br/>
<span class="hashtag">#include</span> “CreateModule.<code></code>h”<br/>
<span class="hashtag">#include</span> “Exit.h”<br/>
<span class="hashtag">#include</span> “Counts.h”</p>
<p>//include<br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> </p>
<p>//physic<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/PhysicsWorld.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/PhysicsEvents.h&gt;</p>
<p>using namespace Urho3D;</p>
<p>class projet : public Application<br/>
{<br/>
URHO3D_OBJECT(projet, Application)</p>
<p>public:</p>
<p>////______________________<br/>
////    DEFINITION</p>
<pre><code>SharedPtr&lt;Scene&gt; my_scene;

//about camera
SharedPtr&lt;Node&gt; camNode;

//physic
bool drawDebug_;

//about text
Window* window;
Text* text;

projet(Context* context) : Application(context)
{
</code></pre>
<p>// Register an object factory for our custom CreateRagdoll component so that we can create them to scene nodes<br/>
context-&gt;RegisterFactory();<br/>
//context-&gt;RegisterFactory();<br/>
}</p>
<pre><code>virtual void Setup()
{
    engineParameters_["FullScreen"]=false;
    engineParameters_["WindowWidth"]=1280;
    engineParameters_["WindowHeight"]=720;
    engineParameters_["WindowResizable"]=true;
}

virtual void Start()
{

    ResourceCache* cache=GetSubsystem&lt;ResourceCache&gt;();

    my_scene=new Scene(context_);
    my_scene-&gt;CreateComponent&lt;Octree&gt;();
    my_scene-&gt;CreateComponent&lt;DebugRenderer&gt;();
</code></pre>
<p>//physic</p>
<pre><code>    my_scene-&gt;CreateComponent&lt;PhysicsWorld&gt;(); 
</code></pre>
<p>////___________________<br/>
////    MODULES</p>
<pre><code>    //Dungeon dungeon(100, my_scene, cache);
    
    Node* m_Node = my_scene-&gt;CreateChild("Test");
    m_Node-&gt;CreateComponent&lt;Module&gt;();
    Module* m_comp = m_Node-&gt;GetComponent&lt;Module&gt;();
    m_comp-&gt;createRoom(my_scene, cache);

    Node* m_Node2 = my_scene-&gt;CreateChild("Test2");
    m_Node2-&gt;CreateComponent&lt;Module&gt;();
    Module* m_comp2 = m_Node2-&gt;GetComponent&lt;Module&gt;();
    m_comp2-&gt;createCor(my_scene, cache);
    m_comp2-&gt;SetWorldPosition(Vector3(0,2,0)); //i tryed with the node as well
    


    URHO3D_LOGINFO("test_main"); 
</code></pre>
<p>////__________________<br/>
////    CAMERA</p>
<p>using namespace Urho3D;<br/>
camNode=my_scene-&gt;CreateChild(“camNode”);<br/>
Camera* camObject=camNode-&gt;CreateComponent();<br/>
camObject-&gt;SetFarClip(2000);<br/>
camNode-&gt;SetWorldPosition(Vector3(0,20,-20));     //x =blender y //y =blender z hauteur //z =blender x profondeur<br/>
camNode-&gt;LookAt(Vector3::ZERO);</p>
<pre><code>    //camera light
    {
        Light* light=camNode-&gt;CreateComponent&lt;Light&gt;();
        light-&gt;SetLightType(LIGHT_POINT);
        light-&gt;SetRange(25);
        light-&gt;SetBrightness(2.0);
        light-&gt;SetColor(Color(.8,1,.8,1.0));
    }
</code></pre>
<p>////________________<br/>
////    TEXT</p>
<pre><code>    std::string str = (""); 
    {
        std::ostringstream ss;
        ss;
          //&lt;&lt;" module count = "&lt;&lt;dungeon.MODULE_COUNT
          //&lt;&lt;"\n free exit = "&lt;&lt;dungeon.mainExitList.size();

        std::string s(ss.str());
        str.append(s/*.substr(0,60)*/);
    }
    String s(str.c_str(),str.size());

    window=new Window(context_);
    GetSubsystem&lt;UI&gt;()-&gt;GetRoot()-&gt;AddChild(window);
    window-&gt;SetStyle("Window");
    window-&gt;SetSize(500,200);
    window-&gt;SetColor(Color(.0,.15,.3,.5));
    window-&gt;SetAlignment(HA_LEFT,VA_TOP);

    text=new Text(context_);
    text-&gt;SetFont(cache-&gt;GetResource&lt;Font&gt;("Fonts/Anonymous Pro.ttf"),14);
    text-&gt;SetColor(Color(.8,.85,.9));
    text-&gt;SetAlignment(HA_LEFT,VA_TOP);
    text-&gt;SetText(s); //s
    window-&gt;AddChild(text);
</code></pre>
<p>////__________________<br/>
////    RENDER</p>
<pre><code>    Renderer* renderer=GetSubsystem&lt;Renderer&gt;();
    SharedPtr&lt;Viewport&gt; viewport(new Viewport(context_,my_scene,camNode-&gt;GetComponent&lt;Camera&gt;()));
    renderer-&gt;SetViewport(0,viewport);
</code></pre>
<p>////__________________<br/>
////    EVENTS</p>
<pre><code>//SubscribeToEvent(E_BEGINFRAME,URHO3D_HANDLER(projet,HandleBeginFrame));
//SubscribeToEvent(E_KEYDOWN,URHO3D_HANDLER(projet,HandleKeyDown));
//SubscribeToEvent(E_UIMOUSECLICK,URHO3D_HANDLER(projet,HandleControlClicked));
    SubscribeToEvent(E_UPDATE, URHO3D_HANDLER(projet, HandleUpdate));

//SubscribeToEvent(E_POSTUPDATE,URHO3D_HANDLER(projet,HandlePostUpdate));
//SubscribeToEvent(E_RENDERUPDATE,URHO3D_HANDLER(projet,HandleRenderUpdate));
    SubscribeToEvent(E_POSTRENDERUPDATE,URHO3D_HANDLER(projet,HandlePostRenderUpdate));     
//SubscribeToEvent(E_ENDFRAME,URHO3D_HANDLER(projet,HandleEndFrame));
    SubscribeToEvent(E_KEYDOWN, URHO3D_HANDLER(projet, HandleKeyDown));


}

virtual void Stop()
{
}
</code></pre>
<p>////________</p>
<pre><code>void HandleUpdate(StringHash eventType,VariantMap&amp; eventData)
{
    float timeStep=eventData[Update::P_TIMESTEP].GetFloat();
float MOVE_SPEED=50.0f;
    Input* input=GetSubsystem&lt;Input&gt;();

if(input-&gt;GetQualifierDown(1))  // 1 is shift, 2 is ctrl, 4 is alt
        MOVE_SPEED*=4;

    if(input-&gt;GetKeyDown('D')) //rotate sens inverse horizontal
        camNode-&gt;Translate(Vector3(1,0, 0)*MOVE_SPEED*timeStep);
    if(input-&gt;GetKeyDown('Q')) //sens montre horizontal
        camNode-&gt;Translate(Vector3(-1,0,0)*MOVE_SPEED*timeStep);
    if(input-&gt;GetKeyDown('Z')) //zoom avant
        camNode-&gt;Translate(Vector3(0,0,1)*MOVE_SPEED*timeStep);
    if(input-&gt;GetKeyDown('S')) //zoom arriere
        camNode-&gt;Translate(Vector3(0,0,-1)*MOVE_SPEED*timeStep);
if(input-&gt;GetKeyDown('E')) //rotate sens inverse vertical
        camNode-&gt;Translate(Vector3(0,1,0)*MOVE_SPEED*timeStep);
    if(input-&gt;GetKeyDown('A')) //sens montre vertical
        camNode-&gt;Translate(Vector3(0,-1,0)*MOVE_SPEED*timeStep);
    if (input-&gt;GetKeyPress(KEY_SPACE)) // Toggle physics debug geometry with space
        drawDebug_ = !drawDebug_;

if(!GetSubsystem&lt;Input&gt;()-&gt;IsMouseGrabbed())
{
    IntVector2 mouseMove=input-&gt;GetMouseMove();
    
    if(mouseMove.x_&gt;-2000000000&amp;&amp;mouseMove.y_&gt;-2000000000)
        {
	camNode-&gt;LookAt(Vector3::ZERO); //look at 0,0,0
        }
}
        


}
</code></pre>
<p>////_______</p>
<p>////________</p>
<pre><code>void HandlePostRenderUpdate(StringHash eventType, VariantMap&amp; eventData)
{
// If draw debug mode is enabled, draw physics debug geometry. Use depth test to make the result easier to interpret
    if (drawDebug_)
        my_scene-&gt;GetComponent&lt;PhysicsWorld&gt;()-&gt;DrawDebugGeometry(true);
}
</code></pre>
<p>////________</p>
<pre><code>void HandleKeyDown(StringHash eventType, VariantMap&amp; eventData)
{
    using namespace KeyDown;

    Graphics* graphics=GetSubsystem&lt;Graphics&gt;();
    int key = eventData[P_KEY].GetInt();

    if (key == KEY_ESC) //ESC to quit
    {
        engine_-&gt;Exit();
    }
    else if(key == KEY_TAB) //TAB to toggle mouse cursor
    {
        GetSubsystem&lt;Input&gt;()-&gt;SetMouseVisible(!GetSubsystem&lt;Input&gt;()-&gt;IsMouseVisible());
        GetSubsystem&lt;Input&gt;()-&gt;SetMouseGrabbed(!GetSubsystem&lt;Input&gt;()-&gt;IsMouseGrabbed()); 
    }
else if(key == 'W') //W for fullscreen
{
    graphics-&gt;ToggleFullscreen();
}
    else if(key == 'I')
    {
        //GetSubsystem&lt;UI&gt;()-&gt;menu-&gt;ShowPopup ();
    }
}
</code></pre>
<p>////________</p>
<p>};<br/>
URHO3D_DEFINE_APPLICATION_MAIN(projet)<br/>
[/code][/spoiler]</p>
<p>comp.h</p>
<p>[spoiler][code]//<br/>
// Copyright © 2008-2015 the Urho3D project.<br/>
//<br/>
// Permission is hereby granted, free of charge, to any person obtaining a copy<br/>
// of this software and associated documentation files (the “Software”), to deal<br/>
// in the Software without restriction, including without limitation the rights<br/>
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br/>
// copies of the Software, and to permit persons to whom the Software is<br/>
// furnished to do so, subject to the following conditions:<br/>
//<br/>
// The above copyright notice and this permission notice shall be included in<br/>
// all copies or substantial portions of the Software.<br/>
//<br/>
// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br/>
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br/>
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br/>
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br/>
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br/>
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br/>
// THE SOFTWARE.<br/>
//</p>
<p><span class="hashtag">#pragma</span> once</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Physics/CollisionShape.h&gt;<br/>
<span class="hashtag">#include</span> “ModuleInfos.h”</p>
<p>using namespace Urho3D;</p>
<p>/// Custom component (that creates a ragdoll upon collision.)<br/>
class Module : public Component<br/>
{<br/>
URHO3D_OBJECT(Module, Component);</p>
<p>public:<br/>
/// Construct.<br/>
Module(Context* context);</p>
<pre><code>void createRoom(Scene* scene, ResourceCache* cache);
void createCor(Scene* scene, ResourceCache* cache);
void createJunc(Scene* scene, ResourceCache* cache);

int type;
int exits;
</code></pre>
<p>protected:<br/>
/// Handle node being assigned.<br/>
virtual void OnNodeSet(Node* node);</p>
<p>private:<br/>
/// Handle scene node’s physics collision.<br/>
void OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData);</p>
<p>/*<br/>
/// Make a bone physical by adding RigidBody and CollisionShape components.<br/>
void CreateRagdollBone(const String&amp; boneName, ShapeType type, const Vector3&amp; size, const Vector3&amp; position, const Quaternion&amp; rotation);<br/>
/// Join two bones with a Constraint component.<br/>
void CreateRagdollConstraint(const String&amp; boneName, const String&amp; parentName, ConstraintType type, const Vector3&amp; axis, const Vector3&amp; parentAxis, const Vector2&amp; highLimit, const Vector2&amp; lowLimit, bool disableCollision = true);<br/>
*/</p>
<p>//to load different modules type infos<br/>
r_Rooms* room_p;<br/>
r_Cors* cor_p;<br/>
r_Juncs* junc_p;<br/>
};[/code][/spoiler]</p>
<p>comp.cpp</p>
<p>[spoiler][code]//<br/>
// Copyright © 2008-2015 the Urho3D project.<br/>
//<br/>
// Permission is hereby granted, free of charge, to any person obtaining a copy<br/>
// of this software and associated documentation files (the “Software”), to deal<br/>
// in the Software without restriction, including without limitation the rights<br/>
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br/>
// copies of the Software, and to permit persons to whom the Software is<br/>
// furnished to do so, subject to the following conditions:<br/>
//<br/>
// The above copyright notice and this permission notice shall be included in<br/>
// all copies or substantial portions of the Software.<br/>
//<br/>
// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br/>
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br/>
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br/>
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br/>
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br/>
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br/>
// THE SOFTWARE.<br/>
//<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/Application.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Engine/Engine.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Input/Input.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Input/InputEvents.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Graphics.h&gt;</p>
<p><span class="hashtag">#include</span> &lt;Urho3D/Resource/ResourceCache.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Scene/Scene.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Vector3.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Math/Quaternion.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Model.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/AnimatedModel.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Graphics/Material.h&gt;<br/>
<span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> </p>
<p><span class="hashtag">#include</span> “fonctions.h”<br/>
<span class="hashtag">#include</span> “conversions.h”<br/>
<span class="hashtag">#include</span> “Counts.h”<br/>
<span class="hashtag">#include</span> “Exit.h”</p>
<p><span class="hashtag">#include</span> “tinyxml2.h”<br/>
<span class="hashtag">#include</span> &lt;Urho3D/IO/Log.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/DebugNew.h&gt;</p>
<p>//physic<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/CollisionShape.h&gt;<br/>
//<span class="hashtag">#include</span> &lt;Urho3D/Physics/PhysicsWorld.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/RigidBody.h&gt;<br/>
<span class="hashtag">#include</span> &lt;Urho3D/Physics/PhysicsEvents.h&gt;</p>
<p><span class="hashtag">#include</span> “CreateModule.h”<br/>
<span class="hashtag">#include</span> “ModuleInfos.h”<br/>
//<span class="hashtag">#include</span> “CreateExit.h”</p>
<p>using namespace Urho3D;</p>
<p>Module::Module(Context* context) :<br/>
Component(context),<br/>
type(0),<br/>
exits(0)<br/>
{<br/>
//context-&gt;RegisterFactory();<br/>
}</p>
<p>void Module::createRoom(Scene* scene, ResourceCache* cache)<br/>
{<br/>
room_p = new r_Rooms();<br/>
type = 0;<br/>
exits = room_p-&gt;exits;</p>
<pre><code>std::string std_sceneName = IntString(id_, room_p-&gt;std_name);
String sceneName = string2urhoString(std_sceneName);

node_ = scene-&gt;CreateChild(sceneName);
node_-&gt;SetWorldPosition(Vector3::ZERO);   //room.position          
node_-&gt;SetWorldRotation(Quaternion::IDENTITY);   //room.rotation (1,0,0,0) 

//m_Object = new AnimatedModel();    
AnimatedModel* m_Object = node_-&gt;CreateComponent&lt;AnimatedModel&gt;();
m_Object-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;(room_p-&gt;path));
m_Object-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;(room_p-&gt;texturepath));
</code></pre>
<p>//add physic<br/>
RigidBody* m_Body = node_-&gt;CreateComponent();<br/>
m_Body-&gt;SetMass(1);  //0 for static object<br/>
m_Body-&gt;SetUseGravity(false);<br/>
m_Body-&gt;SetTrigger(true);<br/>
m_Body-&gt;SetFriction(0.6);        // friction with other objects (like the ground)<br/>
m_Body-&gt;SetCollisionLayer(1);</p>
<p>//add collision shape<br/>
CollisionShape* m_BBox = node_-&gt;CreateComponent();<br/>
m_BBox-&gt;SetTriangleMesh(cache-&gt;GetResource(room_p-&gt;path));</p>
<p>//add light<br/>
Node* light=node_-&gt;CreateChild(“m_light”);<br/>
light-&gt;SetPosition(Vector3(0, 5, 0));<br/>
{<br/>
Light* Mlight=light-&gt;CreateComponent();<br/>
Mlight-&gt;SetLightType(LIGHT_POINT);<br/>
Mlight-&gt;SetRange(20);<br/>
Mlight-&gt;SetBrightness(1.0);<br/>
Mlight-&gt;SetColor(Color(.8,.8,.8,1.0));<br/>
}<br/>
/*<br/>
for(int x=0; x&lt;exits; x++)<br/>
{</p>
<pre><code>	std::string std_exitName = stringInt("exit",x);
    String name = string2urhoString(std_exitName);
	
    Node* exitNode = node_-&gt;GetChild(name, true);
	exitNode-&gt;CreateComponent&lt;Exit&gt;();
	
	
	//make a vector there ?
	
	Exit* tempExit = exitNode-&gt;GetComponent&lt;Exit&gt;();
	tempExit-&gt;type = 0;

	
	
	exit.type=room_p-&gt;type;
    exit.position = exit.e_Node-&gt;GetWorldPosition();
    exit.module_pos = Vector3::ZERO;
    exitList.push_back(exit);            
}
*/
</code></pre>
<p>}</p>
<p>void Module::createCor(Scene* scene, ResourceCache* cache)<br/>
{<br/>
cor_p = new r_Cors();<br/>
type = 1;<br/>
exits = cor_p-&gt;exits;</p>
<pre><code>std::string std_sceneName = IntString(id_, cor_p-&gt;std_name);
String sceneName = string2urhoString(std_sceneName);

node_ = scene-&gt;CreateChild(sceneName);
node_-&gt;SetWorldPosition(Vector3::ZERO);   //room.position          
node_-&gt;SetWorldRotation(Quaternion::IDENTITY);   //room.rotation (1,0,0,0) 

//m_Object = new AnimatedModel();    
AnimatedModel* m_Object = node_-&gt;CreateComponent&lt;AnimatedModel&gt;();
m_Object-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;(cor_p-&gt;path));
m_Object-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;(cor_p-&gt;texturepath));
</code></pre>
<p>//add physic<br/>
RigidBody* m_Body = node_-&gt;CreateComponent();<br/>
m_Body-&gt;SetMass(1);  //0 for static object<br/>
m_Body-&gt;SetUseGravity(false);<br/>
m_Body-&gt;SetTrigger(true);<br/>
m_Body-&gt;SetFriction(0.6);        // friction with other objects (like the ground)<br/>
m_Body-&gt;SetCollisionLayer(1);</p>
<p>//add collision shape<br/>
CollisionShape* m_BBox = node_-&gt;CreateComponent();<br/>
m_BBox-&gt;SetTriangleMesh(cache-&gt;GetResource(cor_p-&gt;path));</p>
<p>//add light<br/>
Node* light=node_-&gt;CreateChild(“m_light”);<br/>
light-&gt;SetPosition(Vector3(0, 5, 0));<br/>
{<br/>
Light* Mlight=light-&gt;CreateComponent();<br/>
Mlight-&gt;SetLightType(LIGHT_POINT);<br/>
Mlight-&gt;SetRange(20);<br/>
Mlight-&gt;SetBrightness(1.0);<br/>
Mlight-&gt;SetColor(Color(.8,.8,.8,1.0));<br/>
}<br/>
/*<br/>
for(int x=0; x&lt;cor_p-&gt;exits; x++)<br/>
{<br/>
Exit tempExit;</p>
<pre><code>    std::string std_exitName = stringInt("exit",x);
    exit.name = string2urhoString(std_exitName);
    exit.type=cor_p-&gt;type;
    exit.e_Node = node_-&gt;GetChild(exit.name, true);
    exit.position = exit.e_Node-&gt;GetWorldPosition();
    exit.module_pos = Vector3::ZERO;
    exitList.push_back(exit);            
}*/
</code></pre>
<p>}</p>
<p>void Module::createJunc(Scene* scene, ResourceCache* cache)<br/>
{<br/>
junc_p = new r_Juncs();<br/>
type = 2;<br/>
exits = junc_p-&gt;exits;</p>
<pre><code>std::string std_sceneName = IntString(id_, junc_p-&gt;std_name);
String sceneName = string2urhoString(std_sceneName);

node_ = scene-&gt;CreateChild(sceneName);
node_-&gt;SetWorldPosition(Vector3::ZERO);   //room.position          
node_-&gt;SetWorldRotation(Quaternion::IDENTITY);   //room.rotation (1,0,0,0) 

//m_Object = new AnimatedModel();    
AnimatedModel* m_Object = node_-&gt;CreateComponent&lt;AnimatedModel&gt;();
m_Object-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;(junc_p-&gt;path));
m_Object-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;(junc_p-&gt;texturepath));
</code></pre>
<p>//add physic<br/>
RigidBody* m_Body = node_-&gt;CreateComponent();<br/>
m_Body-&gt;SetMass(1);  //0 for static object<br/>
m_Body-&gt;SetUseGravity(false);<br/>
m_Body-&gt;SetTrigger(true);<br/>
m_Body-&gt;SetFriction(0.6);        // friction with other objects (like the ground)<br/>
m_Body-&gt;SetCollisionLayer(1);</p>
<p>//add collision shape<br/>
CollisionShape* m_BBox = node_-&gt;CreateComponent();<br/>
m_BBox-&gt;SetTriangleMesh(cache-&gt;GetResource(junc_p-&gt;path));</p>
<p>//add light<br/>
Node* light=node_-&gt;CreateChild(“m_light”);<br/>
light-&gt;SetPosition(Vector3(0, 5, 0));<br/>
{<br/>
Light* Mlight=light-&gt;CreateComponent();<br/>
Mlight-&gt;SetLightType(LIGHT_POINT);<br/>
Mlight-&gt;SetRange(20);<br/>
Mlight-&gt;SetBrightness(1.0);<br/>
Mlight-&gt;SetColor(Color(.8,.8,.8,1.0));<br/>
}<br/>
/*<br/>
for(int x=0; x&lt;junc_p-&gt;exits; x++)<br/>
{<br/>
Exit tempExit;</p>
<pre><code>    std::string std_exitName = stringInt("exit",x);
    exit.name = string2urhoString(std_exitName);
    exit.type=junc_p-&gt;type;
    exit.e_Node = node_-&gt;GetChild(exit.name, true);
    exit.position = exit.e_Node-&gt;GetWorldPosition();
    exit.module_pos = Vector3::ZERO;
    exitList.push_back(exit);            
}*/
</code></pre>
<p>}</p>
<p>//protected<br/>
void Module::OnNodeSet(Node* node)<br/>
{<br/>
// If the node pointer is non-null, this component has been created into a scene node. Subscribe to physics collisions that concern this scene node<br/>
if (node)<br/>
{<br/>
SubscribeToEvent(node, E_NODECOLLISIONSTART, URHO3D_HANDLER(Module, OnCollisionEvent));<br/>
URHO3D_LOGINFO(“node set”);<br/>
}<br/>
}</p>
<p>//private<br/>
void Module::OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData)<br/>
{<br/>
using namespace NodeCollision;</p>
<pre><code>// Get the other colliding body
RigidBody* otherBody = static_cast&lt;RigidBody*&gt;(eventData[P_OTHERBODY].GetPtr());

//Node* otherNode = static_cast&lt;Node*&gt;(eventData[P_OTHERNODE].GetPtr());

if (otherBody-&gt;GetMass() &gt; 0.0f)
{

    URHO3D_LOGINFO("collide");
    Light* light;
    light = node_-&gt;GetComponent&lt;Light&gt;();
    light-&gt;SetColor(Color(.8,.4,.4,1.0));

//m_Body-&gt;SetMass(1);  //0 for static object
//m_Body-&gt;SetUseGravity(false);
//m_Body-&gt;SetTrigger(true);		
	
    // Finally remove self from the scene node. Note that this must be the last operation performed in the function
    //Remove();  
}
</code></pre>
<p>}[/code][/spoiler]</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i will try with a logic component.</p>
<p>edit: or not, because i shouldn’t need real time to set my module’s position at the beginning of my app.</p>
<p>dunno what to do.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Lumak</div>
          <div class="post_content">
<p>Alright, there are a couple of things you can try.<br/>
First, remove setting up the body as a trigger, i.e. m_Body-&gt;SetTrigger(true); &lt;-- comment this out.<br/>
Second, there are other collision events you can register for.  Try these: E_PHYSICSCOLLISION, E_NODECOLLISION.<span class="bbcode-b">E_PHYSICSCOLLISION</span> event is ongoing, meaning that as long as there is a collision occurring you’ll get an event callbck - it doesn’t stop with just an initial collision call like E_NODECOLLISIONSTART.<br/>
Third, remove any conditionals in your OnCollisionEvent() function and just log what’s coming in.<br/>
Lastly, I highly recommend working with Urho3D/Samples for starters.  Add bits of your code to test just to learn how things work. It might end up saving you weeks of trouble.</p>
<p>Good luck!</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>what about the component update ?<br/>
all this is pointless if my component doesn’t even follow the node it is attached to.<br/>
the advantage for me with this component thing is that i can move it and rotate it using the node.</p>
<p>really, there should be templates examples for component, logic component, object with their essential requirements. (or not essential as a plus, for common usages, but commented as such !)<br/>
here instead of 3 clear examples, i have to deal with 41 of them kinda…</p>
<aside class="quote">
<blockquote>
<p>First, remove setting up the body as a trigger, i.e. m_Body-&gt;SetTrigger(true); &lt;-- comment this out.</p>
</blockquote>
</aside>
<p>why ?<br/>
i want my module as static in the physic world but i need them as non-static to test collision so i set them with :</p>
<p>[quote]SetUseGravity (bool enable)<br/>
Set whether gravity is applied to rigid body. [/quote]<br/>
and</p>
<p>[quote]SetTrigger (bool enable)<br/>
Set rigid body trigger mode. In trigger mode collisions are reported but do not apply forces. [/quote]<br/>
and when the collision check is done, i can make them static again and disable the trigger mode so the physic doesn’t mess up with my modules’s position when i’m placing them.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/{size}.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Lumak</div>
          <div class="post_content">
<p>You’ll get a better understanding of Urho3D physic, components, and callbacks by looking at 11_Physics demo.</p>
<p>Try adding a subscription to E_NODECOLLISIONSTART and see how that works.  Then try PHYSICSCOLLISION.  Then try setting SetTrigger() and see what happens.</p>
<p>If you can observe those behaviors, my bet is you can fix what’s wrong with yours.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/2369_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">Dave82</div>
          <div class="post_content">
<p>[quote]what about the component update ?<br/>
all this is pointless if my component doesn’t even follow the node it is attached to.<br/>
the advantage for me with this component thing is that i can move it and rotate it using the node.[/quote]</p>
<p>Components doesn’t have transforms , nodes do ! How do you expect your Module component to move in 3d space ? It’s not a transformable entity it is just a component ! you expect to move based on what exacly ?</p>
<p>[quote]i’m losing my time with this shit.<br/>
how da fuck do this shit work really ?![/quote]</p>
<p>Well, how about learning the basics first as i previously suggested ? I think Urho3d’s structure is extremely well designed and could be understand in no time if you first learn c++ and Component based programming.<br/>
If you stuck with trivial things like how to add components to nodes , imagine how confusing it will be once you get into game logic programming and other nasty stuff which requires good understanding of c++ ?</p>
<p>[quote]this actually return me “node set” in the log but that’s all this fucking component can do !<br/>
in my main.cpp, if i try to move the node with the component on it with SetWorldPosition(), nothing move at all.[/quote]</p>
<p>The code you posted doesn’t make sense to me at all. How about using Nodes for modules.Create one component called (lets say) <a href="http://Element.In" rel="nofollow noopener">Element.In</a> this Element component’s Start() function add you necessary urho components AnimatedModel , Light , RigidBody etc. If you need extra parameters and functions just implement it to Element component. You can override Update() or FixedUpdate() etc in your Element and do per frame updates there. Other things i want to point out is :<br/>
your code is so overcomplicated for such a simple task you want to <a href="http://achive.By" rel="nofollow noopener">achive.By</a> simplifying the code i can garantee you could get the same effect with only 10-15 lines of code…</p>
<pre><code class="lang-auto"></code></pre>
<p>Your module is a <a href="http://component.It" rel="nofollow noopener">component.It</a> is unnecessary to pass the cache and scene pointers because those are already part of your Component.Use GetScene() anywehre in you Module to get the scene and use GetSubsystem<a>Urho3D::Cache</a>() to get the cache</p>
<pre><code class="lang-auto"></code></pre>
<p>You dynamically allocate memory but you never delete them in you code , thus you extremely leaking memory. Do you understand how dynamic memory allocation/deallocation works in c++ ?</p>
<pre><code class="lang-auto"></code></pre>
<p>You still using std::string and i already stated that it is a bad <a href="http://idea.It" rel="nofollow noopener">idea.It</a>’s trivial to link against the stdlib on linux and windows but on other platforms may not be that simple.Also if you try to compile your game on a system that does not implement the std::string you’re doomed. Same goes for std::vector. Urho3d has it’s own Vector and String containers that the developers can guarantee will compile on every platform they support.If you use std:: i don’t think they can guarantee anything. Urho’s string and vector work exacly the same way as the std:: containers.</p>
<p><code>exitNode-&gt;CreateComponent&lt;Exit&gt;();   
Exit* tempExit = exitNode-&gt;GetComponent&lt;Exit&gt;();</code><br/>
Whats wrong with</p>
<pre><code class="lang-auto"></code></pre>
<p><code>exit.position = exit.e_Node-&gt;GetWorldPosition();
exit.module_pos = Vector3::ZERO;
exitList.push_back(exit);</code><br/>
This doesn’t make any sense.Why you need a separate component for this ? I would suggest you could use node-&gt;SetVar() GetVar() for parameters like these.Or simply implement them in the Element component i suggested.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>first, i want things done. then, i optimize my code or whatever.</p>
<p>my first step is having my maze generated without problems, and to do so, i need a collision check.<br/>
i don’t really need the whole physical simulation right now, i just need something that tell me when two modules are colliding, that’s all.</p>
<p>you guys told me to use events.<br/>
from there already it became a mess because i didn’t know about events and i wanted it to work in my class and not in the main.cpp and then you told me about components, etc…</p>
<p>so right now, i will test some events in my main.cpp and see how it goes.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>so here is my try :</p>
<pre><code class="lang-auto">//engine
#include &lt;Urho3D/Engine/Application.h&gt;
#include &lt;Urho3D/Engine/Engine.h&gt;
#include &lt;Urho3D/Input/Input.h&gt;
#include &lt;Urho3D/Input/InputEvents.h&gt;
#include &lt;Urho3D/Graphics/Graphics.h&gt;

#include &lt;Urho3D/Resource/ResourceCache.h&gt;
#include &lt;Urho3D/Scene/Scene.h&gt;
#include &lt;Urho3D/Scene/SceneEvents.h&gt;
#include &lt;Urho3D/Graphics/Octree.h&gt;
#include &lt;Urho3D/Graphics/DebugRenderer.h&gt;
#include &lt;Urho3D/Graphics/Camera.h&gt;
#include &lt;Urho3D/Graphics/Viewport.h&gt;
#include &lt;Urho3D/Graphics/Renderer.h&gt;

#include &lt;Urho3D/Graphics/Model.h&gt;
#include &lt;Urho3D/Graphics/StaticModel.h&gt;
#include &lt;Urho3D/Graphics/AnimatedModel.h&gt;
#include &lt;Urho3D/Graphics/Material.h&gt;

#include &lt;Urho3D/Graphics/Light.h&gt;

#include &lt;Urho3D/Core/CoreEvents.h&gt;

#include &lt;Urho3D/Math/Vector3.h&gt;

#include &lt;Urho3D/UI/Window.h&gt;
#include &lt;Urho3D/UI/Text.h&gt;
#include &lt;Urho3D/UI/Font.h&gt;
#include &lt;Urho3D/UI/UI.h&gt;

//my class
#include "Modules.h"
#include "Exit.h"
#include "Counts.h"

//include
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

//just for testing
#include "conversions.h"
#include "fonctions.h"
#include &lt;Urho3D/IO/Log.h&gt;

//physic
#include &lt;Urho3D/Physics/CollisionShape.h&gt;//test
#include &lt;Urho3D/Physics/PhysicsWorld.h&gt;
#include &lt;Urho3D/Physics/RigidBody.h&gt;//test
#include &lt;Urho3D/Physics/PhysicsEvents.h&gt;



using namespace NodeCollision;
using namespace Urho3D;


class projet : public Application
{
    URHO3D_OBJECT(projet, Application)

public:

////______________________
////    DEFINITION    


    SharedPtr&lt;Scene&gt; my_scene;

    //about camera
    SharedPtr&lt;Node&gt; camNode;

    //physic
    bool drawDebug_;

    //about text
    Window* window;
    Text* text;

    projet(Context* context) : Application(context)
    {
    }

    virtual void Setup()
    {
        engineParameters_["FullScreen"]=false;
        engineParameters_["WindowWidth"]=1280;
        engineParameters_["WindowHeight"]=720;
        engineParameters_["WindowResizable"]=true;
    }

    virtual void Start()
    {

        ResourceCache* cache=GetSubsystem&lt;ResourceCache&gt;();

        my_scene=new Scene(context_);
        my_scene-&gt;CreateComponent&lt;Octree&gt;();
        my_scene-&gt;CreateComponent&lt;DebugRenderer&gt;();
//physic
        my_scene-&gt;CreateComponent&lt;PhysicsWorld&gt;();


////___________________
////    MODULES    

        
        //Dungeon dungeon(600, my_scene, cache);


    Node* m_Node = my_scene-&gt;CreateChild("1");
    m_Node-&gt;SetWorldPosition(Vector3::ZERO);   //room.position          
    m_Node-&gt;SetWorldRotation(Quaternion::IDENTITY);   //room.rotation (1,0,0,0) 
     
    AnimatedModel* m_Object=m_Node-&gt;CreateComponent&lt;AnimatedModel&gt;();
    m_Object-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/room0.mdl"));
    m_Object-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/blank.xml"));
              
    RigidBody* m_Body = m_Node-&gt;CreateComponent&lt;RigidBody&gt;();
    m_Body-&gt;SetMass(0);  //0 for static object
    //m_Body-&gt;SetUseGravity(false);
    //m_Body-&gt;SetTrigger(true);
    m_Body-&gt;SetFriction(0.6);        // friction with other objects (like the ground)
    m_Body-&gt;SetCollisionLayer(1);

    CollisionShape* m_BBox = m_Node-&gt;CreateComponent&lt;CollisionShape&gt;();
    m_BBox-&gt;SetTriangleMesh(cache-&gt;GetResource&lt;Model&gt;("Models/room0.mdl"));
        
    Node* light=m_Node-&gt;CreateChild("m_light");
    light-&gt;SetPosition(Vector3(0, 5, 0));
    {
        Light* Mlight=light-&gt;CreateComponent&lt;Light&gt;();
        Mlight-&gt;SetLightType(LIGHT_POINT);
        Mlight-&gt;SetRange(20);
        Mlight-&gt;SetBrightness(1.0);
        Mlight-&gt;SetColor(Color(.8,.8,.8,1.0));
    }


    Node* m_Node2 = my_scene-&gt;CreateChild("2");
    m_Node2-&gt;SetWorldPosition(Vector3(0,3,0));   //room.position          
    m_Node2-&gt;SetWorldRotation(Quaternion::IDENTITY);   //room.rotation (1,0,0,0) 
     
    AnimatedModel* m_Object2=m_Node2-&gt;CreateComponent&lt;AnimatedModel&gt;();
    m_Object2-&gt;SetModel(cache-&gt;GetResource&lt;Model&gt;("Models/cor0.mdl"));
    m_Object2-&gt;SetMaterial(cache-&gt;GetResource&lt;Material&gt;("Materials/blank.xml"));
              
    RigidBody* m_Body2 = m_Node2-&gt;CreateComponent&lt;RigidBody&gt;();
    m_Body2-&gt;SetMass(1);  //0 for static object
    //m_Body2-&gt;SetUseGravity(false);
    //m_Body2-&gt;SetTrigger(true);
    m_Body2-&gt;SetFriction(0.6);        // friction with other objects (like the ground)
    m_Body2-&gt;SetCollisionLayer(1);

    CollisionShape* m_BBox2 = m_Node2-&gt;CreateComponent&lt;CollisionShape&gt;();
    m_BBox2-&gt;SetTriangleMesh(cache-&gt;GetResource&lt;Model&gt;("Models/cor0.mdl"));



////__________________
////    CAMERA        


        camNode=my_scene-&gt;CreateChild("camNode");
        Camera* camObject=camNode-&gt;CreateComponent&lt;Camera&gt;();
        camObject-&gt;SetFarClip(2000);
	camNode-&gt;SetWorldPosition(Vector3(0,20,-20));     //x =blender y //y =blender z hauteur //z =blender x profondeur
	camNode-&gt;LookAt(Vector3::ZERO);

        //camera light
        {
            Light* light=camNode-&gt;CreateComponent&lt;Light&gt;();
            light-&gt;SetLightType(LIGHT_POINT);
            light-&gt;SetRange(25);
            light-&gt;SetBrightness(2.0);
            light-&gt;SetColor(Color(.8,1,.8,1.0));
        }

////________________
////    TEXT    


        std::string str = (""); 
        {
            std::ostringstream ss;
            ss;
              //&lt;&lt;" module count = "&lt;&lt;dungeon.MODULE_COUNT
              //&lt;&lt;"\n free exit = "&lt;&lt;dungeon.mainExitList.size();

            std::string s(ss.str());
            str.append(s/*.substr(0,60)*/);
        }
        String s(str.c_str(),str.size());

        window=new Window(context_);
        GetSubsystem&lt;UI&gt;()-&gt;GetRoot()-&gt;AddChild(window);
        window-&gt;SetStyle("Window");
        window-&gt;SetSize(500,200);
        window-&gt;SetColor(Color(.0,.15,.3,.5));
        window-&gt;SetAlignment(HA_LEFT,VA_TOP);

        text=new Text(context_);
        text-&gt;SetFont(cache-&gt;GetResource&lt;Font&gt;("Fonts/Anonymous Pro.ttf"),14);
        text-&gt;SetColor(Color(.8,.85,.9));
        text-&gt;SetAlignment(HA_LEFT,VA_TOP);
        text-&gt;SetText(s); //s
        window-&gt;AddChild(text);


////__________________
////    RENDER    


        Renderer* renderer=GetSubsystem&lt;Renderer&gt;();
        SharedPtr&lt;Viewport&gt; viewport(new Viewport(context_,my_scene,camNode-&gt;GetComponent&lt;Camera&gt;()));
        renderer-&gt;SetViewport(0,viewport);


////__________________
////    EVENTS    


    //SubscribeToEvent(E_BEGINFRAME,URHO3D_HANDLER(projet,HandleBeginFrame));
    //SubscribeToEvent(E_KEYDOWN,URHO3D_HANDLER(projet,HandleKeyDown));
    //SubscribeToEvent(E_UIMOUSECLICK,URHO3D_HANDLER(projet,HandleControlClicked));
        SubscribeToEvent(E_UPDATE, URHO3D_HANDLER(projet, HandleUpdate));
    //SubscribeToEvent(E_POSTUPDATE,URHO3D_HANDLER(projet,HandlePostUpdate));

        SubscribeToEvent(m_Node, E_NODECOLLISION, URHO3D_HANDLER(projet, OnNodeCollisionEvent));
        SubscribeToEvent(E_PHYSICSCOLLISION, URHO3D_HANDLER(projet, OnCollisionEvent));

    //SubscribeToEvent(E_RENDERUPDATE,URHO3D_HANDLER(projet,HandleRenderUpdate));
        SubscribeToEvent(E_POSTRENDERUPDATE,URHO3D_HANDLER(projet,HandlePostRenderUpdate));     
    //SubscribeToEvent(E_ENDFRAME,URHO3D_HANDLER(projet,HandleEndFrame));
        SubscribeToEvent(E_KEYDOWN, URHO3D_HANDLER(projet, HandleKeyDown));
    }

    virtual void Stop()
    {
    }


////________


    void HandleUpdate(StringHash eventType,VariantMap&amp; eventData)
    {
        float timeStep=eventData[Update::P_TIMESTEP].GetFloat();
	float MOVE_SPEED=50.0f;
        Input* input=GetSubsystem&lt;Input&gt;();

	if(input-&gt;GetQualifierDown(1))  // 1 is shift, 2 is ctrl, 4 is alt
            MOVE_SPEED*=4;

        if(input-&gt;GetKeyDown('D')) //rotate sens inverse horizontal
            camNode-&gt;Translate(Vector3(1,0, 0)*MOVE_SPEED*timeStep);
        if(input-&gt;GetKeyDown('Q')) //sens montre horizontal
            camNode-&gt;Translate(Vector3(-1,0,0)*MOVE_SPEED*timeStep);
        if(input-&gt;GetKeyDown('Z')) //zoom avant
            camNode-&gt;Translate(Vector3(0,0,1)*MOVE_SPEED*timeStep);
        if(input-&gt;GetKeyDown('S')) //zoom arriere
            camNode-&gt;Translate(Vector3(0,0,-1)*MOVE_SPEED*timeStep);
	if(input-&gt;GetKeyDown('E')) //rotate sens inverse vertical
            camNode-&gt;Translate(Vector3(0,1,0)*MOVE_SPEED*timeStep);
        if(input-&gt;GetKeyDown('A')) //sens montre vertical
            camNode-&gt;Translate(Vector3(0,-1,0)*MOVE_SPEED*timeStep);
        if (input-&gt;GetKeyPress(KEY_SPACE)) // Toggle physics debug geometry with space
            drawDebug_ = !drawDebug_;

	if(!GetSubsystem&lt;Input&gt;()-&gt;IsMouseGrabbed())
	{
	    IntVector2 mouseMove=input-&gt;GetMouseMove();
	    
	    if(mouseMove.x_&gt;-2000000000&amp;&amp;mouseMove.y_&gt;-2000000000)
            {
		camNode-&gt;LookAt(Vector3::ZERO); //look at 0,0,0
            }
	}
            


    }

////________


    void OnNodeCollisionEvent(StringHash eventType, VariantMap&amp; eventData)
    {
        URHO3D_LOGINFO("OnNodeCollisionEvent");
    }


    void OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData)
    {
        //RigidBody* body = static_cast&lt;RigidBody*&gt;(eventData[P_BODY].GetPtr());
        URHO3D_LOGINFO("OnCollisionEvent");
    }

////________

    void HandlePostRenderUpdate(StringHash eventType, VariantMap&amp; eventData)
    {
    // If draw debug mode is enabled, draw physics debug geometry. Use depth test to make the result easier to interpret
        if (drawDebug_)
            my_scene-&gt;GetComponent&lt;PhysicsWorld&gt;()-&gt;DrawDebugGeometry(true);
    }

////________

    void HandleKeyDown(StringHash eventType, VariantMap&amp; eventData)
    {
        using namespace KeyDown;

        Graphics* graphics=GetSubsystem&lt;Graphics&gt;();
        int key = eventData[P_KEY].GetInt();

        if (key == KEY_ESC) //ESC to quit
        {
            engine_-&gt;Exit();
        }
        else if(key == KEY_TAB) //TAB to toggle mouse cursor
        {
            GetSubsystem&lt;Input&gt;()-&gt;SetMouseVisible(!GetSubsystem&lt;Input&gt;()-&gt;IsMouseVisible());
            GetSubsystem&lt;Input&gt;()-&gt;SetMouseGrabbed(!GetSubsystem&lt;Input&gt;()-&gt;IsMouseGrabbed()); 
        }
	else if(key == 'W') //W for fullscreen
	{
	    graphics-&gt;ToggleFullscreen();
	}
        else if(key == 'I')
        {
            //GetSubsystem&lt;UI&gt;()-&gt;menu-&gt;ShowPopup ();
        }
    }


////________


};
URHO3D_DEFINE_APPLICATION_MAIN(projet)
</code></pre>
<p>it load my 2 test module, and the second module just fall through the first one.</p>
<p>1/ why the physic simulation isn’t working at all ? i have a static and a non-static, i guess the non-static should somehow bounce on the static no ?<br/>
2/ and why none of my events return a thing in the log ?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>at least, i was able to get something working and so i found out what my problem is.</p>
<pre><code class="lang-auto"></code></pre>
<p>if i set my collision shape as a box, it work like a charm but it doesn’t do anything with SetTriangleMesh and my custom shape.<br/>
i recall having see something about it somewhere, i through it was in the API but doesn’t seem so or it was edited while i was trying stuff.<br/>
it was saying that the SetTriangleMesh thing is not activated by default or something and i don’t remember what it was saying to fix it.</p>
<p>so, how can i make my room0.mdl well recognized by the physic engine ?</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>found out, it was in the wiki.</p>
<aside class="quote">
<blockquote>
<p>Note: triangle mesh on triangle mesh collisions are disabled per default. See PhysicsWorld::SetInternalEdge(bool enable) <a href="http://urho3d.github.io/documentation/1.32/class_urho3_d_1_1_physics_world.html" rel="nofollow noopener">urho3d.github.io/documentation/1 … world.html</a>. </p>
</blockquote>
</aside>
<p>im using windows right now, i program with ubuntu but i will test it next time in hope it will work at last… &gt;&lt;</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<pre><code class="lang-auto">        PhysicsWorld* physicWorld = my_scene-&gt;CreateComponent&lt;PhysicsWorld&gt;();
        physicWorld-&gt;SetInternalEdge(true);</code></pre>
<p>doesn’t work either. i’m kinda losing hope…<br/>
is there another method to get .mdl collision shapes well recognized by the engine ?<br/>
could it be a .mdl issue ? a setting in blender, i wonder.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>i’m a bit disappointed but convex hulls seems to work so i will try with that.</p>
<aside class="quote no-group" data-username="Dave82">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/39fd1aeff01d89e7279fa956666af00e.png" width="20"/> Dave82:</div>
<blockquote>
<p>Components doesn’t have transforms , nodes do ! How do you expect your Module component to move in 3d space ? It’s not a transformable entity it is just a component ! you expect to move based on what exacly ?</p>
</blockquote>
</aside>
<p>yes, i’m trying to derive from Node but it confuse me more than ever.</p>
<aside class="quote no-group" data-username="Dave82">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/39fd1aeff01d89e7279fa956666af00e.png" width="20"/> Dave82:</div>
<blockquote>
<p>your code is so overcomplicated for such a simple task you want to achive.By simplifying the code i can garantee you could get the same effect with only 10-15 lines of code…</p>
</blockquote>
</aside>
<p>i would like to know how to do that, each time i try a different thing but it end up a mess anyway.<br/>
i use std::string because it is needed for tinyxml2. i had difficulties using PugiXML, tinyxml2 was more convenient to me.<br/>
and then, there is all the mess around.</p>
<p>the xml (so i can change modules not having to recompile)</p>
<p>[spoiler][code]</p>
<p>[/code][/spoiler]</p>
<p>a class to check the number of modules by type and the number of module i will want to load. (i need to add some code if a value is 0 or the app will crash)</p>
<p>[spoiler][code]xmlCounts::xmlCounts()<br/>
{</p>
<pre><code>tinyxml2::XMLDocument modules;
modules.Parse("Data/Scripts/Modules.xml");
if(modules.LoadFile("Data/Scripts/Modules.xml") == tinyxml2::XML_NO_ERROR)
{
    tinyxml2::XMLNode* root = modules.FirstChild();
    tinyxml2::XMLElement* infos = root-&gt;FirstChildElement("infos");
    infos-&gt;QueryIntAttribute("room_count", &amp;room);
    infos-&gt;QueryIntAttribute("cor_count", &amp;cor);
    infos-&gt;QueryIntAttribute("junc_count", &amp;junc);
    infos-&gt;QueryIntAttribute("toLoad", &amp;toLoad);
}
</code></pre>
<p>}[/code][/spoiler]</p>
<p>then i use xml again to get module infos</p>
<p>[spoiler][code]r_Rooms::r_Rooms()<br/>
{</p>
<pre><code>xmlCounts m_counts;

type=0;
int roomNbr = chooseRandomNbr(m_counts.room);
std::string std_name = stringInt("room",roomNbr);
const char* ROOMX = std_name.c_str(); //std::string to const char*
    
tinyxml2::XMLDocument modulesXML;
modulesXML.Parse("Data/Scripts/Modules.xml");
if(modulesXML.LoadFile("Data/Scripts/Modules.xml") == tinyxml2::XML_NO_ERROR)
{
        tinyxml2::XMLNode* root = modulesXML.FirstChild();
        tinyxml2::XMLElement* roomXML = root-&gt;FirstChildElement(ROOMX);
        roomXML-&gt;QueryIntAttribute("exits", &amp;exits);
        std::string std_path = roomXML-&gt;Attribute("path");                
        std::string std_texturepath = roomXML-&gt;Attribute("texturepath");
        path = string2urhoString(std_path); //to urho String
        texturepath = string2urhoString(std_texturepath); //to urho String
         
}
</code></pre>
<p>}[/code][/spoiler]</p>
<p>and then, i need something to create a urho node with a module with AnimatedModel, a vector of child node or something with its exits (bones that i get position from) and its RigidBody and CollisionShape so i can register it with a collision event to test collision and move it at will when i build the dungeon.<br/>
how would you do that because i don’t know how to organise it for the best.</p>
<aside class="quote no-group" data-username="Dave82">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/39fd1aeff01d89e7279fa956666af00e.png" width="20"/> Dave82:</div>
<blockquote>
<p>Do you understand how dynamic memory allocation/deallocation works in c++ ?</p>
</blockquote>
</aside>
<p>yes a little. i know i don’t free the memory where i should… ^^;</p>
<aside class="quote no-group" data-username="Dave82">
<div class="title">
<div class="quote-controls"></div>
<img alt="" class="avatar" height="20" src="../../../images2/39fd1aeff01d89e7279fa956666af00e.png" width="20"/> Dave82:</div>
<blockquote>
<p>This doesn’t make any sense.Why you need a separate component for this ? I would suggest you could use node-&gt;SetVar() GetVar() for parameters like these.Or simply implement them in the Element component i suggested.</p>
</blockquote>
</aside>
<p>basicaly, one exit is a child node that represent a bone of the module. i use those to get my exits positions to calculate modules placement when i build the dungeon.</p>
<p>anyway, thx for your patience, any help is appreciated, it’s just that i tryed a few things before and each time i was kinda stuck at physic so it’s very frustrating for me as i’m kinda very close to exceed this limit.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/1995_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">noals</div>
          <div class="post_content">
<p>it’s with convex hulls but it works at last.<br/>
just added this component :</p>
<p>OnCollision.h</p>
<pre><code class="lang-auto">#pragma once

using namespace Urho3D;

class OnCollision : public Component
{
    URHO3D_OBJECT(OnCollision, Component);
    
public:
    OnCollision(Context* context);

protected:
    /// Handle node being assigned.
    virtual void OnNodeSet(Node* node);
    
private:
    /// Handle scene node's physics collision.
    void OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData);
};</code></pre>
<p>OnCollision.cpp</p>
<pre><code class="lang-auto">#include "OnCollision.h"

using namespace Urho3D;

OnCollision::OnCollision(Context* context) :
    Component(context)
{

}


//protected
void OnCollision::OnNodeSet(Node* node)
{
    // If the node pointer is non-null, this component has been created into a scene node. Subscribe to physics collisions that concern this scene node
    if (node)
    {
        SubscribeToEvent(node, E_NODECOLLISIONSTART, URHO3D_HANDLER(OnCollision, OnCollisionEvent));
        URHO3D_LOGINFO("node set");
    }
}

//private
void OnCollision::OnCollisionEvent(StringHash eventType, VariantMap&amp; eventData)
{
    using namespace NodeCollision;

    // Get the other colliding body
    RigidBody* otherBody = static_cast&lt;RigidBody*&gt;(eventData[P_OTHERBODY].GetPtr());

        URHO3D_LOGINFO("collide");
		
        // Finally remove self from the scene node. Note that this must be the last operation performed in the function
        //Remove();  
}</code></pre>
<p>log</p>
<aside class="quote">
<blockquote>
<p>[Sun Jun 12 06:19:47 2016] INFO: Opened log file Urho3D.log<br/>
[Sun Jun 12 06:19:47 2016] INFO: Created 3 worker threads<br/>
[Sun Jun 12 06:19:47 2016] INFO: Added resource path /home/noname/Bureau/projet_build/bin/Data/<br/>
[Sun Jun 12 06:19:47 2016] INFO: Added resource path /home/noname/Bureau/projet_build/bin/CoreData/<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Skipped autoload path ‘Autoload’ as it does not exist, check the documentation on how to set the ‘resource prefix path’<br/>
[Sun Jun 12 06:19:47 2016] INFO: Set screen mode 1280x720 windowed resizable<br/>
[Sun Jun 12 06:19:47 2016] INFO: Initialized input<br/>
[Sun Jun 12 06:19:47 2016] INFO: Initialized user interface<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Textures/Ramp.png<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading temporary resource Textures/Ramp.xml<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Textures/Spot.png<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading temporary resource Textures/Spot.xml<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Techniques/NoTexture.xml<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource RenderPaths/Forward.xml<br/>
[Sun Jun 12 06:19:47 2016] INFO: Initialized renderer<br/>
[Sun Jun 12 06:19:47 2016] ERROR: Could not initialize audio output<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource UI/MessageBox.xml<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading UI layout UI/MessageBox.xml<br/>
[Sun Jun 12 06:19:47 2016] INFO: Initialized engine<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Models/room2.mdl        &lt;---- first model<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Materials/blank.xml<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Techniques/Diff.xml<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Textures/grid_8x8.png<br/>
[Sun Jun 12 06:19:47 2016] INFO: node set        &lt;----<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Models/cor1.mdl        &lt;---- second model<br/>
[Sun Jun 12 06:19:47 2016] INFO: node set        &lt;----<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Fonts/Anonymous Pro.ttf<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Font face Anonymous Pro (14pt) has 624 glyphs<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Reloading shaders<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Shaders/GLSL/LitSolid.glsl<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Compiled vertex shader LitSolid(PERPIXEL POINTLIGHT SKINNED)<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Compiled pixel shader LitSolid(AMBIENT DIFFMAP PERPIXEL POINTLIGHT SPECULAR)<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Linked vertex shader LitSolid(PERPIXEL POINTLIGHT SKINNED) and pixel shader LitSolid(AMBIENT DIFFMAP PERPIXEL POINTLIGHT SPECULAR)<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Shaders/GLSL/Stencil.glsl<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Compiled vertex shader Stencil()<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Compiled pixel shader Stencil()<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Linked vertex shader Stencil() and pixel shader Stencil()<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Compiled pixel shader LitSolid(DIFFMAP PERPIXEL POINTLIGHT SPECULAR)<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Linked vertex shader LitSolid(PERPIXEL POINTLIGHT SKINNED) and pixel shader LitSolid(DIFFMAP PERPIXEL POINTLIGHT SPECULAR)<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Loading resource Shaders/GLSL/Basic.glsl<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Compiled vertex shader Basic(VERTEXCOLOR)<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Compiled pixel shader Basic(VERTEXCOLOR)<br/>
[Sun Jun 12 06:19:47 2016] DEBUG: Linked vertex shader Basic(VERTEXCOLOR) and pixel shader Basic(VERTEXCOLOR)<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: collide        &lt;----<br/>
[Sun Jun 12 06:19:47 2016] INFO: collide        &lt;----<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
[Sun Jun 12 06:19:47 2016] INFO: OnCollisionEvent<br/>
etc…</p>
</blockquote>
</aside>
<p>now, i just need to find a way to avoid collision between module that are next to each other but it shouldn’t be too hard now that i understand the events better :</p>
<pre><code class="lang-auto">URHO3D_EVENT(E_NODECOLLISION, NodeCollision)
{
    URHO3D_PARAM(P_BODY, Body);                    // RigidBody pointer
    URHO3D_PARAM(P_OTHERNODE, OtherNode);          // Node pointer
    URHO3D_PARAM(P_OTHERBODY, OtherBody);          // RigidBody pointer
    URHO3D_PARAM(P_TRIGGER, Trigger);              // bool
    URHO3D_PARAM(P_CONTACTS, Contacts);            // Buffer containing position (Vector3), normal (Vector3), distance (float), impulse (float) for each contact
}</code></pre>
<p>thx.</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>