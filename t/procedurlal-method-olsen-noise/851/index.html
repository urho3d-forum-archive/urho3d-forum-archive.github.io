<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width">
    <title>Procedurlal Method (Olsen Noise)</title>
    <link rel="stylesheet" href="../../../archived.css" />
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  </head>

  <body>
    <header class="header">
      <div class="title-span">
        <a href="../../../">
          <img src="../../../images/site-logo.png" height="40" alt="Urho3D" id="site-logo" />
        </a>
      </div>
    </header>

    <div class="main">
    <div class="archive-span">Archive 17/01/2023.</div>
    <h1 class="topic-title">Procedurlal Method (Olsen Noise)</h1>
            <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Hey,</p>
<p>I took a crack at converting some JAVA procedural method to c++. I’m getting the following compile error.</p>
<p><code>/media/home2/vivienne/testingc++/olsen2dwip.cpp||In member function ?int* OlsenNoise2D::olsennoise(int, int, int, int)?:|
/media/home2/vivienne/testingc++/olsen2dwip.cpp|79|error: no matching function for call to ?OlsenNoise2D::hashrandom(int, int, int&amp;)?|
/media/home2/vivienne/testingc++/olsen2dwip.cpp|79|note: candidate is:|
/media/home2/vivienne/testingc++/olsen2dwip.cpp|17|note: int OlsenNoise2D::hashrandom(int*)|
/media/home2/vivienne/testingc++/olsen2dwip.cpp|17|note:   candidate expects 1 argument, 3 provided|
/media/home2/vivienne/testingc++/olsen2dwip.cpp||In member function ?int OlsenNoise2D::hashrandom(int*)?:|
/media/home2/vivienne/testingc++/olsen2dwip.cpp|144|error: request for member ?size? in ?elements?, which is of non-class type ?int*?|
/media/home2/vivienne/testingc++/olsen2dwip.cpp|147|error: ?hash? cannot be used as a function|
||=== Build finished: 6 errors, 0 warnings ===|
</code></p>
<p>The code is at PasteBin is <a href="http://pastebin.com/gh6P5zf3" rel="nofollow noopener">pastebin.com/gh6P5zf3</a></p>
<p>[code]<br/>
int * OlsenNoise2D::olsennoise(int x, int y, int width, int height)<br/>
{<br/>
int maxiterations = 7;<br/>
int cx, cy;<br/>
int cxh, cyh;<br/>
int cwidth, cheight;<br/>
int xoff, yoff;<br/>
int nwidth, nheight;<br/>
int nx, ny;<br/>
int nxh, nyh;<br/>
int m=0;<br/>
int n=0;<br/>
int * field = NULL;</p>
<pre><code>for (int iteration = 0; iteration &lt; maxiterations; iteration++)
{
    nx = x;
    ny = y;

    nxh = x + width;
    nyh = y + width;

    n = maxiterations - iteration;

    for (int i = 1; i &lt; n; i++)
    {
        nx = (nx / 2) - 1;
        ny = (ny / 2) - 1;
        nxh = 1 -(-nxh/2);
        nyh = 1 -(-nyh/2);
    }

    xoff = -2*((nx/2)) + nx + 1;
    yoff = -2*((ny/2)) + ny + 1;

    cx = (nx / 2) - 1;
    cy = (ny / 2) - 1;
    cxh = 1 -(-nxh/2);
    cyh = 1 -(-nyh/2);

    nwidth = nxh - nx;
    nheight = nyh - ny;

    cwidth = cxh - cx;
    cheight = cyh - cy;


    /// Field
    m=cwidth;
    n=cheight;

    if (field == NULL) field = new int[m*(n*m)];

    for (int j = 0; j &lt; m; j++)
    {
        for (int k = 0; k &lt; n; k++)
        {
            field[j+(k*m)] += (hashrandom(cx + j, cy + k, iteration) &amp; (1 &lt;&lt; (7 - iteration)));
        }
    }

    /// Up sampled
    //m=field.length * 2;
    //n=field[0].length * 2;
    m=cwidth*2;
    n=cheight*2;


    int * upsampled = new int[m*(n*m)];

    for (int j = 0; j &lt; m; j++)
    {
        for (int k = 0; k &lt; n; k++)
        {
            upsampled[j+(k*m)] = field[(j / 2)+((k / 2)*cwidth)];
        }
    }
    field = upsampled;

    /// Blur field
    //int m=field.length - 2;
    //int n=field[0].length - 2;
    m=cwidth-2;
    n=cheight-2;

    int * blurfield = new int[m*(n*m)];

    for (int j = 0; j &lt; m; j++)
    {
        for (int k = 0;  k &lt; n; k++)
        {
            for (int h = 0; h &lt; 9; h++)
            {
                blurfield[j+(k*m)] += field[(j + (h % 3))+((k + (h / 3))*(cheight*2))];
            }
            blurfield[j+(k*m)] /= 9;
        }
    }
    field = blurfield;

    /// Trim field
    m=nwidth;
    n=nheight;

    int * trimfield = new int[m*(n*m)];

    for (int j = 0;j &lt; m; j++)
    {
        for (int k = 0; k &lt; n; k++)
        {
            trimfield[j+(k*m)] = field[(j + xoff)+((k + yoff)*(nheight-2))];
        }
    }
    field = trimfield;
}
return field;
</code></pre>
<p>}</p>
<p>int OlsenNoise2D::hashrandom(int elements[])<br/>
{<br/>
long hash = 0;</p>
<pre><code>for (int i = 0; i &lt; elements.size; i++)
{
    hash ^= elements[i];
    hash = hash(hash);
}
return (int) hash;
</code></pre>
<p>};</p>
<p>long OlsenNoise2D::hash(long v)<br/>
{<br/>
long hash = v;<br/>
long h = hash;</p>
<pre><code>switch ((int) hash &amp; 3)
{
case 3:
    hash += h;
    hash ^= hash &lt;&lt; 32;
    hash ^= h &lt;&lt; 36;
    hash += hash &gt;&gt; 22;
    break;
case 2:
    hash += h;
    hash ^= hash &lt;&lt; 22;
    hash += hash &gt;&gt; 34;
    break;
case 1:
    hash += h;
    hash ^= hash &lt;&lt; 20;
    hash += hash &gt;&gt; 2;
}
hash ^= hash &lt;&lt; 6;
hash += hash &gt;&gt; 10;
hash ^= hash &lt;&lt; 8;
hash += hash &gt;&gt; 34;
hash ^= hash &lt;&lt; 50;
hash += hash &gt;&gt; 12;
return hash;
</code></pre>
<p>};</p>
<p>int main()<br/>
{</p>
<pre><code>return 1;
</code></pre>
<p>}[/code]</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Revised</p>
<p>[code]/*</p>
<ul>
<li>
<span class="mention">@author</span> Tat</li>
<li>c++ rewrite vivienne (WIP)<br/>
*/</li>
</ul>
<p><span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> </p>
<p><span class="hashtag">#include</span> &lt;stdio.h&gt;<br/>
<span class="hashtag">#include</span> &lt;stdlib.h&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/png.hpp&gt;</p>
<p>using namespace std;</p>
<p>void SaveTerrFile(const int * image, int size);</p>
<p>class OlsenNoise2D<br/>
{</p>
<p>public:<br/>
int * olsennoise(int x, int y, int width, int height);</p>
<p>private:<br/>
int hashrandom(std::vector elements);<br/>
long hash(long v);</p>
<p>};</p>
<p>int * OlsenNoise2D::olsennoise(int x, int y, int width, int height)<br/>
{<br/>
int maxiterations = 7;<br/>
int cx, cy;<br/>
int cxh, cyh;<br/>
int cwidth, cheight;<br/>
int xoff, yoff;<br/>
int nwidth, nheight;<br/>
int nx, ny;<br/>
int nxh, nyh;<br/>
int m=0;<br/>
int n=0;<br/>
int * field = NULL;</p>
<pre><code>for (int iteration = 0; iteration &lt; maxiterations; iteration++)
{
    nx = x;
    ny = y;

    nxh = x + width;
    nyh = y + width;

    n = maxiterations - iteration;

    for (int i = 1; i &lt; n; i++)
    {
        nx = (nx / 2) - 1;
        ny = (ny / 2) - 1;
        nxh = 1 -(-nxh/2);
        nyh = 1 -(-nyh/2);
    }

    xoff = -2*((nx/2)) + nx + 1;
    yoff = -2*((ny/2)) + ny + 1;

    cx = (nx / 2) - 1;
    cy = (ny / 2) - 1;
    cxh = 1 -(-nxh/2);
    cyh = 1 -(-nyh/2);

    nwidth = nxh - nx;
    nheight = nyh - ny;

    cwidth = cxh - cx;
    cheight = cyh - cy;


    /// Field
    m=cwidth;
    n=cheight;

    if (field == NULL) field = new int[m*(n*m)];

    for (int j = 0; j &lt; m; j++)
    {
        for (int k = 0; k &lt; n; k++)
        {
            field[j+(k*m)] += (hashrandom({cx + j, cy + k, iteration}) &amp; (1 &lt;&lt; (7 - iteration)));
        }
    }

    /// Up sampled
    //m=field.length * 2;
    //n=field[0].length * 2;
    m=cwidth*2;
    n=cheight*2;

    int * upsampled = new int[m*(n*m)];

    for (int j = 0; j &lt; m; j++)
    {
        for (int k = 0; k &lt; n; k++)
        {
            upsampled[j+(k*m)] = field[(j / 2)+((k / 2)*cwidth)];
        }
    }
    field = upsampled;

    /// Blur field
    //int m=field.length - 2;
    //int n=field[0].length - 2;
    m=cwidth-2;
    n=cheight-2;

    int * blurfield = new int[m*(n*m)];

    for (int j = 0; j &lt; m; j++)
    {
        for (int k = 0;  k &lt; n; k++)
        {
            for (int h = 0; h &lt; 9; h++)
            {
                blurfield[j+(k*m)] += field[(j + (h % 3))+((k + (h / 3))*(cheight*2))];
            }
            blurfield[j+(k*m)] /= 9;
        }
    }
    field = blurfield;

    /// Trim field
    m=nwidth;
    n=nheight;

    int * trimfield = new int[m*(n*m)];

    for (int j = 0;j &lt; m; j++)
    {
        for (int k = 0; k &lt; n; k++)
        {
            trimfield[j+(k*m)] = field[(j + xoff)+((k + yoff)*(nheight-2))];
        }
    }
    field = trimfield;
}
return field;
</code></pre>
<p>}</p>
<p>int OlsenNoise2D::hashrandom(std::vector elements)<br/>
{<br/>
long hashcalc = 0;</p>
<pre><code>for (int i = 0; i &lt; elements.size(); i++)
{
    hashcalc ^= elements[i];
    hashcalc = hash(hashcalc);
}
return (int) hashcalc;
</code></pre>
<p>};</p>
<p>long OlsenNoise2D::hash(long v)<br/>
{<br/>
long hash = v;<br/>
long h = hash;</p>
<pre><code>switch ((int) hash &amp; 3)
{
case 3:
    hash += h;
    hash ^= hash &lt;&lt; 32;
    hash ^= h &lt;&lt; 36;
    hash += hash &gt;&gt; 22;
    break;
case 2:
    hash += h;
    hash ^= hash &lt;&lt; 22;
    hash += hash &gt;&gt; 34;
    break;
case 1:
    hash += h;
    hash ^= hash &lt;&lt; 20;
    hash += hash &gt;&gt; 2;
}
hash ^= hash &lt;&lt; 6;
hash += hash &gt;&gt; 10;
hash ^= hash &lt;&lt; 8;
hash += hash &gt;&gt; 34;
hash ^= hash &lt;&lt; 50;
hash += hash &gt;&gt; 12;
return hash;
</code></pre>
<p>};</p>
<p>int main()<br/>
{<br/>
/// Test<br/>
int ImageSize=2049;</p>
<pre><code>int * imageInput = new int[ImageSize*ImageSize];

/// Image
OlsenNoise2D testingolsen;
imageInput=testingolsen.olsennoise(0,0,ImageSize,ImageSize);


SaveTerrFile(imageInput, ImageSize);

return 1;
</code></pre>
<p>}</p>
<p>void SaveTerrFile(const int * image, int size)<br/>
{<br/>
png::image&lt; png::rgb_pixel &gt; newimage(size, size);</p>
<pre><code>for (unsigned int y = 0; y &lt; newimage.get_width(); ++y)
{
    for (unsigned int x = 0; x &lt; newimage.get_height(); ++x)
    {
        int col = int(image[x+(y*newimage.get_width())]*255);
        newimage[y][x] = png::rgb_pixel(col,col,col);
        // non-checking equivalent of image.set_pixel(x, y, ...);
    }
}

newimage.write("rgbOlsen.png");
</code></pre>
<p>}</p>
<p>[/code]</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/357_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">JTippetts</div>
          <div class="post_content">
<p>The revision compiles, I take it? (It does for me, at least.)</p>
<p>In the original, the clue lies in the error message itself.<br/>
"error: no matching function for call to ?OlsenNoise2D::hashrandom(int, int, int&amp;)"<br/>
This means that you are trying to call a function called hashrandom that takes two ints and a reference to a third int, but the only candidate function it can find that’s called hashrandom expects an array of ints instead. Also, in C++, an array of ints is just a “dumb” sequential array of values, and not a “smart” array that includes a size() method. The solution (as you discovered) is to use a vector.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>[quote=“JTippetts”]The revision compiles, I take it? (It does for me, at least.)</p>
<p>In the original, the clue lies in the error message itself.<br/>
"error: no matching function for call to ?OlsenNoise2D::hashrandom(int, int, int&amp;)"<br/>
This means that you are trying to call a function called hashrandom that takes two ints and a reference to a third int, but the only candidate function it can find that’s called hashrandom expects an array of ints instead. Also, in C++, an array of ints is just a “dumb” sequential array of values, and not a “smart” array that includes a size() method. The solution (as you discovered) is to use a vector.[/quote]</p>
<p>The whole thing is weird I think. Usually I translate  array[x][y] to a sequential difference of  array[x+(y+width)] like you said a sequence. The first for loop does fit thtat after looking at it.</p>
<p>Its like<br/>
field 0<br/>
field 01<br/>
field 012 (set limit based on the previous level)</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/357_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">JTippetts</div>
          <div class="post_content">
<p>One potential source of problems that I see by looking at the compile warnings is that in the hash() function you are using <span class="bbcode-b">long int</span>, but you are attempting to bitshift by large amounts such as 36 or 50. long is only guaranteed by the standard to be at least a 32-bit type, so on platforms where it is implemented as 32 bits (including Windows) all of your bits are going to be shifted out completely when you shift by more than 32. Likely what you want to use instead is a <span class="bbcode-b">long long int</span> which is guaranteed to be at least 64 bits.</p>
<p>Also, you’re going to leak memory like crazy. In your main, you allocate imageInput as an array sized 2049x2049, but then you immediately overwrite it with the return result of the olsennoise() function, leaving the chunk you had allocated hanging out there in limbo rather than being properly freed. In addition, inside olsennoise you allocate an array of ints using new, assign the allocated block to the field variable, later allocate another array and assign it to upsample, then assign that to field, leaving the previously allocated block hanging out in the wind. Then you allocate <span class="bbcode-i">another</span> array, assign it to blurfield, then assign that to field: again, overwriting the previous address and leaving another allocated block in limbo. Then you do the same with a variable called trimfield. That’s a whole lot of memory you’re leaving allocated and twisting in the wind each time you call olsennoise(). You then return field, but nowhere in main is this returned array ever deleted.</p>
<p>You have to remember that C++ <span class="bbcode-b">new</span> doesn’t work like Java <span class="bbcode-b">new</span>, in that you have to explicitly call <span class="bbcode-b">delete</span> on anything you <span class="bbcode-b">new</span> or it will leak.</p>
<p>Another problem is that in olsennoise you allocate memory for field, then in the following loop you modify the values of field using the += operator (adding values to what was already there) without ever initializing the values you allocated to 0. That’s undefined behavior right there. It’s possible that the allocated chunk is 0 already, but not certain, and you could in fact be adding values to garbage. C++ new doesn’t automatically initialize non-class objects to 0.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>[quote=“JTippetts”]One potential source of problems that I see by looking at the compile warnings is that in the hash() function you are using <span class="bbcode-b">long int</span>, but you are attempting to bitshift by large amounts such as 36 or 50. long is only guaranteed by the standard to be at least a 32-bit type, so on platforms where it is implemented as 32 bits (including Windows) all of your bits are going to be shifted out completely when you shift by more than 32. Likely what you want to use instead is a <span class="bbcode-b">long long int</span> which is guaranteed to be at least 64 bits.</p>
<p>Also, you’re going to leak memory like crazy. In your main, you allocate imageInput as an array sized 2049x2049, but then you immediately overwrite it with the return result of the olsennoise() function, leaving the chunk you had allocated hanging out there in limbo rather than being properly freed. In addition, inside olsennoise you allocate an array of ints using new, assign the allocated block to the field variable, later allocate another array and assign it to upsample, then assign that to field, leaving the previously allocated block hanging out in the wind. Then you allocate <span class="bbcode-i">another</span> array, assign it to blurfield, then assign that to field: again, overwriting the previous address and leaving another allocated block in limbo. Then you do the same with a variable called trimfield. That’s a whole lot of memory you’re leaving allocated and twisting in the wind each time you call olsennoise(). You then return field, but nowhere in main is this returned array ever deleted.</p>
<p>You have to remember that C++ <span class="bbcode-b">new</span> doesn’t work like Java <span class="bbcode-b">new</span>, in that you have to explicitly call <span class="bbcode-b">delete</span> on anything you <span class="bbcode-b">new</span> or it will leak.</p>
<p>Another problem is that in olsennoise you allocate memory for field, then in the following loop you modify the values of field using the += operator (adding values to what was already there) without ever initializing the values you allocated to 0. That’s undefined behavior right there. It’s possible that the allocated chunk is 0 already, but not certain, and you could in fact be adding values to garbage. C++ new doesn’t automatically initialize non-class objects to 0.[/quote]</p>
<p>I’ll look at the code today. It was a rough rough conversion. I’m going make the change. I have to figure out how it fully functions tho but the way the person has it shifting the memory is not typically a way I would do it.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/357_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">JTippetts</div>
          <div class="post_content">
<p>Well, bit-shifting is a common component of hashing in noise implementations like this. The idea of hashing is to take values in a sequence (such as the coordinate pairs iterating a grid) and convert them to something random-seeming yet deterministic: ie, the output looks random, but calling hash on a given coordinate always results in the same output each call.</p>
<p>I’m not sure I really understand the need for this algorithm. For generating a terrain, it seems needlessly convoluted, and allocates a whole lot of large memory chunks. (In your code, I see allocations of the form m<em>m</em>n which, if m and n are equal to 2049, comes out to a whopping 32GB for a 32-bit int array.)  I understand from skimming the guy’s original blog post that it’s supposed to filter better than Perlin noise, but if you’re generating a terrain you’re not filtering it anyway. Perlin noise can be evaluated in-place without the need for allocating huge workspace buffers, and can produce roughly comparable and eminently acceptable results.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>[quote=“JTippetts”]Well, bit-shifting is a common component of hashing in noise implementations like this. The idea of hashing is to take values in a sequence (such as the coordinate pairs iterating a grid) and convert them to something random-seeming yet deterministic: ie, the output looks random, but calling hash on a given coordinate always results in the same output each call.</p>
<p>I’m not sure I really understand the need for this algorithm. For generating a terrain, it seems needlessly convoluted, and allocates a whole lot of large memory chunks. (In your code, I see allocations of the form m<em>m</em>n which, if m and n are equal to 2049, comes out to a whopping 32GB for a 32-bit int array.)  I understand from skimming the guy’s original blog post that it’s supposed to filter better than Perlin noise, but if you’re generating a terrain you’re not filtering it anyway. Perlin noise can be evaluated in-place without the need for allocating huge workspace buffers, and can produce roughly comparable and eminently acceptable results.[/quote]</p>
<p>That was a error on my part trying to figure out whats going on. The results to me isn’t very acceptable. I’m picky.</p>
<p>Also diamond square method is another method but I haven’t  find any good resource to allow offsetting. With STB I can choose a offset. This guys code I can choose a offset also.</p>
<p>I changed the code to this <a href="http://pastebin.com/bkeSiXgb" rel="nofollow noopener">pastebin.com/bkeSiXgb</a></p>
<p>If I set the interation to 1.  The equivalent of this in a image. <a href="http://imgur.com/BzDWARK" rel="nofollow noopener">imgur.com/BzDWARK</a></p>
<p>Now if I set it higher to 1, I get a segmentation fault which I think lays in this code and the length of elements vector</p>
<pre><code class="lang-auto"></code></pre>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Hi JTippett</p>
<p>This is the code I modified <a href="http://pastebin.com/PBCzcH3Q" rel="nofollow noopener">pastebin.com/PBCzcH3Q</a></p>
<p>If I set the interations to 2. It creates <a href="http://imgur.com/u4o8732" rel="nofollow noopener">imgur.com/u4o8732</a></p>
<p>So, I made the pointers and removed the allocated memory when need be.   The original code is <a href="http://godsnotwheregodsnot.blogspot.com/2014/09/olsen-noise-source-code-in-java.html" rel="nofollow noopener">godsnotwheregodsnot.blogspot.com … -java.html</a></p>
<p>I don’t think I should be using memcpy that way I am. Usually I just reference a pointer or whatever.</p>
<p>Maybe you’ll notice something. The speed of it is about 2 seconds when ran.  If done right, infinite terrain like <a href="http://imgur.com/f2aanDf" rel="nofollow noopener">imgur.com/f2aanDf</a> can be done.</p>
<p>Vivienne</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Current not working fully code</p>
<p>This is the code so far I converted to C++ (Olsen 2D)<br/>
<a href="http://pastebin.com/qbgBL0Hq" rel="nofollow noopener">pastebin.com/qbgBL0Hq</a></p>
<p>This is the image produce<br/>
<a href="http://imgur.com/nb2pMjP" rel="nofollow noopener">imgur.com/nb2pMjP</a></p>
<p>Original source code<br/>
<a href="http://pastebin.com/gh6P5zf3" rel="nofollow noopener">pastebin.com/gh6P5zf3</a></p>
<p>Demo Online(You should see what it should produce at 5 interations)<br/>
<a href="http://tatarize.nfshost.com/OlsenNoise.htm" rel="nofollow noopener">tatarize.nfshost.com/OlsenNoise.htm</a></p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>Hello,</p>
<p>Could someone take a look at this. I’m not sure what’s wrong or a simple solution. The discussion between the original developer is here.</p>
<p><a href="http://godsnotwheregodsnot.blogspot.com/2014/08/3d-olsen-noise.html" rel="nofollow noopener">godsnotwheregodsnot.blogspot.com … noise.html</a></p>
<p>The code is below. It works 90%. My goal is 100% plus throw in another 15%.</p>
<p>A image produced is <a href="http://imgur.com/P8EYbPn" rel="nofollow noopener">imgur.com/P8EYbPn</a></p>
<p>[code]/*</p>
<ul>
<li>
<span class="mention">@author</span> Tat</li>
<li>c++ rewrite vivienne (WIP)</li>
<li>verion .01<br/>
*/</li>
</ul>
<p><span class="hashtag">#include</span> <br/>
<span class="hashtag">#include</span> </p>
<p><span class="hashtag">#include</span> &lt;stdio.h&gt;<br/>
<span class="hashtag">#include</span> &lt;stdlib.h&gt;<br/>
<span class="hashtag">#include</span> &lt;png++/png.hpp&gt;</p>
<p>using namespace std;</p>
<p>void SaveTerrFile(const int * image, int size, char * filename);</p>
<p>class OlsenNoise2D<br/>
{</p>
<p>public:<br/>
int * olsennoise(int x, int y, int width, int height);</p>
<p>private:<br/>
int hashrandom(std::vector elements);<br/>
long long hash(long long v);</p>
<p>};</p>
<p>int * OlsenNoise2D::olsennoise(int x, int y, int width, int height)<br/>
{<br/>
int maxiterations = 4;<br/>
int cx, cy;<br/>
int cxh, cyh;<br/>
int cwidth, cheight;<br/>
int xoff, yoff;<br/>
int nwidth, nheight;<br/>
int nx, ny;<br/>
int nxh, nyh;<br/>
int m=0;<br/>
int n=0;<br/>
int fieldwidth=0;<br/>
int fieldheight=0;</p>
<pre><code>int * field = NULL;

for (int iteration = 0; iteration &lt; maxiterations; iteration++)
{
    nx = x;
    ny = y;

    nxh = x + width;
    nyh = y + height;

    for (int i = 1,n = maxiterations - iteration; i &lt; n; i++)
    {
        nx = (nx / 2) - 1;
        ny = (ny / 2) - 1;
        nxh = 1 -(-nxh/2);
        nyh = 1 -(-nyh/2);
    }

    xoff = -2*((nx/2)) + nx + 1;
    yoff = -2*((ny/2)) + ny + 1;

    cx = (nx / 2) - 1;
    cy = (ny / 2) - 1;
    cxh = 1 -(-nxh/2);
    cyh = 1 -(-nyh/2);

    nwidth = nxh - nx;
    nheight = nyh - ny;

    cwidth = cxh - cx;
    cheight = cyh - cy;

    /// rest
    fieldwidth=cwidth;
    fieldheight=cheight;

    /// Only happens once
    if (field==NULL)
    {
        /// allocate memory
        field = new int[height * width];

        /// blank value
        for (int x = 0; x &lt; width; x++)
        {
            for (int y = 0; y &lt; height; y++)
            {
                field[x+(y*width)]=0;
            }
        }
    }

    /// First loop
    for (int j = 0, m=cwidth; j &lt; m; j++)
    {
        for (int k = 0, n=cheight; k &lt; n; k++)
        {
            field[j+(k*m)] += (hashrandom( {cx + j, cy + k, iteration}) &amp; (1 &lt;&lt; (7 - iteration)));
        }
    }

    /// Up sampled
    int * upsampled = new int[(fieldwidth*2)*(fieldheight*2)];
    long int upsampledsize=(fieldwidth*2)*(fieldheight*2);

    for (int j = 0, m=fieldwidth*2; j &lt; m; j++)
    {
        for (int k = 0,n=fieldheight*2; k &lt; n; k++)
        {
            upsampled[j+(k*m)] = field[(j / 2)+((k / 2)*fieldwidth)];
        }
    }

    memmove((void *)field,(void *) upsampled,upsampledsize*sizeof(int));
    delete upsampled;

    /// rest
    fieldwidth=fieldwidth*2;
    fieldheight=fieldheight*2;

    /// Blur field
    int * blurfield =new int[(fieldwidth-2)*(fieldheight-2)];
    long int blurfieldsize = (fieldwidth-2)*(fieldheight-2);

    for (int j = 0,m=fieldwidth-2; j &lt; m; j++)
    {
        for (int k = 0, n=fieldheight-2;  k &lt; n; k++)
        {
            for (int h = 0; h &lt; 9; h++)
            {
                blurfield[j+(k*m)] += field[(j + (h % 3))+((k+(h/ 3))*fieldwidth)];
            }
            blurfield[j+(k*m)] /= 9;
        }
    }

    memmove((void *)field,(void *)blurfield,blurfieldsize*sizeof(int));
    delete blurfield;

    /// rest
    fieldwidth=fieldwidth-2;
    fieldheight=fieldheight-2;

    /// Trim field
    int * trimfield = new int[nwidth*nheight];
    long int trimfieldsize = nwidth*nheight;

    for (int j = 0, m=nwidth; j &lt; m; j++)
    {
        for (int k = 0, n=nheight; k &lt; n; k++)
        {
            trimfield[j+(k*m)] = field[(j + xoff)+((k + yoff)*fieldwidth)];
        }
    }

    /// create new
    memmove((void *)field,(void *)trimfield,trimfieldsize*sizeof(int));

    delete trimfield;
}

SaveTerrFile(field, width, "output.png");

return field;
</code></pre>
<p>}</p>
<p>int OlsenNoise2D::hashrandom(std::vector elements)<br/>
{<br/>
long long hashcalc = 0;</p>
<pre><code>for (int i = 0; i &lt; elements.size(); i++)
{
    hashcalc ^= elements[i];
    hashcalc = hash(hashcalc);
}
return (int) hashcalc;
</code></pre>
<p>};</p>
<p>long long OlsenNoise2D::hash(long long v)<br/>
{<br/>
long long hash = v;<br/>
long long h = hash;</p>
<pre><code>switch ((int) hash &amp; 3)
{
case 3:
    hash += h;
    hash ^= hash &lt;&lt; 32;
    hash ^= h &lt;&lt; 36;
    hash += hash &gt;&gt; 22;
    break;
case 2:
    hash += h;
    hash ^= hash &lt;&lt; 22;
    hash += hash &gt;&gt; 34;
    break;
case 1:
    hash += h;
    hash ^= hash &lt;&lt; 20;
    hash += hash &gt;&gt; 2;
}
hash ^= hash &lt;&lt; 6;
hash += hash &gt;&gt; 10;
hash ^= hash &lt;&lt; 8;
hash += hash &gt;&gt; 34;
hash ^= hash &lt;&lt; 50;
hash += hash &gt;&gt; 12;
return hash;
</code></pre>
<p>};</p>
<p>int main()<br/>
{<br/>
/// Test<br/>
int ImageSize=2048;</p>
<pre><code>int * imageInput = new int[ImageSize*ImageSize];

/// Image
OlsenNoise2D testingolsen;
imageInput=testingolsen.olsennoise(1,1,ImageSize,ImageSize);

// SaveTerrFile(imageInput, ImageSize, "rgbOlsen.png");

delete imageInput;

return 1;
</code></pre>
<p>}</p>
<p>void SaveTerrFile(const int * image, int size, char * filename)<br/>
{<br/>
png::image&lt; png::rgb_pixel &gt; newimage(size, size);</p>
<pre><code>for (unsigned int y = 0; y &lt; newimage.get_width(); ++y)
{
    for (unsigned int x = 0; x &lt; newimage.get_height(); ++x)
    {
        int col = int(image[x+(y*newimage.get_width())]);
        newimage[y][x] = png::rgb_pixel(col,col,col);
        // non-checking equivalent of image.set_pixel(x, y, ...);
    }
}

newimage.write(filename);
</code></pre>
<p>}</p>
<p>[/code]</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/357_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">JTippetts</div>
          <div class="post_content">
<p>I get a segfault at the line <span class="bbcode-b">memmove((void *)field,(void <em>) upsampled,upsampledsize</em>sizeof(int));</span></p>
<p>That olsennoise() method looks like a prime candidate for being broken up into smaller functions. You’d probably have better luck isolating your bug that way.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>[quote=“JTippetts”]I get a segfault at the line <span class="bbcode-b">memmove((void *)field,(void <em>) upsampled,upsampledsize</em>sizeof(int));</span></p>
<p>That olsennoise() method looks like a prime candidate for being broken up into smaller functions. You’d probably have better luck isolating your bug that way.[/quote]</p>
<p>Yea. I was working on the code last night.</p>
<p>Working copy image<br/>
The <a href="http://imgur.com/a/ei4dF" rel="nofollow noopener">imgur.com/a/ei4dF</a></p>
<p>Working copy<br/>
<a href="http://pastebin.com/iZUPJThc" rel="nofollow noopener">pastebin.com/iZUPJThc</a></p>
<p>There is a slight issue with the edge maybe because of low numbers from the calculation process since(Mentioned by the author). I removed memmov. I was mixing memmov with c++ allocation methods of delete[] and new. If that’s figured out as to the edge, then you have infinite terrain dirt fast that’s reasonable and probably better then diamond square method.</p>
<p>The developer is trying to work on a fix to the problem <a href="http://godsnotwheregodsnot.blogspot.com/2014/08/3d-olsen-noise.html" rel="nofollow noopener">godsnotwheregodsnot.blogspot.com … noise.html</a></p>
<p>His code is at <a href="http://pastebin.com/BdVY9wXN" rel="nofollow noopener">pastebin.com/BdVY9wXN</a></p>
<p>My code is at <a href="http://pastebin.com/LTww8EQr" rel="nofollow noopener">pastebin.com/LTww8EQr</a></p>
<p>Since I changing code from a array to a pointer array. Basically [x][y] to [x*(y<em>width)]. I have to find every [y] and change it to [y</em>width] that matches that specific code and function which takes me longer. Since, I already converted the previous code, it is a little bit faster and deciphering Java.</p>
<p>Vivienne</p>
<p>BTW, the guy wants to make a Android app to Demostrate. I see this as a possible why to get a noise generator in Urho3d and to highlight Urho3D. He made a 3D version also.</p>
          </div>
        </div>
      </div>

      <div class="post_container">
        <div class="avatar_container">
          <img src="../../../images/942_2.png" class="avatar" />
        </div>
        <div class="post">
          <div class="user_name">vivienneanthony</div>
          <div class="post_content">
<p>[quote=“JTippetts”]I get a segfault at the line <span class="bbcode-b">memmove((void *)field,(void <em>) upsampled,upsampledsize</em>sizeof(int));</span></p>
<p>That olsennoise() method looks like a prime candidate for being broken up into smaller functions. You’d probably have better luck isolating your bug that way.[/quote]</p>
<p>These are images of the generated textured loaded into the Urho3D editor Terrain node.</p>
<p><a href="http://imgur.com/a/p42gb" rel="nofollow noopener">imgur.com/a/p42gb</a></p>
<p>I think it’s infinite like STB Perlin just setting (x,y).</p>
<p>Since the terrain blend works. It sounds like a fresh mix of infinite terrain.</p>
<p>Note, just want to create a way to make roads, maybe generate a path then use it to mask or alter the heightmap,</p>
          </div>
        </div>
      </div>


    </div>
  </body>
</html>